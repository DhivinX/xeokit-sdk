function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var id = 0;
function _classPrivateFieldLooseKey(name) {
  return "__private_" + id++ + "_" + name;
}
function _classPrivateFieldLooseBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}

var _ievent = /*#__PURE__*/_classPrivateFieldLooseKey("ievent");
/**
 * Event emitter.
 *
 * @typeParam TSender - Type of the event sender
 * @typeParam TArgs - Type of the event argument
 */
var EventEmitter = /*#__PURE__*/function () {
  function EventEmitter(ievent) {
    Object.defineProperty(this, _ievent, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _ievent)[_ievent] = ievent;
  }
  /**
   * Returns the number of subscriptions.
   */
  var _proto = EventEmitter.prototype;
  /**
   * Subscribe to the event.
   *
   * @param func The event handler that is called when the event is dispatched.
   * @returns Function that unsubscribes the event handler from the event.
   */
  _proto.subscribe = function subscribe(func) {
    return _classPrivateFieldLooseBase(this, _ievent)[_ievent].asEvent().subscribe(func);
  }
  /**
   * @private
   * @param sender
   * @param args
   */;
  _proto.dispatch = function dispatch(sender, args) {
    _classPrivateFieldLooseBase(this, _ievent)[_ievent].dispatch(sender, args);
  }
  /**
   * Subscribe to the event.
   * @param func The event handler that is called when the event is dispatched.
   * @returns A function that unsubscribes the event handler from the event.
   */;
  _proto.sub = function sub(func) {
    return _classPrivateFieldLooseBase(this, _ievent)[_ievent].asEvent().sub(func);
  }
  /**
   * Unsubscribe from the event.
   * @param func The event handler that will be unsubsribed from the event.
   */;
  _proto.unsubscribe = function unsubscribe(func) {
    _classPrivateFieldLooseBase(this, _ievent)[_ievent].asEvent().unsubscribe(func);
  }
  /**
   * Unsubscribe from the event.
   * @param func The event handler that will be unsubsribed from the event.
   */;
  _proto.unsub = function unsub(func) {
    _classPrivateFieldLooseBase(this, _ievent)[_ievent].asEvent().unsub(func);
  }
  /**
   * Subscribes to the event only once.
   * @param func The event handler that is called when the event is dispatched.
   * @returns A function that unsubscribes the event handler from the event.
   */;
  _proto.one = function one(func) {
    return _classPrivateFieldLooseBase(this, _ievent)[_ievent].asEvent().one(func);
  }
  /**
   * Checks if the event has a subscription for the specified handler.
   * @param func The event handler.
   */;
  _proto.has = function has(func) {
    return _classPrivateFieldLooseBase(this, _ievent)[_ievent].asEvent().has(func);
  }
  /**
   * Clears all the subscriptions.
   */;
  _proto.clear = function clear() {
    _classPrivateFieldLooseBase(this, _ievent)[_ievent].asEvent().clear();
  };
  _createClass(EventEmitter, [{
    key: "count",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _ievent)[_ievent].count;
    }
  }]);
  return EventEmitter;
}();

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

var DispatcherWrapper_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.DispatcherWrapper = void 0;
/**
 * Hides the implementation of the event dispatcher. Will expose methods that
 * are relevent to the event.
 *
 * @export
 * @class DispatcherWrapper
 * @implements {ISubscribable<TEventHandler>}
 * @template TEventHandler The type of event handler.
 */
class DispatcherWrapper {
    /**
     * Creates an instance of DispatcherWrapper.
     * @param {ISubscribable<TEventHandler>} dispatcher
     *
     * @memberOf DispatcherWrapper
     */
    constructor(dispatcher) {
        this._subscribe = (fn) => dispatcher.subscribe(fn);
        this._unsubscribe = (fn) => dispatcher.unsubscribe(fn);
        this._one = (fn) => dispatcher.one(fn);
        this._has = (fn) => dispatcher.has(fn);
        this._clear = () => dispatcher.clear();
        this._count = () => dispatcher.count;
        this._onSubscriptionChange = () => dispatcher.onSubscriptionChange;
    }
    /**
     * Triggered when subscriptions are changed (added or removed).
     *
     * @readonly
     * @type {ISubscribable<SubscriptionChangeEventHandler>}
     * @memberOf DispatcherWrapper
     */
    get onSubscriptionChange() {
        return this._onSubscriptionChange();
    }
    /**
     * Returns the number of subscriptions.
     *
     * @readonly
     * @type {number}
     * @memberOf DispatcherWrapper
     */
    get count() {
        return this._count();
    }
    /**
     * Subscribe to the event dispatcher.
     *
     * @param {TEventHandler} fn The event handler that is called when the event is dispatched.
     * @returns {() => void} A function that unsubscribes the event handler from the event.
     *
     * @memberOf DispatcherWrapper
     */
    subscribe(fn) {
        return this._subscribe(fn);
    }
    /**
     * Subscribe to the event dispatcher.
     *
     * @param {TEventHandler} fn The event handler that is called when the event is dispatched.
     * @returns {() => void} A function that unsubscribes the event handler from the event.
     *
     * @memberOf DispatcherWrapper
     */
    sub(fn) {
        return this.subscribe(fn);
    }
    /**
     * Unsubscribe from the event dispatcher.
     *
     * @param {TEventHandler} fn The event handler that is called when the event is dispatched.
     *
     * @memberOf DispatcherWrapper
     */
    unsubscribe(fn) {
        this._unsubscribe(fn);
    }
    /**
     * Unsubscribe from the event dispatcher.
     *
     * @param {TEventHandler} fn The event handler that is called when the event is dispatched.
     *
     * @memberOf DispatcherWrapper
     */
    unsub(fn) {
        this.unsubscribe(fn);
    }
    /**
     * Subscribe once to the event with the specified name.
     *
     * @returns {() => void} A function that unsubscribes the event handler from the event.
     *
     * @memberOf DispatcherWrapper
     */
    one(fn) {
        return this._one(fn);
    }
    /**
     * Checks it the event has a subscription for the specified handler.
     *
     * @param {TEventHandler} fn The event handler that is called when the event is dispatched.
     *
     * @memberOf DispatcherWrapper
     */
    has(fn) {
        return this._has(fn);
    }
    /**
     * Clears all the subscriptions.
     *
     * @memberOf DispatcherWrapper
     */
    clear() {
        this._clear();
    }
}
exports.DispatcherWrapper = DispatcherWrapper;
});

var Subscription_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Subscription = void 0;
/**
 * Stores a handler. Manages execution meta data.
 * @class Subscription
 * @template TEventHandler
 */
class Subscription {
    /**
     * Creates an instance of Subscription.
     *
     * @param {TEventHandler} handler The handler for the subscription.
     * @param {boolean} isOnce Indicates if the handler should only be executed once.
     */
    constructor(handler, isOnce) {
        this.handler = handler;
        this.isOnce = isOnce;
        /**
         * Indicates if the subscription has been executed before.
         */
        this.isExecuted = false;
    }
    /**
     * Executes the handler.
     *
     * @param {boolean} executeAsync True if the even should be executed async.
     * @param {*} scope The scope the scope of the event.
     * @param {IArguments} args The arguments for the event.
     */
    execute(executeAsync, scope, args) {
        if (!this.isOnce || !this.isExecuted) {
            this.isExecuted = true;
            var fn = this.handler;
            if (executeAsync) {
                setTimeout(() => {
                    fn.apply(scope, args);
                }, 1);
            }
            else {
                fn.apply(scope, args);
            }
        }
    }
}
exports.Subscription = Subscription;
});

var EventManagement_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventManagement = void 0;
/**
 * Allows the user to interact with the event.
 *
 * @export
 * @class EventManagement
 * @implements {IEventManagement}
 */
class EventManagement {
    /**
     * Creates an instance of EventManagement.
     * @param {() => void} unsub An unsubscribe handler.
     *
     * @memberOf EventManagement
     */
    constructor(unsub) {
        this.unsub = unsub;
        this.propagationStopped = false;
    }
    /**
     * Stops the propagation of the event.
     * Cannot be used when async dispatch is done.
     *
     * @memberOf EventManagement
     */
    stopPropagation() {
        this.propagationStopped = true;
    }
}
exports.EventManagement = EventManagement;
});

var DispatcherBase_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubscriptionChangeEventDispatcher = exports.DispatcherBase = void 0;



/**
 * Base class for implementation of the dispatcher. It facilitates the subscribe
 * and unsubscribe methods based on generic handlers. The TEventType specifies
 * the type of event that should be exposed. Use the asEvent to expose the
 * dispatcher as event.
 *
 * @export
 * @abstract
 * @class DispatcherBase
 * @implements {ISubscribable<TEventHandler>}
 * @template TEventHandler The type of event handler.
 */
class DispatcherBase {
    constructor() {
        /**
         * The subscriptions.
         *
         * @protected
         *
         * @memberOf DispatcherBase
         */
        this._subscriptions = new Array();
    }
    /**
     * Returns the number of subscriptions.
     *
     * @readonly
     * @type {number}
     * @memberOf DispatcherBase
     */
    get count() {
        return this._subscriptions.length;
    }
    /**
     * Triggered when subscriptions are changed (added or removed).
     *
     * @readonly
     * @type {ISubscribable<SubscriptionChangeEventHandler>}
     * @memberOf DispatcherBase
     */
    get onSubscriptionChange() {
        if (this._onSubscriptionChange == null) {
            this._onSubscriptionChange = new SubscriptionChangeEventDispatcher();
        }
        return this._onSubscriptionChange.asEvent();
    }
    /**
     * Subscribe to the event dispatcher.
     *
     * @param {TEventHandler} fn The event handler that is called when the event is dispatched.
     * @returns A function that unsubscribes the event handler from the event.
     *
     * @memberOf DispatcherBase
     */
    subscribe(fn) {
        if (fn) {
            this._subscriptions.push(this.createSubscription(fn, false));
            this.triggerSubscriptionChange();
        }
        return () => {
            this.unsubscribe(fn);
        };
    }
    /**
     * Subscribe to the event dispatcher.
     *
     * @param {TEventHandler} fn The event handler that is called when the event is dispatched.
     * @returns A function that unsubscribes the event handler from the event.
     *
     * @memberOf DispatcherBase
     */
    sub(fn) {
        return this.subscribe(fn);
    }
    /**
     * Subscribe once to the event with the specified name.
     *
     * @param {TEventHandler} fn The event handler that is called when the event is dispatched.
     * @returns A function that unsubscribes the event handler from the event.
     *
     * @memberOf DispatcherBase
     */
    one(fn) {
        if (fn) {
            this._subscriptions.push(this.createSubscription(fn, true));
            this.triggerSubscriptionChange();
        }
        return () => {
            this.unsubscribe(fn);
        };
    }
    /**
     * Checks it the event has a subscription for the specified handler.
     *
     * @param {TEventHandler} fn The event handler.
     *
     * @memberOf DispatcherBase
     */
    has(fn) {
        if (!fn)
            return false;
        return this._subscriptions.some((sub) => sub.handler == fn);
    }
    /**
     * Unsubscribes the handler from the dispatcher.
     *
     * @param {TEventHandler} fn The event handler.
     *
     * @memberOf DispatcherBase
     */
    unsubscribe(fn) {
        if (!fn)
            return;
        let changes = false;
        for (let i = 0; i < this._subscriptions.length; i++) {
            if (this._subscriptions[i].handler == fn) {
                this._subscriptions.splice(i, 1);
                changes = true;
                break;
            }
        }
        if (changes) {
            this.triggerSubscriptionChange();
        }
    }
    /**
     * Unsubscribes the handler from the dispatcher.
     *
     * @param {TEventHandler} fn The event handler.
     *
     * @memberOf DispatcherBase
     */
    unsub(fn) {
        this.unsubscribe(fn);
    }
    /**
     * Generic dispatch will dispatch the handlers with the given arguments.
     *
     * @protected
     * @param {boolean} executeAsync `True` if the even should be executed async.
     * @param {*} scope The scope of the event. The scope becomes the `this` for handler.
     * @param {IArguments} args The arguments for the event.
     * @returns {(IPropagationStatus | null)} The propagation status, or if an `executeAsync` is used `null`.
     *
     * @memberOf DispatcherBase
     */
    _dispatch(executeAsync, scope, args) {
        //execute on a copy because of bug #9
        for (let sub of [...this._subscriptions]) {
            let ev = new EventManagement_1.EventManagement(() => this.unsub(sub.handler));
            let nargs = Array.prototype.slice.call(args);
            nargs.push(ev);
            let s = sub;
            s.execute(executeAsync, scope, nargs);
            //cleanup subs that are no longer needed
            this.cleanup(sub);
            if (!executeAsync && ev.propagationStopped) {
                return { propagationStopped: true };
            }
        }
        if (executeAsync) {
            return null;
        }
        return { propagationStopped: false };
    }
    /**
     * Creates a subscription.
     *
     * @protected
     * @param {TEventHandler} handler The handler.
     * @param {boolean} isOnce True if the handler should run only one.
     * @returns {ISubscription<TEventHandler>} The subscription.
     *
     * @memberOf DispatcherBase
     */
    createSubscription(handler, isOnce) {
        return new Subscription_1.Subscription(handler, isOnce);
    }
    /**
     * Cleans up subs that ran and should run only once.
     *
     * @protected
     * @param {ISubscription<TEventHandler>} sub The subscription.
     *
     * @memberOf DispatcherBase
     */
    cleanup(sub) {
        let changes = false;
        if (sub.isOnce && sub.isExecuted) {
            let i = this._subscriptions.indexOf(sub);
            if (i > -1) {
                this._subscriptions.splice(i, 1);
                changes = true;
            }
        }
        if (changes) {
            this.triggerSubscriptionChange();
        }
    }
    /**
     * Creates an event from the dispatcher. Will return the dispatcher
     * in a wrapper. This will prevent exposure of any dispatcher methods.
     *
     * @returns {ISubscribable<TEventHandler>}
     *
     * @memberOf DispatcherBase
     */
    asEvent() {
        if (this._wrap == null) {
            this._wrap = new DispatcherWrapper_1.DispatcherWrapper(this);
        }
        return this._wrap;
    }
    /**
     * Clears the subscriptions.
     *
     * @memberOf DispatcherBase
     */
    clear() {
        if (this._subscriptions.length != 0) {
            this._subscriptions.splice(0, this._subscriptions.length);
            this.triggerSubscriptionChange();
        }
    }
    /**
     * Triggers the subscription change event.
     *
     * @private
     *
     * @memberOf DispatcherBase
     */
    triggerSubscriptionChange() {
        if (this._onSubscriptionChange != null) {
            this._onSubscriptionChange.dispatch(this.count);
        }
    }
}
exports.DispatcherBase = DispatcherBase;
/**
 * Dispatcher for subscription changes.
 *
 * @export
 * @class SubscriptionChangeEventDispatcher
 * @extends {DispatcherBase<SubscriptionChangeEventHandler>}
 */
class SubscriptionChangeEventDispatcher extends DispatcherBase {
    /**
     * Dispatches the event.
     *
     * @param {number} count The currrent number of subscriptions.
     *
     * @memberOf SubscriptionChangeEventDispatcher
     */
    dispatch(count) {
        this._dispatch(false, this, arguments);
    }
}
exports.SubscriptionChangeEventDispatcher = SubscriptionChangeEventDispatcher;
});

var DispatchError_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.DispatchError = void 0;
/**
 * Indicates an error with dispatching.
 *
 * @export
 * @class DispatchError
 * @extends {Error}
 */
class DispatchError extends Error {
    /**
     * Creates an instance of DispatchError.
     * @param {string} message The message.
     *
     * @memberOf DispatchError
     */
    constructor(message) {
        super(message);
    }
}
exports.DispatchError = DispatchError;
});

var EventListBase_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventListBase = void 0;
/**
 * Base class for event lists classes. Implements the get and remove.
 *
 * @export
 * @abstract
 * @class EventListBaset
 * @template TEventDispatcher The type of event dispatcher.
 */
class EventListBase {
    constructor() {
        this._events = {};
    }
    /**
     * Gets the dispatcher associated with the name.
     *
     * @param {string} name The name of the event.
     * @returns {TEventDispatcher} The disptacher.
     *
     * @memberOf EventListBase
     */
    get(name) {
        let event = this._events[name];
        if (event) {
            return event;
        }
        event = this.createDispatcher();
        this._events[name] = event;
        return event;
    }
    /**
     * Removes the dispatcher associated with the name.
     *
     * @param {string} name
     *
     * @memberOf EventListBase
     */
    remove(name) {
        delete this._events[name];
    }
}
exports.EventListBase = EventListBase;
});

var HandlingBase_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.HandlingBase = void 0;
/**
 * Base class that implements event handling. With a an
 * event list this base class will expose events that can be
 * subscribed to. This will give your class generic events.
 *
 * @export
 * @abstract
 * @class HandlingBase
 * @template TEventHandler The type of event handler.
 * @template TDispatcher The type of dispatcher.
 * @template TList The type of event list.
 */
class HandlingBase {
    /**
     * Creates an instance of HandlingBase.
     * @param {TList} events The event list. Used for event management.
     *
     * @memberOf HandlingBase
     */
    constructor(events) {
        this.events = events;
    }
    /**
     * Subscribes once to the event with the specified name.
     * @param {string} name The name of the event.
     * @param {TEventHandler} fn The event handler.
     *
     * @memberOf HandlingBase
     */
    one(name, fn) {
        this.events.get(name).one(fn);
    }
    /**
     * Checks it the event has a subscription for the specified handler.
     * @param {string} name The name of the event.
     * @param {TEventHandler} fn The event handler.
     *
     * @memberOf HandlingBase
     */
    has(name, fn) {
        return this.events.get(name).has(fn);
    }
    /**
     * Subscribes to the event with the specified name.
     * @param {string} name The name of the event.
     * @param {TEventHandler} fn The event handler.
     *
     * @memberOf HandlingBase
     */
    subscribe(name, fn) {
        this.events.get(name).subscribe(fn);
    }
    /**
     * Subscribes to the event with the specified name.
     * @param {string} name The name of the event.
     * @param {TEventHandler} fn The event handler.
     *
     * @memberOf HandlingBase
     */
    sub(name, fn) {
        this.subscribe(name, fn);
    }
    /**
     * Unsubscribes from the event with the specified name.
     * @param {string} name The name of the event.
     * @param {TEventHandler} fn The event handler.
     *
     * @memberOf HandlingBase
     */
    unsubscribe(name, fn) {
        this.events.get(name).unsubscribe(fn);
    }
    /**
     * Unsubscribes from the event with the specified name.
     * @param {string} name The name of the event.
     * @param {TEventHandler} fn The event handler.
     *
     * @memberOf HandlingBase
     */
    unsub(name, fn) {
        this.unsubscribe(name, fn);
    }
}
exports.HandlingBase = HandlingBase;
});

var PromiseSubscription_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseSubscription = void 0;
/**
 * Subscription implementation for events with promises.
 *
 * @export
 * @class PromiseSubscription
 * @implements {ISubscription<TEventHandler>}
 * @template TEventHandler The type of event handler.
 */
class PromiseSubscription {
    /**
     * Creates an instance of PromiseSubscription.
     * @param {TEventHandler} handler The handler for the subscription.
     * @param {boolean} isOnce Indicates if the handler should only be executed once.
     *
     * @memberOf PromiseSubscription
     */
    constructor(handler, isOnce) {
        this.handler = handler;
        this.isOnce = isOnce;
        /**
         * Indicates if the subscription has been executed before.
         *
         * @memberOf PromiseSubscription
         */
        this.isExecuted = false;
    }
    /**
     * Executes the handler.
     *
     * @param {boolean} executeAsync True if the even should be executed async.
     * @param {*} scope The scope the scope of the event.
     * @param {IArguments} args The arguments for the event.
     *
     * @memberOf PromiseSubscription
     */
    async execute(executeAsync, scope, args) {
        if (!this.isOnce || !this.isExecuted) {
            this.isExecuted = true;
            //TODO: do we need to cast to any -- seems yuck
            var fn = this.handler;
            if (executeAsync) {
                setTimeout(() => {
                    fn.apply(scope, args);
                }, 1);
                return;
            }
            let result = fn.apply(scope, args);
            await result;
        }
    }
}
exports.PromiseSubscription = PromiseSubscription;
});

var PromiseDispatcherBase_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseDispatcherBase = void 0;




/**
 * Dispatcher base for dispatchers that use promises. Each promise
 * is awaited before the next is dispatched, unless the event is
 * dispatched with the executeAsync flag.
 *
 * @export
 * @abstract
 * @class PromiseDispatcherBase
 * @extends {DispatcherBase<TEventHandler>}
 * @template TEventHandler The type of event handler.
 */
class PromiseDispatcherBase extends DispatcherBase_1.DispatcherBase {
    /**
     * The normal dispatch cannot be used in this class.
     *
     * @protected
     * @param {boolean} executeAsync `True` if the even should be executed async.
     * @param {*} scope The scope of the event. The scope becomes the `this` for handler.
     * @param {IArguments} args The arguments for the event.
     * @returns {(IPropagationStatus | null)} The propagation status, or if an `executeAsync` is used `null`.
     *
     * @memberOf DispatcherBase
     */
    _dispatch(executeAsync, scope, args) {
        throw new DispatchError_1.DispatchError("_dispatch not supported. Use _dispatchAsPromise.");
    }
    /**
     * Crates a new subscription.
     *
     * @protected
     * @param {TEventHandler} handler The handler.
     * @param {boolean} isOnce Indicates if the handler should only run once.
     * @returns {ISubscription<TEventHandler>} The subscription.
     *
     * @memberOf PromiseDispatcherBase
     */
    createSubscription(handler, isOnce) {
        return new PromiseSubscription_1.PromiseSubscription(handler, isOnce);
    }
    /**
     * Generic dispatch will dispatch the handlers with the given arguments.
     *
     * @protected
     * @param {boolean} executeAsync `True` if the even should be executed async.
     * @param {*} scope The scope of the event. The scope becomes the `this` for handler.
     * @param {IArguments} args The arguments for the event.
     * @returns {(IPropagationStatus | null)} The propagation status, or if an `executeAsync` is used `null`.
     *
     * @memberOf DispatcherBase
     */
    async _dispatchAsPromise(executeAsync, scope, args) {
        //execute on a copy because of bug #9
        for (let sub of [...this._subscriptions]) {
            let ev = new EventManagement_1.EventManagement(() => this.unsub(sub.handler));
            let nargs = Array.prototype.slice.call(args);
            nargs.push(ev);
            let ps = sub;
            await ps.execute(executeAsync, scope, nargs);
            //cleanup subs that are no longer needed
            this.cleanup(sub);
            if (!executeAsync && ev.propagationStopped) {
                return { propagationStopped: true };
            }
        }
        if (executeAsync) {
            return null;
        }
        return { propagationStopped: false };
    }
}
exports.PromiseDispatcherBase = PromiseDispatcherBase;
});

var dist$7 = createCommonjsModule(function (module, exports) {
/*!
 * Strongly Typed Events for TypeScript - Core
 * https://github.com/KeesCBakker/StronlyTypedEvents/
 * http://keestalkstech.com
 *
 * Copyright Kees C. Bakker / KeesTalksTech
 * Released under the MIT license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubscriptionChangeEventDispatcher = exports.HandlingBase = exports.PromiseDispatcherBase = exports.PromiseSubscription = exports.DispatchError = exports.EventManagement = exports.EventListBase = exports.DispatcherWrapper = exports.DispatcherBase = exports.Subscription = void 0;

Object.defineProperty(exports, "DispatcherBase", { enumerable: true, get: function () { return DispatcherBase_1.DispatcherBase; } });
Object.defineProperty(exports, "SubscriptionChangeEventDispatcher", { enumerable: true, get: function () { return DispatcherBase_1.SubscriptionChangeEventDispatcher; } });

Object.defineProperty(exports, "DispatchError", { enumerable: true, get: function () { return DispatchError_1.DispatchError; } });

Object.defineProperty(exports, "DispatcherWrapper", { enumerable: true, get: function () { return DispatcherWrapper_1.DispatcherWrapper; } });

Object.defineProperty(exports, "EventListBase", { enumerable: true, get: function () { return EventListBase_1.EventListBase; } });

Object.defineProperty(exports, "EventManagement", { enumerable: true, get: function () { return EventManagement_1.EventManagement; } });

Object.defineProperty(exports, "HandlingBase", { enumerable: true, get: function () { return HandlingBase_1.HandlingBase; } });

Object.defineProperty(exports, "PromiseDispatcherBase", { enumerable: true, get: function () { return PromiseDispatcherBase_1.PromiseDispatcherBase; } });

Object.defineProperty(exports, "PromiseSubscription", { enumerable: true, get: function () { return PromiseSubscription_1.PromiseSubscription; } });

Object.defineProperty(exports, "Subscription", { enumerable: true, get: function () { return Subscription_1.Subscription; } });
});

var EventDispatcher_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventDispatcher = void 0;

/**
 * Dispatcher implementation for events. Can be used to subscribe, unsubscribe
 * or dispatch events. Use the ToEvent() method to expose the event.
 *
 * @export
 * @class EventDispatcher
 * @extends {DispatcherBase<IEventHandler<TSender, TArgs>>}
 * @implements {IEvent<TSender, TArgs>}
 * @template TSender The sender type.
 * @template TArgs The event arguments type.
 */
class EventDispatcher extends dist$7.DispatcherBase {
    /**
     * Creates an instance of EventDispatcher.
     *
     * @memberOf EventDispatcher
     */
    constructor() {
        super();
    }
    /**
     * Dispatches the event.
     *
     * @param {TSender} sender The sender.
     * @param {TArgs} args The arguments.
     * @returns {IPropagationStatus} The propagation status to interact with the event
     *
     * @memberOf EventDispatcher
     */
    dispatch(sender, args) {
        const result = this._dispatch(false, this, arguments);
        if (result == null) {
            throw new dist$7.DispatchError("Got `null` back from dispatch.");
        }
        return result;
    }
    /**
     * Dispatches the event in an async way. Does not support event interaction.
     *
     * @param {TSender} sender The sender.
     * @param {TArgs} args The arguments.
     *
     * @memberOf EventDispatcher
     */
    dispatchAsync(sender, args) {
        this._dispatch(true, this, arguments);
    }
    /**
     * Creates an event from the dispatcher. Will return the dispatcher
     * in a wrapper. This will prevent exposure of any dispatcher methods.
     *
     * @returns {IEvent<TSender, TArgs>} The event.
     *
     * @memberOf EventDispatcher
     */
    asEvent() {
        return super.asEvent();
    }
}
exports.EventDispatcher = EventDispatcher;
});

var EventList_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventList = void 0;


/**
 * Storage class for multiple events that are accessible by name.
 * Events dispatchers are automatically created.
 */
class EventList extends dist$7.EventListBase {
    /**
     * Creates a new EventList instance.
     */
    constructor() {
        super();
    }
    /**
     * Creates a new dispatcher instance.
     */
    createDispatcher() {
        return new EventDispatcher_1.EventDispatcher();
    }
}
exports.EventList = EventList;
});

var EventHandlingBase_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventHandlingBase = void 0;


/**
 * Extends objects with signal event handling capabilities.
 */
class EventHandlingBase extends dist$7.HandlingBase {
    constructor() {
        super(new EventList_1.EventList());
    }
}
exports.EventHandlingBase = EventHandlingBase;
});

var NonUniformEventList_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonUniformEventList = void 0;

/**
 * Similar to EventList, but instead of TArgs, a map of event names ang argument types is provided with TArgsMap.
 */
class NonUniformEventList {
    constructor() {
        this._events = {};
    }
    /**
     * Gets the dispatcher associated with the name.
     * @param name The name of the event.
     */
    get(name) {
        if (this._events[name]) {
            // @TODO avoid typecasting. Not sure why TS thinks this._events[name] could still be undefined.
            return this._events[name];
        }
        const event = this.createDispatcher();
        this._events[name] = event;
        return event;
    }
    /**
     * Removes the dispatcher associated with the name.
     * @param name The name of the event.
     */
    remove(name) {
        delete this._events[name];
    }
    /**
     * Creates a new dispatcher instance.
     */
    createDispatcher() {
        return new EventDispatcher_1.EventDispatcher();
    }
}
exports.NonUniformEventList = NonUniformEventList;
});

var dist$6 = createCommonjsModule(function (module, exports) {
/*!
 * Strongly Typed Events for TypeScript - Core
 * https://github.com/KeesCBakker/StronlyTypedEvents/
 * http://keestalkstech.com
 *
 * Copyright Kees C. Bakker / KeesTalksTech
 * Released under the MIT license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonUniformEventList = exports.EventList = exports.EventHandlingBase = exports.EventDispatcher = void 0;

Object.defineProperty(exports, "EventDispatcher", { enumerable: true, get: function () { return EventDispatcher_1.EventDispatcher; } });

Object.defineProperty(exports, "EventHandlingBase", { enumerable: true, get: function () { return EventHandlingBase_1.EventHandlingBase; } });

Object.defineProperty(exports, "EventList", { enumerable: true, get: function () { return EventList_1.EventList; } });

Object.defineProperty(exports, "NonUniformEventList", { enumerable: true, get: function () { return NonUniformEventList_1.NonUniformEventList; } });
});

var SimpleEventDispatcher_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleEventDispatcher = void 0;

/**
 * The dispatcher handles the storage of subsciptions and facilitates
 * subscription, unsubscription and dispatching of a simple event
 *
 * @export
 * @class SimpleEventDispatcher
 * @extends {DispatcherBase<ISimpleEventHandler<TArgs>>}
 * @implements {ISimpleEvent<TArgs>}
 * @template TArgs
 */
class SimpleEventDispatcher extends dist$7.DispatcherBase {
    /**
     * Creates an instance of SimpleEventDispatcher.
     *
     * @memberOf SimpleEventDispatcher
     */
    constructor() {
        super();
    }
    /**
     * Dispatches the event.
     *
     * @param {TArgs} args The arguments object.
     * @returns {IPropagationStatus} The status of the event.
     *
     * @memberOf SimpleEventDispatcher
     */
    dispatch(args) {
        const result = this._dispatch(false, this, arguments);
        if (result == null) {
            throw new dist$7.DispatchError("Got `null` back from dispatch.");
        }
        return result;
    }
    /**
     * Dispatches the event without waiting for the result.
     *
     * @param {TArgs} args The arguments object.
     *
     * @memberOf SimpleEventDispatcher
     */
    dispatchAsync(args) {
        this._dispatch(true, this, arguments);
    }
    /**
     * Creates an event from the dispatcher. Will return the dispatcher
     * in a wrapper. This will prevent exposure of any dispatcher methods.
     *
     * @returns {ISimpleEvent<TArgs>} The event.
     *
     * @memberOf SimpleEventDispatcher
     */
    asEvent() {
        return super.asEvent();
    }
}
exports.SimpleEventDispatcher = SimpleEventDispatcher;
});

var SimpleEventList_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleEventList = void 0;


/**
 * Storage class for multiple simple events that are accessible by name.
 * Events dispatchers are automatically created.
 */
class SimpleEventList extends dist$7.EventListBase {
    /**
     * Creates a new SimpleEventList instance.
     */
    constructor() {
        super();
    }
    /**
     * Creates a new dispatcher instance.
     */
    createDispatcher() {
        return new SimpleEventDispatcher_1.SimpleEventDispatcher();
    }
}
exports.SimpleEventList = SimpleEventList;
});

var SimpleEventHandlingBase_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleEventHandlingBase = void 0;


/**
 * Extends objects with signal event handling capabilities.
 */
class SimpleEventHandlingBase extends dist$7.HandlingBase {
    constructor() {
        super(new SimpleEventList_1.SimpleEventList());
    }
}
exports.SimpleEventHandlingBase = SimpleEventHandlingBase;
});

var NonUniformSimpleEventList_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonUniformSimpleEventList = void 0;

/**
 * Similar to EventList, but instead of TArgs, a map of event names ang argument types is provided with TArgsMap.
 */
class NonUniformSimpleEventList {
    constructor() {
        this._events = {};
    }
    /**
     * Gets the dispatcher associated with the name.
     * @param name The name of the event.
     */
    get(name) {
        if (this._events[name]) {
            // @TODO avoid typecasting. Not sure why TS thinks this._events[name] could still be undefined.
            return this._events[name];
        }
        const event = this.createDispatcher();
        this._events[name] = event;
        return event;
    }
    /**
     * Removes the dispatcher associated with the name.
     * @param name The name of the event.
     */
    remove(name) {
        delete this._events[name];
    }
    /**
     * Creates a new dispatcher instance.
     */
    createDispatcher() {
        return new SimpleEventDispatcher_1.SimpleEventDispatcher();
    }
}
exports.NonUniformSimpleEventList = NonUniformSimpleEventList;
});

var dist$5 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonUniformSimpleEventList = exports.SimpleEventList = exports.SimpleEventHandlingBase = exports.SimpleEventDispatcher = void 0;

Object.defineProperty(exports, "SimpleEventDispatcher", { enumerable: true, get: function () { return SimpleEventDispatcher_1.SimpleEventDispatcher; } });

Object.defineProperty(exports, "SimpleEventHandlingBase", { enumerable: true, get: function () { return SimpleEventHandlingBase_1.SimpleEventHandlingBase; } });

Object.defineProperty(exports, "NonUniformSimpleEventList", { enumerable: true, get: function () { return NonUniformSimpleEventList_1.NonUniformSimpleEventList; } });

Object.defineProperty(exports, "SimpleEventList", { enumerable: true, get: function () { return SimpleEventList_1.SimpleEventList; } });
});

var SignalDispatcher_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignalDispatcher = void 0;

/**
 * The dispatcher handles the storage of subsciptions and facilitates
 * subscription, unsubscription and dispatching of a signal event.
 *
 * @export
 * @class SignalDispatcher
 * @extends {DispatcherBase<ISignalHandler>}
 * @implements {ISignal}
 */
class SignalDispatcher extends dist$7.DispatcherBase {
    /**
     * Dispatches the signal.
     *
     * @returns {IPropagationStatus} The status of the signal.
     *
     * @memberOf SignalDispatcher
     */
    dispatch() {
        const result = this._dispatch(false, this, arguments);
        if (result == null) {
            throw new dist$7.DispatchError("Got `null` back from dispatch.");
        }
        return result;
    }
    /**
     * Dispatches the signal without waiting for the result.
     *
     * @memberOf SignalDispatcher
     */
    dispatchAsync() {
        this._dispatch(true, this, arguments);
    }
    /**
     * Creates an event from the dispatcher. Will return the dispatcher
     * in a wrapper. This will prevent exposure of any dispatcher methods.
     *
     * @returns {ISignal} The signal.
     *
     * @memberOf SignalDispatcher
     */
    asEvent() {
        return super.asEvent();
    }
}
exports.SignalDispatcher = SignalDispatcher;
});

var SignalList_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignalList = void 0;


/**
 * Storage class for multiple signal events that are accessible by name.
 * Events dispatchers are automatically created.
 *
 * @export
 * @class SignalList
 * @extends {EventListBase<SignalDispatcher>}
 */
class SignalList extends dist$7.EventListBase {
    /**
     * Creates an instance of SignalList.
     *
     * @memberOf SignalList
     */
    constructor() {
        super();
    }
    /**
     * Creates a new dispatcher instance.
     *
     * @protected
     * @returns {SignalDispatcher}
     *
     * @memberOf SignalList
     */
    createDispatcher() {
        return new SignalDispatcher_1.SignalDispatcher();
    }
}
exports.SignalList = SignalList;
});

var SignalHandlingBase_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignalHandlingBase = void 0;


/**
 * Extends objects with signal event handling capabilities.
 *
 * @export
 * @abstract
 * @class SignalHandlingBase
 * @extends {HandlingBase<ISignalHandler, SignalDispatcher, SignalList>}
 * @implements {ISignalHandling}
 */
class SignalHandlingBase extends dist$7.HandlingBase {
    /**
     * Creates an instance of SignalHandlingBase.
     *
     * @memberOf SignalHandlingBase
     */
    constructor() {
        super(new SignalList_1.SignalList());
    }
}
exports.SignalHandlingBase = SignalHandlingBase;
});

var dist$4 = createCommonjsModule(function (module, exports) {
/*!
 * Strongly Typed Events for TypeScript - Promise Signals
 * https://github.com/KeesCBakker/StronlyTypedEvents/
 * http://keestalkstech.com
 *
 * Copyright Kees C. Bakker / KeesTalksTech
 * Released under the MIT license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignalList = exports.SignalHandlingBase = exports.SignalDispatcher = void 0;

Object.defineProperty(exports, "SignalDispatcher", { enumerable: true, get: function () { return SignalDispatcher_1.SignalDispatcher; } });

Object.defineProperty(exports, "SignalHandlingBase", { enumerable: true, get: function () { return SignalHandlingBase_1.SignalHandlingBase; } });

Object.defineProperty(exports, "SignalList", { enumerable: true, get: function () { return SignalList_1.SignalList; } });
});

var PromiseEventDispatcher_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseEventDispatcher = void 0;

/**
 * Dispatcher implementation for events. Can be used to subscribe, unsubscribe
 * or dispatch events. Use the ToEvent() method to expose the event.
 *
 * @export
 * @class PromiseEventDispatcher
 * @extends {PromiseDispatcherBase<IPromiseEventHandler<TSender, TArgs>>}
 * @implements {IPromiseEvent<TSender, TArgs>}
 * @template TSender
 * @template TArgs
 */
class PromiseEventDispatcher extends dist$7.PromiseDispatcherBase {
    /**
     * Creates a new EventDispatcher instance.
     */
    constructor() {
        super();
    }
    /**
     * Dispatches the event.
     *
     * @param {TSender} sender The sender object.
     * @param {TArgs} args The argument object.
     * @returns {Promise<IPropagationStatus>} The status.
     *
     * @memberOf PromiseEventDispatcher
     */
    async dispatch(sender, args) {
        const result = await this._dispatchAsPromise(false, this, arguments);
        if (result == null) {
            throw new dist$7.DispatchError("Got `null` back from dispatch.");
        }
        return result;
    }
    /**
     * Dispatches the event without waiting for the result.
     *
     * @param {TSender} sender The sender object.
     * @param {TArgs} args The argument object.
     *
     * @memberOf PromiseEventDispatcher
     */
    dispatchAsync(sender, args) {
        this._dispatchAsPromise(true, this, arguments);
    }
    /**
     * Creates an event from the dispatcher. Will return the dispatcher
     * in a wrapper. This will prevent exposure of any dispatcher methods.
     */
    asEvent() {
        return super.asEvent();
    }
}
exports.PromiseEventDispatcher = PromiseEventDispatcher;
});

var PromiseEventList_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseEventList = void 0;


/**
 * Storage class for multiple events that are accessible by name.
 * Events dispatchers are automatically created.
 */
class PromiseEventList extends dist$7.EventListBase {
    /**
     * Creates a new EventList instance.
     */
    constructor() {
        super();
    }
    /**
     * Creates a new dispatcher instance.
     */
    createDispatcher() {
        return new PromiseEventDispatcher_1.PromiseEventDispatcher();
    }
}
exports.PromiseEventList = PromiseEventList;
});

var PromiseEventHandlingBase_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseEventHandlingBase = void 0;


/**
 * Extends objects with signal event handling capabilities.
 */
class PromiseEventHandlingBase extends dist$7.HandlingBase {
    constructor() {
        super(new PromiseEventList_1.PromiseEventList());
    }
}
exports.PromiseEventHandlingBase = PromiseEventHandlingBase;
});

var NonUniformPromiseEventList_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonUniformPromiseEventList = void 0;

/**
 * Similar to EventList, but instead of TArgs, a map of event names ang argument types is provided with TArgsMap.
 */
class NonUniformPromiseEventList {
    constructor() {
        this._events = {};
    }
    /**
     * Gets the dispatcher associated with the name.
     * @param name The name of the event.
     */
    get(name) {
        if (this._events[name]) {
            // @TODO avoid typecasting. Not sure why TS thinks this._events[name] could still be undefined.
            return this._events[name];
        }
        const event = this.createDispatcher();
        this._events[name] = event;
        return event;
    }
    /**
     * Removes the dispatcher associated with the name.
     * @param name The name of the event.
     */
    remove(name) {
        delete this._events[name];
    }
    /**
     * Creates a new dispatcher instance.
     */
    createDispatcher() {
        return new PromiseEventDispatcher_1.PromiseEventDispatcher();
    }
}
exports.NonUniformPromiseEventList = NonUniformPromiseEventList;
});

var dist$3 = createCommonjsModule(function (module, exports) {
/*!
 * Strongly Typed Events for TypeScript - Core
 * https://github.com/KeesCBakker/StronlyTypedEvents/
 * http://keestalkstech.com
 *
 * Copyright Kees C. Bakker / KeesTalksTech
 * Released under the MIT license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonUniformPromiseEventList = exports.PromiseEventList = exports.PromiseEventHandlingBase = exports.PromiseEventDispatcher = void 0;

Object.defineProperty(exports, "PromiseEventDispatcher", { enumerable: true, get: function () { return PromiseEventDispatcher_1.PromiseEventDispatcher; } });

Object.defineProperty(exports, "PromiseEventHandlingBase", { enumerable: true, get: function () { return PromiseEventHandlingBase_1.PromiseEventHandlingBase; } });

Object.defineProperty(exports, "PromiseEventList", { enumerable: true, get: function () { return PromiseEventList_1.PromiseEventList; } });

Object.defineProperty(exports, "NonUniformPromiseEventList", { enumerable: true, get: function () { return NonUniformPromiseEventList_1.NonUniformPromiseEventList; } });
});

var PromiseSignalDispatcher_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseSignalDispatcher = void 0;

/**
 * The dispatcher handles the storage of subsciptions and facilitates
 * subscription, unsubscription and dispatching of a signal event.
 */
class PromiseSignalDispatcher extends dist$7.PromiseDispatcherBase {
    /**
     * Creates a new SignalDispatcher instance.
     */
    constructor() {
        super();
    }
    /**
     * Dispatches the signal.
     *
     * @returns {IPropagationStatus} The status of the dispatch.
     *
     * @memberOf SignalDispatcher
     */
    async dispatch() {
        const result = await this._dispatchAsPromise(false, this, arguments);
        if (result == null) {
            throw new dist$7.DispatchError("Got `null` back from dispatch.");
        }
        return result;
    }
    /**
     * Dispatches the signal threaded.
     */
    dispatchAsync() {
        this._dispatchAsPromise(true, this, arguments);
    }
    /**
     * Creates an event from the dispatcher. Will return the dispatcher
     * in a wrapper. This will prevent exposure of any dispatcher methods.
     */
    asEvent() {
        return super.asEvent();
    }
}
exports.PromiseSignalDispatcher = PromiseSignalDispatcher;
});

var PromiseSignalList_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseSignalList = void 0;


/**
 * Storage class for multiple signal events that are accessible by name.
 * Events dispatchers are automatically created.
 */
class PromiseSignalList extends dist$7.EventListBase {
    /**
     * Creates a new SignalList instance.
     */
    constructor() {
        super();
    }
    /**
     * Creates a new dispatcher instance.
     */
    createDispatcher() {
        return new PromiseSignalDispatcher_1.PromiseSignalDispatcher();
    }
}
exports.PromiseSignalList = PromiseSignalList;
});

var PromiseSignalHandlingBase_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseSignalHandlingBase = void 0;


/**
 * Extends objects with signal event handling capabilities.
 */
class PromiseSignalHandlingBase extends dist$7.HandlingBase {
    constructor() {
        super(new PromiseSignalList_1.PromiseSignalList());
    }
}
exports.PromiseSignalHandlingBase = PromiseSignalHandlingBase;
});

var dist$2 = createCommonjsModule(function (module, exports) {
/*!
 * Strongly Typed Events for TypeScript - Promise Signals
 * https://github.com/KeesCBakker/StronlyTypedEvents/
 * http://keestalkstech.com
 *
 * Copyright Kees C. Bakker / KeesTalksTech
 * Released under the MIT license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseSignalList = exports.PromiseSignalHandlingBase = exports.PromiseSignalDispatcher = void 0;

Object.defineProperty(exports, "PromiseSignalDispatcher", { enumerable: true, get: function () { return PromiseSignalDispatcher_1.PromiseSignalDispatcher; } });

Object.defineProperty(exports, "PromiseSignalHandlingBase", { enumerable: true, get: function () { return PromiseSignalHandlingBase_1.PromiseSignalHandlingBase; } });

Object.defineProperty(exports, "PromiseSignalList", { enumerable: true, get: function () { return PromiseSignalList_1.PromiseSignalList; } });
});

var PromiseSimpleEventDispatcher_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseSimpleEventDispatcher = void 0;

/**
 * The dispatcher handles the storage of subsciptions and facilitates
 * subscription, unsubscription and dispatching of a simple event
 *
 * @export
 * @class PromiseSimpleEventDispatcher
 * @extends {PromiseDispatcherBase<IPromiseSimpleEventHandler<TArgs>>}
 * @implements {IPromiseSimpleEvent<TArgs>}
 * @template TArgs
 */
class PromiseSimpleEventDispatcher extends dist$7.PromiseDispatcherBase {
    /**
     * Creates a new SimpleEventDispatcher instance.
     */
    constructor() {
        super();
    }
    /**
     * Dispatches the event.
     * @param args The arguments object.
     * @returns {IPropagationStatus} The status of the dispatch.
     * @memberOf PromiseSimpleEventDispatcher
     */
    async dispatch(args) {
        const result = await this._dispatchAsPromise(false, this, arguments);
        if (result == null) {
            throw new dist$7.DispatchError("Got `null` back from dispatch.");
        }
        return result;
    }
    /**
     * Dispatches the event without waiting for it to complete.
     * @param args The argument object.
     * @memberOf PromiseSimpleEventDispatcher
     */
    dispatchAsync(args) {
        this._dispatchAsPromise(true, this, arguments);
    }
    /**
     * Creates an event from the dispatcher. Will return the dispatcher
     * in a wrapper. This will prevent exposure of any dispatcher methods.
     */
    asEvent() {
        return super.asEvent();
    }
}
exports.PromiseSimpleEventDispatcher = PromiseSimpleEventDispatcher;
});

var NonUniformPromiseSimpleEventList_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonUniformPromiseSimpleEventList = void 0;

/**
 * Similar to EventList, but instead of TArgs, a map of event names ang argument types is provided with TArgsMap.
 */
class NonUniformPromiseSimpleEventList {
    constructor() {
        this._events = {};
    }
    /**
     * Gets the dispatcher associated with the name.
     * @param name The name of the event.
     */
    get(name) {
        if (this._events[name]) {
            // @TODO avoid typecasting. Not sure why TS thinks this._events[name] could still be undefined.
            return this._events[name];
        }
        const event = this.createDispatcher();
        this._events[name] = event;
        return event;
    }
    /**
     * Removes the dispatcher associated with the name.
     * @param name The name of the event.
     */
    remove(name) {
        delete this._events[name];
    }
    /**
     * Creates a new dispatcher instance.
     */
    createDispatcher() {
        return new PromiseSimpleEventDispatcher_1.PromiseSimpleEventDispatcher();
    }
}
exports.NonUniformPromiseSimpleEventList = NonUniformPromiseSimpleEventList;
});

var PromiseSimpleEventList_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseSimpleEventList = void 0;


/**
 * Storage class for multiple simple events that are accessible by name.
 * Events dispatchers are automatically created.
 */
class PromiseSimpleEventList extends dist$7.EventListBase {
    /**
     * Creates a new SimpleEventList instance.
     */
    constructor() {
        super();
    }
    /**
     * Creates a new dispatcher instance.
     */
    createDispatcher() {
        return new PromiseSimpleEventDispatcher_1.PromiseSimpleEventDispatcher();
    }
}
exports.PromiseSimpleEventList = PromiseSimpleEventList;
});

var PromiseSimpleEventHandlingBase_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseSimpleEventHandlingBase = void 0;


/**
 * Extends objects with signal event handling capabilities.
 */
class PromiseSimpleEventHandlingBase extends dist$7.HandlingBase {
    constructor() {
        super(new PromiseSimpleEventList_1.PromiseSimpleEventList());
    }
}
exports.PromiseSimpleEventHandlingBase = PromiseSimpleEventHandlingBase;
});

var dist$1 = createCommonjsModule(function (module, exports) {
/*!
 * Strongly Typed Events for TypeScript - Core
 * https://github.com/KeesCBakker/StronlyTypedEvents/
 * http://keestalkstech.com
 *
 * Copyright Kees C. Bakker / KeesTalksTech
 * Released under the MIT license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonUniformPromiseSimpleEventList = exports.PromiseSimpleEventList = exports.PromiseSimpleEventHandlingBase = exports.PromiseSimpleEventDispatcher = void 0;

Object.defineProperty(exports, "NonUniformPromiseSimpleEventList", { enumerable: true, get: function () { return NonUniformPromiseSimpleEventList_1.NonUniformPromiseSimpleEventList; } });

Object.defineProperty(exports, "PromiseSimpleEventDispatcher", { enumerable: true, get: function () { return PromiseSimpleEventDispatcher_1.PromiseSimpleEventDispatcher; } });

Object.defineProperty(exports, "PromiseSimpleEventHandlingBase", { enumerable: true, get: function () { return PromiseSimpleEventHandlingBase_1.PromiseSimpleEventHandlingBase; } });

Object.defineProperty(exports, "PromiseSimpleEventList", { enumerable: true, get: function () { return PromiseSimpleEventList_1.PromiseSimpleEventList; } });
});

var dist = createCommonjsModule(function (module, exports) {
/*!
 * Strongly Typed Events for TypeScript
 * https://github.com/KeesCBakker/StronlyTypedEvents/
 * http://keestalkstech.com
 *
 * Copyright Kees C. Bakker / KeesTalksTech
 * Released under the MIT license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonUniformPromiseSimpleEventList = exports.PromiseSimpleEventList = exports.PromiseSimpleEventHandlingBase = exports.PromiseSimpleEventDispatcher = exports.PromiseSignalList = exports.PromiseSignalHandlingBase = exports.PromiseSignalDispatcher = exports.NonUniformPromiseEventList = exports.PromiseEventList = exports.PromiseEventHandlingBase = exports.PromiseEventDispatcher = exports.SignalList = exports.SignalHandlingBase = exports.SignalDispatcher = exports.NonUniformSimpleEventList = exports.SimpleEventList = exports.SimpleEventHandlingBase = exports.SimpleEventDispatcher = exports.NonUniformEventList = exports.EventList = exports.EventHandlingBase = exports.EventDispatcher = exports.HandlingBase = exports.PromiseDispatcherBase = exports.PromiseSubscription = exports.DispatchError = exports.EventManagement = exports.EventListBase = exports.DispatcherWrapper = exports.DispatcherBase = exports.Subscription = void 0;

Object.defineProperty(exports, "Subscription", { enumerable: true, get: function () { return dist$7.Subscription; } });
Object.defineProperty(exports, "DispatcherBase", { enumerable: true, get: function () { return dist$7.DispatcherBase; } });
Object.defineProperty(exports, "DispatcherWrapper", { enumerable: true, get: function () { return dist$7.DispatcherWrapper; } });
Object.defineProperty(exports, "EventListBase", { enumerable: true, get: function () { return dist$7.EventListBase; } });
Object.defineProperty(exports, "EventManagement", { enumerable: true, get: function () { return dist$7.EventManagement; } });
Object.defineProperty(exports, "DispatchError", { enumerable: true, get: function () { return dist$7.DispatchError; } });
Object.defineProperty(exports, "PromiseSubscription", { enumerable: true, get: function () { return dist$7.PromiseSubscription; } });
Object.defineProperty(exports, "PromiseDispatcherBase", { enumerable: true, get: function () { return dist$7.PromiseDispatcherBase; } });
Object.defineProperty(exports, "HandlingBase", { enumerable: true, get: function () { return dist$7.HandlingBase; } });

Object.defineProperty(exports, "EventDispatcher", { enumerable: true, get: function () { return dist$6.EventDispatcher; } });
Object.defineProperty(exports, "EventHandlingBase", { enumerable: true, get: function () { return dist$6.EventHandlingBase; } });
Object.defineProperty(exports, "EventList", { enumerable: true, get: function () { return dist$6.EventList; } });
Object.defineProperty(exports, "NonUniformEventList", { enumerable: true, get: function () { return dist$6.NonUniformEventList; } });

Object.defineProperty(exports, "SimpleEventDispatcher", { enumerable: true, get: function () { return dist$5.SimpleEventDispatcher; } });
Object.defineProperty(exports, "SimpleEventHandlingBase", { enumerable: true, get: function () { return dist$5.SimpleEventHandlingBase; } });
Object.defineProperty(exports, "SimpleEventList", { enumerable: true, get: function () { return dist$5.SimpleEventList; } });
Object.defineProperty(exports, "NonUniformSimpleEventList", { enumerable: true, get: function () { return dist$5.NonUniformSimpleEventList; } });

Object.defineProperty(exports, "SignalDispatcher", { enumerable: true, get: function () { return dist$4.SignalDispatcher; } });
Object.defineProperty(exports, "SignalHandlingBase", { enumerable: true, get: function () { return dist$4.SignalHandlingBase; } });
Object.defineProperty(exports, "SignalList", { enumerable: true, get: function () { return dist$4.SignalList; } });

Object.defineProperty(exports, "PromiseEventDispatcher", { enumerable: true, get: function () { return dist$3.PromiseEventDispatcher; } });
Object.defineProperty(exports, "PromiseEventHandlingBase", { enumerable: true, get: function () { return dist$3.PromiseEventHandlingBase; } });
Object.defineProperty(exports, "PromiseEventList", { enumerable: true, get: function () { return dist$3.PromiseEventList; } });
Object.defineProperty(exports, "NonUniformPromiseEventList", { enumerable: true, get: function () { return dist$3.NonUniformPromiseEventList; } });

Object.defineProperty(exports, "PromiseSignalDispatcher", { enumerable: true, get: function () { return dist$2.PromiseSignalDispatcher; } });
Object.defineProperty(exports, "PromiseSignalHandlingBase", { enumerable: true, get: function () { return dist$2.PromiseSignalHandlingBase; } });
Object.defineProperty(exports, "PromiseSignalList", { enumerable: true, get: function () { return dist$2.PromiseSignalList; } });

Object.defineProperty(exports, "PromiseSimpleEventDispatcher", { enumerable: true, get: function () { return dist$1.PromiseSimpleEventDispatcher; } });
Object.defineProperty(exports, "PromiseSimpleEventHandlingBase", { enumerable: true, get: function () { return dist$1.PromiseSimpleEventHandlingBase; } });
Object.defineProperty(exports, "PromiseSimpleEventList", { enumerable: true, get: function () { return dist$1.PromiseSimpleEventList; } });
Object.defineProperty(exports, "NonUniformPromiseSimpleEventList", { enumerable: true, get: function () { return dist$1.NonUniformPromiseSimpleEventList; } });
});

var createUUID$1 = function () {
  var lut = [];
  for (var i = 0; i < 256; i++) {
    lut[i] = (i < 16 ? '0' : '') + i.toString(16);
  }
  return function () {
    var d0 = Math.random() * 0xffffffff | 0;
    var d1 = Math.random() * 0xffffffff | 0;
    var d2 = Math.random() * 0xffffffff | 0;
    var d3 = Math.random() * 0xffffffff | 0;
    return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + "-" + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + "-" + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + "-" + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + "-" + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
  };
}();
/**
 * Common base class for xeokit SDK components.
 *
 * ## Summary
 *
 * * Unique ID
 * * Logging methods
 * * Manages lifecycle of child Components
 */
var _owner = /*#__PURE__*/_classPrivateFieldLooseKey("owner");
var _ownedComponents = /*#__PURE__*/_classPrivateFieldLooseKey("ownedComponents");
var _prefixMessageWithID$1 = /*#__PURE__*/_classPrivateFieldLooseKey("prefixMessageWithID");
var _own = /*#__PURE__*/_classPrivateFieldLooseKey("own");
var Component = /*#__PURE__*/function () {
  /**
   * Creates a new component.
   */
  function Component(owner, cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    Object.defineProperty(this, _own, {
      value: _own2
    });
    Object.defineProperty(this, _prefixMessageWithID$1, {
      value: _prefixMessageWithID2$1
    });
    /**
     * Unique ID of this Component.
     */
    this.id = void 0;
    /**
     * True once this Component has been destroyed.
     *
     * Don't use this Component if this is ````true````.
     */
    this.destroyed = void 0;
    this.dirty = void 0;
    Object.defineProperty(this, _owner, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _ownedComponents, {
      writable: true,
      value: void 0
    });
    /**
     * Emits an event when the {@link @xeokit/core!Component} has been destroyed.
     *
     * @event
     */
    this.onDestroyed = void 0;
    _classPrivateFieldLooseBase(this, _owner)[_owner] = owner;
    this.id = cfg.id || createUUID$1();
    this.destroyed = false;
    _classPrivateFieldLooseBase(this, _ownedComponents)[_ownedComponents] = null;
    this.dirty = false;
    this.onDestroyed = new EventEmitter(new dist.EventDispatcher());
    if (owner) {
      _classPrivateFieldLooseBase(owner, _own)[_own](this);
    }
  }
  /**
   * Logs a message for this component.
   *
   * The message will have this format: *````[LOG] [<component type> <component id>: <message>````*
   *
   * @param message - The message to log
   * @protected
   */
  var _proto = Component.prototype;
  _proto.log = function log(message) {
    message = "[LOG] " + _classPrivateFieldLooseBase(this, _prefixMessageWithID$1)[_prefixMessageWithID$1](message);
    console.log(message);
  }
  /**
   * Logs a warning for this component to the JavaScript console.
   *
   * The console message will have this format: *````[WARN] [<component type> =<component id>: <message>````*
   *
   * @param message - The warning message to log
   * @protected
   */;
  _proto.warn = function warn(message) {
    message = "[WARN] " + _classPrivateFieldLooseBase(this, _prefixMessageWithID$1)[_prefixMessageWithID$1](message);
    console.warn(message);
  }
  /**
   * Logs an error for this component to the JavaScript console.
   *
   * The console message will have this format: *````[ERROR] [<component type> =<component id>: <message>````*
    @param message The error message to log
   @protected
   */;
  _proto.error = function error(message) {
    message = "[ERROR] " + _classPrivateFieldLooseBase(this, _prefixMessageWithID$1)[_prefixMessageWithID$1](message);
    console.error(message);
  }
  /**
   * Flags this component as having a defered state updates it needs to perform.
   */;
  _proto.setDirty = function setDirty() {
    if (this.dirty) {
      return;
    }
    this.dirty = true;
  }
  /**
   * Gives this component an opportunity to action any defered state updates.
   */;
  _proto.cleanIfDirty = function cleanIfDirty() {
    if (this.dirty) {
      this.dirty = false;
      this.clean();
    }
  }
  /**
   * Forces this component to action any deferred state updates.
   */;
  _proto.clean = function clean() {}
  /**
   * Destroys this component.
   *
   * Also destroys any components owned by this one.
   *
   * Sets {@link Component.destroyed} ````true````.
   *
   * Cancels any deferred state updates.
   */;
  _proto.destroy = function destroy() {
    if (this.destroyed) {
      return;
    }
    this.destroyed = true;
    if (_classPrivateFieldLooseBase(this, _ownedComponents)[_ownedComponents]) {
      for (var id in _classPrivateFieldLooseBase(this, _ownedComponents)[_ownedComponents]) {
        if (_classPrivateFieldLooseBase(this, _ownedComponents)[_ownedComponents].hasOwnProperty(id)) {
          var component = _classPrivateFieldLooseBase(this, _ownedComponents)[_ownedComponents][id];
          component.destroy();
          delete _classPrivateFieldLooseBase(this, _ownedComponents)[_ownedComponents][id];
        }
      }
    }
    _classPrivateFieldLooseBase(this, _ownedComponents)[_ownedComponents] = null;
    this.dirty = false;
    this.onDestroyed.dispatch(this, null);
    this.onDestroyed.clear();
  };
  return Component;
}();
function _prefixMessageWithID2$1(message) {
  return " [" + this.constructor.name + " \"" + this.id + "\"]: " + message;
}
function _own2(component) {
  var _this = this;
  if (!_classPrivateFieldLooseBase(this, _ownedComponents)[_ownedComponents]) {
    _classPrivateFieldLooseBase(this, _ownedComponents)[_ownedComponents] = {};
  }
  if (!_classPrivateFieldLooseBase(this, _ownedComponents)[_ownedComponents][component.id]) {
    _classPrivateFieldLooseBase(this, _ownedComponents)[_ownedComponents][component.id] = component;
  }
  component.onDestroyed.one(function () {
    // @ts-ignore
    delete _classPrivateFieldLooseBase(_this, _ownedComponents)[_ownedComponents][component.id];
  });
}

/**
 * Basic xeokit SDK error type.
 */
var SDKError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(SDKError, _Error);
  function SDKError() {
    return _Error.apply(this, arguments) || this;
  }
  return SDKError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2Fcore.svg)](https://badge.fury.io/js/%40xeokit%2Fcore)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/core/badge)](https://www.jsdelivr.com/package/npm/@xeokit/core)
 *
 * <img style="padding:10px" src="media://images/xeokit_components_icon.png"/>
 *
 * ## xeokit SDK Core Components
 *
 * * {@link @xeokit/core!Component} base class
 * * Various interfaces that are implemented throughout the SDK.
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/core
 * ````
 *
 * @module @xeokit/core
 */

var index$m = {
  __proto__: null,
  Component: Component,
  SDKError: SDKError,
  EventEmitter: EventEmitter
};

/**
 * ## xeokit SDK Constant Definitions
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/constants
 * ````
 *
 * @module @xeokit/constants
 */
/**
 * Texture wrapping mode in which the texture repeats to infinity.
 */
var RepeatWrapping = 1000;
/**
 * Texture wrapping mode in which the last pixel of the texture stretches to the edge of the mesh.
 */
var ClampToEdgeWrapping = 1001;
/**
 * Texture wrapping mode in which the texture repeats to infinity, mirroring on each repeat.
 */
var MirroredRepeatWrapping = 1002;
/**
 * Texture magnification and minification filter that returns the nearest texel to the given sample coordinates.
 */
var NearestFilter = 1003;
/**
 * Texture minification filter that chooses the mipmap that most closely matches the size of the pixel being textured and returns the nearest texel to the given sample coordinates.
 */
var NearestMipMapNearestFilter = 1004;
/**
 * Texture minification filter that chooses the mipmap that most closely matches the size of the pixel being textured
 * and returns the nearest texel to the given sample coordinates.
 */
var NearestMipmapNearestFilter = 1004;
/**
 * Texture minification filter that chooses two mipmaps that most closely match the size of the pixel being textured
 * and returns the nearest texel to the center of the pixel at the given sample coordinates.
 */
var NearestMipmapLinearFilter = 1005;
/**
 * Texture minification filter that chooses two mipmaps that most closely match the size of the pixel being textured
 * and returns the nearest texel to the center of the pixel at the given sample coordinates.
 */
var NearestMipMapLinearFilter = 1005;
/**
 * Texture magnification and minification filter that returns the weighted average of the four nearest texels to the given sample coordinates.
 */
var LinearFilter = 1006;
/**
 * Texture minification filter that chooses the mipmap that most closely matches the size of the pixel being textured and
 * returns the weighted average of the four nearest texels to the given sample coordinates.
 */
var LinearMipmapNearestFilter = 1007;
/**
 * Texture minification filter that chooses the mipmap that most closely matches the size of the pixel being textured and
 * returns the weighted average of the four nearest texels to the given sample coordinates.
 */
var LinearMipMapNearestFilter = 1007;
/**
 * Texture minification filter that chooses two mipmaps that most closely match the size of the pixel being textured,
 * finds within each mipmap the weighted average of the nearest texel to the center of the pixel, then returns the
 * weighted average of those two values.
 */
var LinearMipmapLinearFilter = 1008;
/**
 * Texture minification filter that chooses two mipmaps that most closely match the size of the pixel being textured,
 * finds within each mipmap the weighted average of the nearest texel to the center of the pixel, then returns the
 * weighted average of those two values.
 */
var LinearMipMapLinearFilter = 1008;
/**
 * Unsigned 8-bit integer type.
 */
var UnsignedByteType = 1009;
/**
 * Signed 8-bit integer type.
 */
var ByteType = 1010;
/**
 * Signed 16-bit integer type.
 */
var ShortType = 1011;
/**
 * Unsigned 16-bit integer type.
 */
var UnsignedShortType = 1012;
/**
 * Signed 32-bit integer type.
 */
var IntType = 1013;
/**
 * Unsigned 32-bit integer type.
 */
var UnsignedIntType = 1014;
/**
 * Signed 32-bit floating-point type.
 */
var FloatType = 1015;
/**
 * Signed 16-bit half-precision floating-point type.
 */
var HalfFloatType = 1016;
/**
 * Texture packing mode in which each ````RGBA```` channel is packed into 4 bits, for a combined total of 16 bits.
 */
var UnsignedShort4444Type = 1017;
/**
 * Texture packing mode in which the ````RGB```` channels are each packed into 5 bits, and the ````A```` channel is packed into 1 bit, for a combined total of 16 bits.
 */
var UnsignedShort5551Type = 1018;
/**
 * Unsigned integer type for 24-bit depth texture data.
 */
var UnsignedInt248Type = 1020;
/**
 * Texture sampling mode that discards the ````RGBA```` components and just reads the ````A```` component.
 */
var AlphaFormat = 1021;
/**
 * Texture sampling mode that discards the ````A```` component and reads the ````RGB```` components.
 */
var RGBFormat = 1022;
/**
 * Texture sampling mode that reads the ````RGBA```` components.
 */
var RGBAFormat = 1023;
/**
 * Texture sampling mode that reads each ````RGB```` texture component as a luminance value, converted to a float and clamped
 * to ````[0,1]````, while always reading the ````A```` channel as ````1.0````.
 */
var LuminanceFormat = 1024;
/**
 * Texture sampling mode that reads each of the ````RGBA```` texture components as a luminance/alpha value, converted to a float and clamped to ````[0,1]````.
 */
var LuminanceAlphaFormat = 1025;
/**
 * Texture sampling mode that reads each element as a single depth value, converts it to a float and clamps to ````[0,1]````.
 */
var DepthFormat = 1026;
/**
 * Texture sampling mode that
 */
var DepthStencilFormat = 1027;
/**
 * Texture sampling mode that discards the ````GBA```` components and just reads the ````R```` component.
 */
var RedFormat = 1028;
/**
 * Texture sampling mode that discards the ````GBA```` components and just reads the ````R```` component, as an integer instead of as a float.
 */
var RedIntegerFormat = 1029;
/**
 * Texture sampling mode that discards the ````A```` and ````B```` components and just reads the ````R```` and ````G```` components.
 */
var RGFormat = 1030;
/**
 * Texture sampling mode that discards the ````A```` and ````B```` components and just reads the ````R```` and ````G```` components, as integers instead of floats.
 */
var RGIntegerFormat = 1031;
/**
 * Texture sampling mode that reads the ````RGBA```` components as integers instead of floats.
 */
var RGBAIntegerFormat = 1033;
/**
 * Texture format mode in which the texture is formatted as a <a href="https://en.wikipedia.org/wiki/S3_Texture_Compression">DXT1 compressed</a> ````RGB```` image.
 */
var RGB_S3TC_DXT1_Format = 33776;
/**
 * Texture format mode in which the texture is formatted as a <a href="https://en.wikipedia.org/wiki/S3_Texture_Compression">DXT1 compressed</a> ````RGBA```` image.
 */
var RGBA_S3TC_DXT1_Format = 33777;
/**
 * Texture format mode in which the texture is formatted as a <a href="https://en.wikipedia.org/wiki/S3_Texture_Compression">DXT3 compressed</a> ````RGBA```` image.
 */
var RGBA_S3TC_DXT3_Format = 33778;
/**
 * Texture format mode in which the texture is formatted as a <a href="https://en.wikipedia.org/wiki/S3_Texture_Compression">DXT5 compressed</a> ````RGBA```` image.
 */
var RGBA_S3TC_DXT5_Format = 33779;
/**
 * Texture format mode in which the texture is formatted as a <a href="https://en.wikipedia.org/wiki/PVRTC">PVRTC compressed</a>
 * image, with ````RGB```` compression in 4-bit mode and one block for each 4×4 pixels.
 */
var RGB_PVRTC_4BPPV1_Format = 35840;
/**
 * Texture format mode in which the texture is formatted as a <a href="https://en.wikipedia.org/wiki/PVRTC">PVRTC compressed</a>
 * image, with ````RGB```` compression in 2-bit mode and one block for each 8×4 pixels.
 */
var RGB_PVRTC_2BPPV1_Format = 35841;
/**
 * Texture format mode in which the texture is formatted as a <a href="https://en.wikipedia.org/wiki/PVRTC">PVRTC compressed</a>
 * image, with ````RGBA```` compression in 4-bit mode and one block for each 4×4 pixels.
 */
var RGBA_PVRTC_4BPPV1_Format = 35842;
/**
 * Texture format mode in which the texture is formatted as a <a href="https://en.wikipedia.org/wiki/PVRTC">PVRTC compressed</a>
 * image, with ````RGBA```` compression in 2-bit mode and one block for each 8×4 pixels.
 */
var RGBA_PVRTC_2BPPV1_Format = 35843;
/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc1/">ETC1 compressed</a>
 * ````RGB```` image.
 */
var RGB_ETC1_Format = 36196;
/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc2/">ETC2 compressed</a>
 * ````RGB```` image.
 */
var RGB_ETC2_Format = 37492;
/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc2/">ETC2 compressed</a>
 * ````RGBA```` image.
 */
var RGBA_ETC2_EAC_Format = 37496;
/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */
var RGBA_ASTC_4x4_Format = 37808;
/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */
var RGBA_ASTC_5x4_Format = 37809;
/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */
var RGBA_ASTC_5x5_Format = 37810;
/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */
var RGBA_ASTC_6x5_Format = 37811;
/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */
var RGBA_ASTC_6x6_Format = 37812;
/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */
var RGBA_ASTC_8x5_Format = 37813;
/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */
var RGBA_ASTC_8x6_Format = 37814;
/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */
var RGBA_ASTC_8x8_Format = 37815;
/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */
var RGBA_ASTC_10x5_Format = 37816;
/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */
var RGBA_ASTC_10x6_Format = 37817;
/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */
var RGBA_ASTC_10x8_Format = 37818;
/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */
var RGBA_ASTC_10x10_Format = 37819;
/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */
var RGBA_ASTC_12x10_Format = 37820;
/**
 * Texture format mode in which the texture is formatted as an <a href="https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/">ATSC compressed</a>
 * ````RGBA```` image.
 */
var RGBA_ASTC_12x12_Format = 37821;
/**
 * Texture format mode in which the texture is formatted as an <a href="https://www.khronos.org/opengl/wiki/BPTC_Texture_Compression">BPTC compressed</a>
 * ````RGBA```` image.
 */
var RGBA_BPTC_Format = 36492;
/**
 * Texture encoding mode in which the texture image is in linear color space.
 */
var LinearEncoding = 3000;
/**
 * Texture encoding mode in which the texture image is in sRGB color space.
 */
var sRGBEncoding = 3001;
/**
 * Media type for GIF images.
 */
var GIFMediaType = 10000;
/**
 * Media type for JPEG images.
 */
var JPEGMediaType = 10001;
/**
 * Media type for PNG images.
 */
var PNGMediaType = 10002;
/**
 * Points primitive type.
 */
var PointsPrimitive = 20000;
/**
 * Line segments primitive type.
 */
var LinesPrimitive = 20001;
/**
 * Non-closed triangle mesh primitive type.
 *
 * > Since we are able to look inside non-closed surfaces and see their backfaces, these primitive types are always
 * rendered with backfaces enabled.
 */
var TrianglesPrimitive = 20002;
/**
 * Closed triangle mesh primitive type.
 *
 * Since we normally can't see the backfaces inside closed surfaces, these primitive types are normally rendered
 * with backfaces disabled, for extra performance.
 */
var SolidPrimitive = 20003;
/**
 * Non-closed triangle mesh primitive type.
 *
 * Since we are able to look inside non-closed surfaces and see their backfaces, these primitive types are always
 * rendered with backfaces enabled.
 */
var SurfacePrimitive = 20004;
/**
 * Fast rendering mode.
 */
var FastRender = 300001;
/**
 * Quality rendering mode.
 */
var QualityRender = 30000;
/**
 * Meters unit of measurement.
 */
var MetersUnit = 400000;
/**
 * Centimeters unit of measurement.
 */
var CentimetersUnit = 400001;
/**
 * Millimeters unit of measurement.
 */
var MillimetersUnit = 400002;
/**
 * Yards unit of measurement.
 */
var YardsUnit = 400003;
/**
 * Feet unit of measurement.
 */
var FeetUnit = 400004;
/**
 * Inches unit of measurement.
 */
var InchesUnit = 400005;
/**
 * Perspective projection type.
 */
var PerspectiveProjectionType = 500000;
/**
 * Orthographic projection type.
 */
var OrthoProjectionType = 500001;
/**
 * Frustum3 projection type.
 */
var FrustumProjectionType = 500002;
/**
 * Custom projection type.
 */
var CustomProjectionType = 500003;
/**
 * Orbit navigation mode.
 */
var OrbitNavigationMode = 600001;
/**
 * First-person navigation mode.
 */
var FirstPersonNavigationMode = 600002;
/**
 * Plan view navigation mode.
 */
var PlanViewNavigationMode = 600003;

var index$l = {
  __proto__: null,
  RepeatWrapping: RepeatWrapping,
  ClampToEdgeWrapping: ClampToEdgeWrapping,
  MirroredRepeatWrapping: MirroredRepeatWrapping,
  NearestFilter: NearestFilter,
  NearestMipMapNearestFilter: NearestMipMapNearestFilter,
  NearestMipmapNearestFilter: NearestMipmapNearestFilter,
  NearestMipmapLinearFilter: NearestMipmapLinearFilter,
  NearestMipMapLinearFilter: NearestMipMapLinearFilter,
  LinearFilter: LinearFilter,
  LinearMipmapNearestFilter: LinearMipmapNearestFilter,
  LinearMipMapNearestFilter: LinearMipMapNearestFilter,
  LinearMipmapLinearFilter: LinearMipmapLinearFilter,
  LinearMipMapLinearFilter: LinearMipMapLinearFilter,
  UnsignedByteType: UnsignedByteType,
  ByteType: ByteType,
  ShortType: ShortType,
  UnsignedShortType: UnsignedShortType,
  IntType: IntType,
  UnsignedIntType: UnsignedIntType,
  FloatType: FloatType,
  HalfFloatType: HalfFloatType,
  UnsignedShort4444Type: UnsignedShort4444Type,
  UnsignedShort5551Type: UnsignedShort5551Type,
  UnsignedInt248Type: UnsignedInt248Type,
  AlphaFormat: AlphaFormat,
  RGBFormat: RGBFormat,
  RGBAFormat: RGBAFormat,
  LuminanceFormat: LuminanceFormat,
  LuminanceAlphaFormat: LuminanceAlphaFormat,
  DepthFormat: DepthFormat,
  DepthStencilFormat: DepthStencilFormat,
  RedFormat: RedFormat,
  RedIntegerFormat: RedIntegerFormat,
  RGFormat: RGFormat,
  RGIntegerFormat: RGIntegerFormat,
  RGBAIntegerFormat: RGBAIntegerFormat,
  RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format,
  RGBA_S3TC_DXT1_Format: RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format: RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,
  RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,
  RGB_PVRTC_2BPPV1_Format: RGB_PVRTC_2BPPV1_Format,
  RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,
  RGBA_PVRTC_2BPPV1_Format: RGBA_PVRTC_2BPPV1_Format,
  RGB_ETC1_Format: RGB_ETC1_Format,
  RGB_ETC2_Format: RGB_ETC2_Format,
  RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,
  RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,
  RGBA_ASTC_5x4_Format: RGBA_ASTC_5x4_Format,
  RGBA_ASTC_5x5_Format: RGBA_ASTC_5x5_Format,
  RGBA_ASTC_6x5_Format: RGBA_ASTC_6x5_Format,
  RGBA_ASTC_6x6_Format: RGBA_ASTC_6x6_Format,
  RGBA_ASTC_8x5_Format: RGBA_ASTC_8x5_Format,
  RGBA_ASTC_8x6_Format: RGBA_ASTC_8x6_Format,
  RGBA_ASTC_8x8_Format: RGBA_ASTC_8x8_Format,
  RGBA_ASTC_10x5_Format: RGBA_ASTC_10x5_Format,
  RGBA_ASTC_10x6_Format: RGBA_ASTC_10x6_Format,
  RGBA_ASTC_10x8_Format: RGBA_ASTC_10x8_Format,
  RGBA_ASTC_10x10_Format: RGBA_ASTC_10x10_Format,
  RGBA_ASTC_12x10_Format: RGBA_ASTC_12x10_Format,
  RGBA_ASTC_12x12_Format: RGBA_ASTC_12x12_Format,
  RGBA_BPTC_Format: RGBA_BPTC_Format,
  LinearEncoding: LinearEncoding,
  sRGBEncoding: sRGBEncoding,
  GIFMediaType: GIFMediaType,
  JPEGMediaType: JPEGMediaType,
  PNGMediaType: PNGMediaType,
  PointsPrimitive: PointsPrimitive,
  LinesPrimitive: LinesPrimitive,
  TrianglesPrimitive: TrianglesPrimitive,
  SolidPrimitive: SolidPrimitive,
  SurfacePrimitive: SurfacePrimitive,
  FastRender: FastRender,
  QualityRender: QualityRender,
  MetersUnit: MetersUnit,
  CentimetersUnit: CentimetersUnit,
  MillimetersUnit: MillimetersUnit,
  YardsUnit: YardsUnit,
  FeetUnit: FeetUnit,
  InchesUnit: InchesUnit,
  PerspectiveProjectionType: PerspectiveProjectionType,
  OrthoProjectionType: OrthoProjectionType,
  FrustumProjectionType: FrustumProjectionType,
  CustomProjectionType: CustomProjectionType,
  OrbitNavigationMode: OrbitNavigationMode,
  FirstPersonNavigationMode: FirstPersonNavigationMode,
  PlanViewNavigationMode: PlanViewNavigationMode
};

/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2Fmath.svg)](https://badge.fury.io/js/%40xeokit%2Fmath)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/badge)](https://www.jsdelivr.com/package/npm/@xeokit/math)
 *
 * <img style="padding:0px; padding-top:20px; padding-bottom:30px; height:140px;" src="media://images/math_icon.png"/>
 *
 * # xeokit Core Math Utilities
 *
 * ---
 *
 * ### *Basic math types and constants*
 *
 * ---
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/math
 * ````
 *
 * ## Usage
 *
 * ````javascript
 * import * as math from "@xeokit/math";
 *
 * //..
 * ````
 *
 * @module @xeokit/math
 */
/**
 * Minimum safe double-precision value.
 */
var MIN_DOUBLE = -Number.MAX_SAFE_INTEGER;
/**
 * Maximum safe double-precision value.
 */
var MAX_DOUBLE = Number.MAX_SAFE_INTEGER;
/**
 * The number of radiians in a degree (0.0174532925).
 */
var DEGTORAD = 0.0174532925;
/**
 * The number of degrees in a radian.
 */
var RADTODEG = 57.295779513;
/**
 * Clamps a value to the given range.
 * @param value Value to clamp.
 * @param  min Lower bound.
 * @param max Upper bound.
 * @returns  Clamped result.
 */
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
/**
 * Creates a new {@link FloatArrayParam}.
 */
function newFloatArray(values) {
  // @ts-ignore
  return new Float64Array(values);
}

var index$k = {
  __proto__: null,
  MIN_DOUBLE: MIN_DOUBLE,
  MAX_DOUBLE: MAX_DOUBLE,
  DEGTORAD: DEGTORAD,
  RADTODEG: RADTODEG,
  clamp: clamp,
  newFloatArray: newFloatArray
};

/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2Fmath.svg)](https://badge.fury.io/js/%40xeokit%2Fmath)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/badge)](https://www.jsdelivr.com/package/npm/@xeokit/math)
 *
 * <img style="padding:0px; padding-top:20px; padding-bottom:30px; height:140px;" src="media://images/matrix_icon.png"/>
 *
 * # xeokit Matrix and Vector Math Library
 *
 * ---
 *
 * ### *Math functions for 3D/2D matrices, quaternions and vectors*
 *
 * ---
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/matrix
 * ````
 *
 * ## Usage
 *
 * ````javascript
 * import * as matrix from "@xeokit/matrix";
 *
 * //..
 * ````
 *
 * @module @xeokit/matrix
 */
var tempVec4a$2 = createVec4();
var tempVec3$3 = createVec3();
var tempVec3b$6 = createVec3();
var tempVec3c$5 = createVec3();
var tempVec3d$2 = createVec3();
var tempVec3e$1 = createVec3();
var tempVec4b$2 = createVec4();
/**
 * Returns the dot product of two three-element vectors.
 */
function dotVec3(u, v) {
  return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
}
/**
 * Returns a new, uninitialized two-element vector.
 */
function createVec2(values) {
  // @ts-ignore
  return new Float64Array(values || 2);
}
/**
 * Returns a new, uninitialized three-element vector.
 */
function createVec3(values) {
  // @ts-ignore
  return new Float64Array(values || 3);
}
/**
 * Returns a new, uninitialized four-element vector.
 */
function createVec4(values) {
  // @ts-ignore
  return new Float64Array(values || 4);
}
/**
 * Negates a three-element vector.
 */
function negateVec3(v, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = -v[0];
  dest[1] = -v[1];
  dest[2] = -v[2];
  return dest;
}
/**
 * Negates a four-element vector.
 */
function negateVec4(v, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = -v[0];
  dest[1] = -v[1];
  dest[2] = -v[2];
  dest[3] = -v[3];
  return dest;
}
/**
 * Adds one four-element vector to another.
 */
function addVec4(u, v, dest) {
  if (!dest) {
    dest = u;
  }
  dest[0] = u[0] + v[0];
  dest[1] = u[1] + v[1];
  dest[2] = u[2] + v[2];
  dest[3] = u[3] + v[3];
  return dest;
}
/**
 * Adds a scalar value to each element of a four-element vector.
 */
function addVec4Scalar(v, s, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = v[0] + s;
  dest[1] = v[1] + s;
  dest[2] = v[2] + s;
  dest[3] = v[3] + s;
  return dest;
}
/**
 * Multiplies each element of a four-element vector by a scalar.
 */
function mulVec4Scalar(v, s, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = v[0] * s;
  dest[1] = v[1] * s;
  dest[2] = v[2] * s;
  dest[3] = v[3] * s;
  return dest;
}
/**
 * Multiplies each element of a three-element vector by a scalar.
 */
function mulVec3Scalar(v, s, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = v[0] * s;
  dest[1] = v[1] * s;
  dest[2] = v[2] * s;
  return dest;
}
/**
 * Multiplies each element of a two-element vector by a scalar.
 */
function mulVec2Scalar(v, s, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = v[0] * s;
  dest[1] = v[1] * s;
  return dest;
}
/**
 * Adds one three-element vector to another.
 */
function addVec3(u, v, dest) {
  if (!dest) {
    dest = u;
  }
  dest[0] = u[0] + v[0];
  dest[1] = u[1] + v[1];
  dest[2] = u[2] + v[2];
  return dest;
}
/**
 */
function addVec3Scalar(v, s, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = v[0] + s;
  dest[1] = v[1] + s;
  dest[2] = v[2] + s;
  return dest;
}
/**
 * Subtracts one four-element vector from another.
 */
function subVec4(u, v, dest) {
  if (!dest) {
    dest = u;
  }
  dest[0] = u[0] - v[0];
  dest[1] = u[1] - v[1];
  dest[2] = u[2] - v[2];
  dest[3] = u[3] - v[3];
  return dest;
}
/**
 * Returns true if the two 3-element vectors are the same.
 */
function compareVec3(v1, v2) {
  return v1[0] === v2[0] && v1[1] === v2[1] && v1[2] === v2[2];
}
/**
 * Subtracts one three-element vector from another.
 */
function subVec3(u, v, dest) {
  if (!dest) {
    dest = u;
  }
  dest[0] = u[0] - v[0];
  dest[1] = u[1] - v[1];
  dest[2] = u[2] - v[2];
  return dest;
}
/**
 * Subtracts one two-element vector from another.
 */
function subVec2(u, v, dest) {
  if (!dest) {
    dest = u;
  }
  dest[0] = u[0] - v[0];
  dest[1] = u[1] - v[1];
  return dest;
}
/**
 * Get the geometric mean of the vectors.
 */
function geometricMeanVec2() {
  var vectors = [].slice.call(arguments);
  var geometricMean = new Float32Array(vectors[0]);
  for (var i = 1; i < vectors.length; i++) {
    geometricMean[0] += vectors[i][0];
    geometricMean[1] += vectors[i][1];
  }
  geometricMean[0] /= vectors.length;
  geometricMean[1] /= vectors.length;
  return geometricMean;
}
/**
 * Subtracts a scalar value from each element of a four-element vector.
 */
function subVec4Scalar(v, s, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = v[0] - s;
  dest[1] = v[1] - s;
  dest[2] = v[2] - s;
  dest[3] = v[3] - s;
  return dest;
}
/**
 * Sets each element of a 4-element vector to a scalar value minus the value of that element.
 * @method subScalarVec4
 * @static
 * @param {Array(Number)} v The vector
 * @param s The scalar
 * @param  {Array(Number)} [dest] Destination vector
 * @return {Array(Number)} dest if specified, v otherwise
 */
function subScalarVec4(v, s, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = s - v[0];
  dest[1] = s - v[1];
  dest[2] = s - v[2];
  dest[3] = s - v[3];
  return dest;
}
/**
 * Multiplies one three-element vector by another.
 */
function mulVec4(u, v, dest) {
  if (!dest) {
    dest = u;
  }
  dest[0] = u[0] * v[0];
  dest[1] = u[1] * v[1];
  dest[2] = u[2] * v[2];
  dest[3] = u[3] * v[3];
  return dest;
}
/**
 * Divides one three-element vector by another.
 */
function divVec3(u, v, dest) {
  if (!dest) {
    dest = u;
  }
  dest[0] = u[0] / v[0];
  dest[1] = u[1] / v[1];
  dest[2] = u[2] / v[2];
  return dest;
}
/**
 * Divides one four-element vector by another.
 */
function divVec4(u, v, dest) {
  if (!dest) {
    dest = u;
  }
  dest[0] = u[0] / v[0];
  dest[1] = u[1] / v[1];
  dest[2] = u[2] / v[2];
  dest[3] = u[3] / v[3];
  return dest;
}
/**
 * Divides a scalar by a three-element vector, returning a new vector.
 */
function divScalarVec3(s, v, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = s / v[0];
  dest[1] = s / v[1];
  dest[2] = s / v[2];
  return dest;
}
/**
 * Divides a three-element vector by a scalar.
 */
function divVec3Scalar(v, s, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = v[0] / s;
  dest[1] = v[1] / s;
  dest[2] = v[2] / s;
  return dest;
}
/**
 * Divides a four-element vector by a scalar.
 */
function divVec4Scalar(v, s, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = v[0] / s;
  dest[1] = v[1] / s;
  dest[2] = v[2] / s;
  dest[3] = v[3] / s;
  return dest;
}
/**
 * Divides a scalar by a four-element vector, returning a new vector.
 */
function divScalarVec4(s, v, dest) {
  if (!dest) {
    dest = v;
  }
  dest[0] = s / v[0];
  dest[1] = s / v[1];
  dest[2] = s / v[2];
  dest[3] = s / v[3];
  return dest;
}
/**
 * Returns the dot product of two four-element vectors.
 */
function dotVec4(u, v) {
  return u[0] * v[0] + u[1] * v[1] + u[2] * v[2] + u[3] * v[3];
}
/**
 * Returns the cross product of two four-element vectors.
 */
function cross3Vec4(u, v) {
  var u0 = u[0];
  var u1 = u[1];
  var u2 = u[2];
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  return [u1 * v2 - u2 * v1, u2 * v0 - u0 * v2, u0 * v1 - u1 * v0, 0.0];
}
/**
 * Returns the cross product of two three-element vectors.
 */
function cross3Vec3(u, v, dest) {
  if (!dest) {
    dest = u;
  }
  var x = u[0];
  var y = u[1];
  var z = u[2];
  var x2 = v[0];
  var y2 = v[1];
  var z2 = v[2];
  dest[0] = y * z2 - z * y2;
  dest[1] = z * x2 - x * z2;
  dest[2] = x * y2 - y * x2;
  return dest;
}
function sqLenVec4(v) {
  return dotVec4(v, v);
}
/**
 * Returns the length of a four-element vector.
 * @method lenVec4
 * @static
 * @param {Array(Number)} v The vector
 * @return The length
 */
function lenVec4(v) {
  return Math.sqrt(sqLenVec4(v));
}
/**
 * Returns the dot product of two two-element vectors.
 */
function dotVec2(u, v) {
  return u[0] * v[0] + u[1] * v[1];
}
function sqLenVec3(v) {
  return dotVec3(v, v);
}
function sqLenVec2(v) {
  return dotVec2(v, v);
}
/**
 * Returns the length of a three-element vector.
 */
function lenVec3(v) {
  return Math.sqrt(sqLenVec3(v));
}
var distVec3 = function () {
  var vec = createVec3();
  return function (v, w) {
    return lenVec3(subVec3(v, w, vec));
  };
}();
/**
 * Returns the length of a two-element vector.
 */
function lenVec2(v) {
  return Math.sqrt(sqLenVec2(v));
}
/**
 * Linearly interpolates between two 3D vectors.
 */
function lerpVec3(t, t1, t2, p1, p2, dest) {
  var result = dest || createVec3();
  var f = (t - t1) / (t2 - t1);
  result[0] = p1[0] + f * (p2[0] - p1[0]);
  result[1] = p1[1] + f * (p2[1] - p1[1]);
  result[2] = p1[2] + f * (p2[2] - p1[2]);
  return result;
}
var distVec2 = function () {
  var vec = createVec2();
  return function (v, w) {
    return lenVec2(subVec2(v, w, vec));
  };
}();
/**
 * @method rcpVec3
 * @static
 * @param v createVec3
 * @param dest createVec3 - optional destination
 * @return [] dest if specified, v otherwise
 *
 */
function rcpVec3(v, dest) {
  return divScalarVec3(1.0, v, dest);
}
/**
 * Normalizes a four-element vector
 *
 */
function normalizeVec4(v, dest) {
  var f = 1.0 / lenVec4(v);
  return mulVec4Scalar(v, f, dest);
}
/**
 * Normalizes a three-element vector
 * @method normalizeVec4
 * @static
 */
function normalizeVec3(v, dest) {
  var f = 1.0 / lenVec3(v);
  return mulVec3Scalar(v, f, dest);
}
/**
 * Normalizes a two-element vector
 */
function normalizeVec2(v, dest) {
  var f = 1.0 / lenVec2(v);
  return mulVec2Scalar(v, f, dest);
}
/**
 * Gets the angle between two vectors
 */
function angleVec3(v, w) {
  var theta = dotVec3(v, w) / Math.sqrt(sqLenVec3(v) * sqLenVec3(w));
  theta = theta < -1 ? -1 : theta > 1 ? 1 : theta; // Clamp to handle numerical problems
  return Math.acos(theta);
}
/**
 * Creates a three-element vector from the rotation part of a sixteen-element matrix.
 */
var vec3FromMat4Scale = function () {
  var tempVec3 = createVec3();
  return function (m, dest) {
    tempVec3[0] = m[0];
    tempVec3[1] = m[1];
    tempVec3[2] = m[2];
    dest[0] = lenVec3(tempVec3);
    tempVec3[0] = m[4];
    tempVec3[1] = m[5];
    tempVec3[2] = m[6];
    dest[1] = lenVec3(tempVec3);
    tempVec3[0] = m[8];
    tempVec3[1] = m[9];
    tempVec3[2] = m[10];
    dest[2] = lenVec3(tempVec3);
    return dest;
  };
}();
/**
 * Converts an n-element vector to a JSON-serializable
 * array with values rounded to two decimal places.
 */
function vecToArray(v) {
  v = Array.prototype.slice.call(v);
  for (var i = 0, len = v.length; i < len; i++) {
    v[i] = trunc(v[i]);
  }
  return v;
}
function trunc(v) {
  return Math.round(v * 100000) / 100000;
}
/**
 * Calculates the normal vector of a triangle.
 */
function triangleNormal(a, b, c, normal) {
  if (normal === void 0) {
    normal = createVec3();
  }
  var p1x = b[0] - a[0];
  var p1y = b[1] - a[1];
  var p1z = b[2] - a[2];
  var p2x = c[0] - a[0];
  var p2y = c[1] - a[1];
  var p2z = c[2] - a[2];
  var p3x = p1y * p2z - p1z * p2y;
  var p3y = p1z * p2x - p1x * p2z;
  var p3z = p1x * p2y - p1y * p2x;
  var mag = Math.sqrt(p3x * p3x + p3y * p3y + p3z * p3z);
  if (mag === 0) {
    normal[0] = 0;
    normal[1] = 0;
    normal[2] = 0;
  } else {
    normal[0] = p3x / mag;
    normal[1] = p3y / mag;
    normal[2] = p3z / mag;
  }
  return normal;
}
/**
 * Returns a new, uninitialized 3x3 matrix.
 */
function createMat3(values) {
  // @ts-ignore
  return new newFloatArray(values || 9);
}
/**
 * Converts a 3x3 matrix to 4x4.
 */
function mat3ToMat4(mat3, mat4) {
  if (!mat4) {
    mat4 = createMat4();
  }
  mat4[0] = mat3[0];
  mat4[1] = mat3[1];
  mat4[2] = mat3[2];
  mat4[3] = 0;
  mat4[4] = mat3[3];
  mat4[5] = mat3[4];
  mat4[6] = mat3[5];
  mat4[7] = 0;
  mat4[8] = mat3[6];
  mat4[9] = mat3[7];
  mat4[10] = mat3[8];
  mat4[11] = 0;
  mat4[12] = 0;
  mat4[13] = 0;
  mat4[14] = 0;
  mat4[15] = 1;
  return mat4;
}
/**
 * Returns a new, uninitialized 4x4 matrix.
 */
function createMat4(values) {
  // @ts-ignore
  return newFloatArray(values || 16);
}
var tempMat4a$1 = createMat4();
var tempMat4b = createMat4();
/**
 * Returns true if the two 4x4 matrices are the same.
 * @param m1
 * @param m2
 * @returns {boolean}
 */
function compareMat4(m1, m2) {
  return m1[0] === m2[0] && m1[1] === m2[1] && m1[2] === m2[2] && m1[3] === m2[3] && m1[4] === m2[4] && m1[5] === m2[5] && m1[6] === m2[6] && m1[7] === m2[7] && m1[8] === m2[8] && m1[9] === m2[9] && m1[10] === m2[10] && m1[11] === m2[11] && m1[12] === m2[12] && m1[13] === m2[13] && m1[14] === m2[14] && m1[15] === m2[15];
}
/**
 * Returns a 4x4 perspective projection matrix.
 */
function perspectiveMat4(fovyrad, aspectratio, znear, zfar, m) {
  var pmin = [];
  var pmax = [];
  pmin[2] = znear;
  pmax[2] = zfar;
  pmax[1] = pmin[2] * Math.tan(fovyrad / 2.0);
  pmin[1] = -pmax[1];
  pmax[0] = pmax[1] * aspectratio;
  pmin[0] = -pmax[0];
  return frustumMat4v(pmin, pmax, m);
}
/**
 * Returns a 4x4 perspective frustum projection matrix.
 */
function frustumMat4v(fmin, fmax, m) {
  if (!m) {
    m = createMat4();
  }
  var fmin4 = [fmin[0], fmin[1], fmin[2], 0.0];
  var fmax4 = [fmax[0], fmax[1], fmax[2], 0.0];
  addVec4(fmax4, fmin4, tempMat4a$1);
  subVec4(fmax4, fmin4, tempMat4b);
  var t = 2.0 * fmin4[2];
  var tempMat4b0 = tempMat4b[0];
  var tempMat4b1 = tempMat4b[1];
  var tempMat4b2 = tempMat4b[2];
  m[0] = t / tempMat4b0;
  m[1] = 0.0;
  m[2] = 0.0;
  m[3] = 0.0;
  m[4] = 0.0;
  m[5] = t / tempMat4b1;
  m[6] = 0.0;
  m[7] = 0.0;
  m[8] = tempMat4a$1[0] / tempMat4b0;
  m[9] = tempMat4a$1[1] / tempMat4b1;
  m[10] = -tempMat4a$1[2] / tempMat4b2;
  m[11] = -1.0;
  m[12] = 0.0;
  m[13] = 0.0;
  m[14] = -t * fmax4[2] / tempMat4b2;
  m[15] = 0.0;
  return m;
}
/**
 * Returns a 4x4 orthographic projection matrix.
 */
function orthoMat4c(left, right, bottom, top, near, far, dest) {
  if (!dest) {
    dest = createMat4();
  }
  var rl = right - left;
  var tb = top - bottom;
  var fn = far - near;
  dest[0] = 2.0 / rl;
  dest[1] = 0.0;
  dest[2] = 0.0;
  dest[3] = 0.0;
  dest[4] = 0.0;
  dest[5] = 2.0 / tb;
  dest[6] = 0.0;
  dest[7] = 0.0;
  dest[8] = 0.0;
  dest[9] = 0.0;
  dest[10] = -2.0 / fn;
  dest[11] = 0.0;
  dest[12] = -(left + right) / rl;
  dest[13] = -(top + bottom) / tb;
  dest[14] = -(far + near) / fn;
  dest[15] = 1.0;
  return dest;
}
/**
 * Returns a 4x4 perspective projection matrix.
 */
function frustumMat4(left, right, bottom, top, near, far, dest) {
  if (!dest) {
    dest = createMat4();
  }
  var rl = right - left;
  var tb = top - bottom;
  var fn = far - near;
  dest[0] = near * 2 / rl;
  dest[1] = 0;
  dest[2] = 0;
  dest[3] = 0;
  dest[4] = 0;
  dest[5] = near * 2 / tb;
  dest[6] = 0;
  dest[7] = 0;
  dest[8] = (right + left) / rl;
  dest[9] = (top + bottom) / tb;
  dest[10] = -(far + near) / fn;
  dest[11] = -1;
  dest[12] = 0;
  dest[13] = 0;
  dest[14] = -(far * near * 2) / fn;
  dest[15] = 0;
  return dest;
}
/**
 * Returns a 4x4 identity matrix.
 */
function identityMat4(dest) {
  if (!dest) {
    dest = createMat4();
  }
  dest[0] = 1.0;
  dest[1] = 0.0;
  dest[2] = 0.0;
  dest[3] = 0.0;
  dest[4] = 0.0;
  dest[5] = 1.0;
  dest[6] = 0.0;
  dest[7] = 0.0;
  dest[8] = 0.0;
  dest[9] = 0.0;
  dest[10] = 1.0;
  dest[11] = 0.0;
  dest[12] = 0.0;
  dest[13] = 0.0;
  dest[14] = 0.0;
  dest[15] = 1.0;
  return dest;
}
/**
 * Returns a 3x3 identity matrix.
 */
function identityMat3(dest) {
  if (!dest) {
    dest = createMat4();
  }
  dest[0] = 1.0;
  dest[1] = 0.0;
  dest[2] = 0.0;
  dest[3] = 0.0;
  dest[4] = 1.0;
  dest[5] = 0.0;
  dest[6] = 0.0;
  dest[7] = 0.0;
  dest[8] = 1.0;
  return dest;
}
/**
 * Tests if the given 4x4 matrix is the identity matrix.
 */
function isIdentityMat4(m) {
  if (m[0] !== 1.0 || m[1] !== 0.0 || m[2] !== 0.0 || m[3] !== 0.0 || m[4] !== 0.0 || m[5] !== 1.0 || m[6] !== 0.0 || m[7] !== 0.0 || m[8] !== 0.0 || m[9] !== 0.0 || m[10] !== 1.0 || m[11] !== 0.0 || m[12] !== 0.0 || m[13] !== 0.0 || m[14] !== 0.0 || m[15] !== 1.0) {
    return false;
  }
  return true;
}
/**
 * Creates a 4x4 rotation matrix.
 */
function rotationMat4v(anglerad, axis, m) {
  if (!m) {
    m = createMat4();
  }
  var ax = normalizeVec4([axis[0], axis[1], axis[2], 0.0], []);
  var s = Math.sin(anglerad);
  var c = Math.cos(anglerad);
  var q = 1.0 - c;
  var x = ax[0];
  var y = ax[1];
  var z = ax[2];
  var xy;
  var yz;
  var zx;
  var xs;
  var ys;
  var zs;
  xy = x * y;
  yz = y * z;
  zx = z * x;
  xs = x * s;
  ys = y * s;
  zs = z * s;
  m[0] = q * x * x + c;
  m[1] = q * xy + zs;
  m[2] = q * zx - ys;
  m[3] = 0.0;
  m[4] = q * xy - zs;
  m[5] = q * y * y + c;
  m[6] = q * yz + xs;
  m[7] = 0.0;
  m[8] = q * zx + ys;
  m[9] = q * yz - xs;
  m[10] = q * z * z + c;
  m[11] = 0.0;
  m[12] = 0.0;
  m[13] = 0.0;
  m[14] = 0.0;
  m[15] = 1.0;
  return m;
}
/**
 * Creates a 4x4 'lookat' viewing transform matrix.
 */
function lookAtMat4v(pos, target, up, dest) {
  if (!dest) {
    dest = createMat4();
  }
  var posx = pos[0];
  var posy = pos[1];
  var posz = pos[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var targetx = target[0];
  var targety = target[1];
  var targetz = target[2];
  if (posx === targetx && posy === targety && posz === targetz) {
    return identityMat4();
  }
  var z0;
  var z1;
  var z2;
  var x0;
  var x1;
  var x2;
  var y0;
  var y1;
  var y2;
  var len;
  //createVec3.direction(eye, center, z);
  z0 = posx - targetx;
  z1 = posy - targety;
  z2 = posz - targetz;
  // normalize (no check needed for 0 because of early return)
  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  //createVec3.normalize(createVec3.cross(up, z, x));
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }
  //createVec3.normalize(createVec3.cross(z, x, y));
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }
  dest[0] = x0;
  dest[1] = y0;
  dest[2] = z0;
  dest[3] = 0;
  dest[4] = x1;
  dest[5] = y1;
  dest[6] = z1;
  dest[7] = 0;
  dest[8] = x2;
  dest[9] = y2;
  dest[10] = z2;
  dest[11] = 0;
  dest[12] = -(x0 * posx + x1 * posy + x2 * posz);
  dest[13] = -(y0 * posx + y1 * posy + y2 * posz);
  dest[14] = -(z0 * posx + z1 * posy + z2 * posz);
  dest[15] = 1;
  return dest;
}
/**
 * Returns the inverse of the given 4x4 matrix.
 */
function inverseMat4(mat, dest) {
  if (!dest) {
    dest = mat;
  }
  var a00 = mat[0];
  var a01 = mat[1];
  var a02 = mat[2];
  var a03 = mat[3];
  var a10 = mat[4];
  var a11 = mat[5];
  var a12 = mat[6];
  var a13 = mat[7];
  var a20 = mat[8];
  var a21 = mat[9];
  var a22 = mat[10];
  var a23 = mat[11];
  var a30 = mat[12];
  var a31 = mat[13];
  var a32 = mat[14];
  var a33 = mat[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);
  dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
  dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
  dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
  dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
  dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
  dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
  dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
  dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
  dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
  dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
  dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
  dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
  dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
  dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
  dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
  dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
  return dest;
}
/**
 * Transposes the given 4x4 matrix.
 */
function transposeMat4(mat, dest) {
  var m4 = mat[4];
  var m14 = mat[14];
  var m8 = mat[8];
  var m13 = mat[13];
  var m12 = mat[12];
  var m9 = mat[9];
  if (!dest || mat === dest) {
    var a01 = mat[1];
    var a02 = mat[2];
    var a03 = mat[3];
    var a12 = mat[6];
    var a13 = mat[7];
    var a23 = mat[11];
    mat[1] = m4;
    mat[2] = m8;
    mat[3] = m12;
    mat[4] = a01;
    mat[6] = m9;
    mat[7] = m13;
    mat[8] = a02;
    mat[9] = a12;
    mat[11] = m14;
    mat[12] = a03;
    mat[13] = a13;
    mat[14] = a23;
    return mat;
  }
  dest[0] = mat[0];
  dest[1] = m4;
  dest[2] = m8;
  dest[3] = m12;
  dest[4] = mat[1];
  dest[5] = mat[5];
  dest[6] = m9;
  dest[7] = m13;
  dest[8] = mat[2];
  dest[9] = mat[6];
  dest[10] = mat[10];
  dest[11] = m14;
  dest[12] = mat[3];
  dest[13] = mat[7];
  dest[14] = mat[11];
  dest[15] = mat[15];
  return dest;
}
/**
 * Multiplies the given 4x4 matrix by the given four-element vector.
 */
function mulMat4v4(m, v, dest) {
  if (!dest) {
    dest = m;
  }
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  var v3 = v[3];
  dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;
  dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;
  dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;
  dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;
  return dest;
}
/**
 * Multiplies the two given 4x4 matrix by each other.
 * @method mulMat4
 * @static
 */
function mulMat4(a, b, dest) {
  if (!dest) {
    dest = a;
  }
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  var a30 = a[12];
  var a31 = a[13];
  var a32 = a[14];
  var a33 = a[15];
  var b00 = b[0];
  var b01 = b[1];
  var b02 = b[2];
  var b03 = b[3];
  var b10 = b[4];
  var b11 = b[5];
  var b12 = b[6];
  var b13 = b[7];
  var b20 = b[8];
  var b21 = b[9];
  var b22 = b[10];
  var b23 = b[11];
  var b30 = b[12];
  var b31 = b[13];
  var b32 = b[14];
  var b33 = b[15];
  dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
  dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
  dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
  dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
  dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
  dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
  dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
  dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
  dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
  dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
  dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
  dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
  dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
  dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
  dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
  dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
  return dest;
}
/**
 * Multiplies the two given 3x3 matrices by each other.
 */
function mulMat3(a, b, dest) {
  if (dest === void 0) {
    dest = newFloatArray(9);
  }
  var a11 = a[0];
  var a12 = a[3];
  var a13 = a[6];
  var a21 = a[1];
  var a22 = a[4];
  var a23 = a[7];
  var a31 = a[2];
  var a32 = a[5];
  var a33 = a[8];
  var b11 = b[0];
  var b12 = b[3];
  var b13 = b[6];
  var b21 = b[1];
  var b22 = b[4];
  var b23 = b[7];
  var b31 = b[2];
  var b32 = b[5];
  var b33 = b[8];
  dest[0] = a11 * b11 + a12 * b21 + a13 * b31;
  dest[3] = a11 * b12 + a12 * b22 + a13 * b32;
  dest[6] = a11 * b13 + a12 * b23 + a13 * b33;
  dest[1] = a21 * b11 + a22 * b21 + a23 * b31;
  dest[4] = a21 * b12 + a22 * b22 + a23 * b32;
  dest[7] = a21 * b13 + a22 * b23 + a23 * b33;
  dest[2] = a31 * b11 + a32 * b21 + a33 * b31;
  dest[5] = a31 * b12 + a32 * b22 + a33 * b32;
  dest[8] = a31 * b13 + a32 * b23 + a33 * b33;
  return dest;
}
/**
 * Transforms a three-element position by a 4x4 matrix.
 * @method transformPoint3
 * @static
 */
function transformPoint3(m, p, dest) {
  if (!dest) {
    dest = p;
  }
  var x = p[0];
  var y = p[1];
  var z = p[2];
  dest[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
  dest[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
  dest[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
  return dest;
}
/**
 * Transforms a homogeneous coordinate by a 4x4 matrix.
 * @method transformPoint3
 * @static
 */
function transformPoint4(m, v, dest) {
  dest[0] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3];
  dest[1] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3];
  dest[2] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3];
  dest[3] = m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3];
  return dest;
}
/**
 * Transforms an array of three-element positions by a 4x4 matrix.
 * @method transformPoints3
 * @static
 */
function transformPoints3(m, points, points2) {
  var result = points2 || [];
  var len = points.length;
  var p0;
  var p1;
  var p2;
  var pi;
  // cache values
  var m0 = m[0];
  var m1 = m[1];
  var m2 = m[2];
  var m3 = m[3];
  var m4 = m[4];
  var m5 = m[5];
  var m6 = m[6];
  var m7 = m[7];
  var m8 = m[8];
  var m9 = m[9];
  var m10 = m[10];
  var m11 = m[11];
  var m12 = m[12];
  var m13 = m[13];
  var m14 = m[14];
  var m15 = m[15];
  var r;
  for (var i = 0; i < len; ++i) {
    // cache values
    pi = points[i];
    p0 = pi[0];
    p1 = pi[1];
    p2 = pi[2];
    r = result[i] || (result[i] = [0, 0, 0]);
    r[0] = m0 * p0 + m4 * p1 + m8 * p2 + m12;
    r[1] = m1 * p0 + m5 * p1 + m9 * p2 + m13;
    r[2] = m2 * p0 + m6 * p1 + m10 * p2 + m14;
    r[3] = m3 * p0 + m7 * p1 + m11 * p2 + m15;
  }
  result.length = len;
  return result;
}
/**
 * Transforms an array of positions by a 4x4 matrix.
 */
function transformPositions3(m, p, p2) {
  if (!p2) {
    p2 = p;
  }
  var i;
  var len = p.length;
  var x;
  var y;
  var z;
  var m0 = m[0];
  var m1 = m[1];
  var m2 = m[2];
  var m3 = m[3];
  var m4 = m[4];
  var m5 = m[5];
  var m6 = m[6];
  var m7 = m[7];
  var m8 = m[8];
  var m9 = m[9];
  var m10 = m[10];
  var m11 = m[11];
  var m12 = m[12];
  var m13 = m[13];
  var m14 = m[14];
  var m15 = m[15];
  for (i = 0; i < len; i += 3) {
    x = p[i + 0];
    y = p[i + 1];
    z = p[i + 2];
    p2[i + 0] = m0 * x + m4 * y + m8 * z + m12;
    p2[i + 1] = m1 * x + m5 * y + m9 * z + m13;
    p2[i + 2] = m2 * x + m6 * y + m10 * z + m14;
    p2[i + 3] = m3 * x + m7 * y + m11 * z + m15;
  }
  return p2;
}
/**
 * Transforms an array of positions by a 4x4 matrix.
 */
function transformPositions4(m, p, p2) {
  if (!p2) {
    p2 = p;
  }
  var i;
  var len = p.length;
  var x;
  var y;
  var z;
  var m0 = m[0];
  var m1 = m[1];
  var m2 = m[2];
  var m3 = m[3];
  var m4 = m[4];
  var m5 = m[5];
  var m6 = m[6];
  var m7 = m[7];
  var m8 = m[8];
  var m9 = m[9];
  var m10 = m[10];
  var m11 = m[11];
  var m12 = m[12];
  var m13 = m[13];
  var m14 = m[14];
  var m15 = m[15];
  for (i = 0; i < len; i += 4) {
    x = p[i + 0];
    y = p[i + 1];
    z = p[i + 2];
    p2[i + 0] = m0 * x + m4 * y + m8 * z + m12;
    p2[i + 1] = m1 * x + m5 * y + m9 * z + m13;
    p2[i + 2] = m2 * x + m6 * y + m10 * z + m14;
    p2[i + 3] = m3 * x + m7 * y + m11 * z + m15;
  }
  return p2;
}
/**
 * Transforms a three-element vector by a 4x4 matrix.
 */
function transformVec3(m, v, dest) {
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  dest = dest || createVec3();
  dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2;
  dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2;
  dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2;
  return dest;
}
/**
 * Transforms a four-element vector by a 4x4 matrix.
 * @method transformVec4
 * @static
 */
function transformVec4(m, v, dest) {
  var v0 = v[0];
  var v1 = v[1];
  var v2 = v[2];
  var v3 = v[3];
  dest = dest || createVec4();
  dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;
  dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;
  dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;
  dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;
  return dest;
}
/**
 * Efficiently post-concatenates a scaling to the given matrix.
 */
function scaleMat4v(xyz, m) {
  if (m === void 0) {
    m = identityMat4();
  }
  var x = xyz[0];
  var y = xyz[1];
  var z = xyz[2];
  m[0] *= x;
  m[4] *= y;
  m[8] *= z;
  m[1] *= x;
  m[5] *= y;
  m[9] *= z;
  m[2] *= x;
  m[6] *= y;
  m[10] *= z;
  m[3] *= x;
  m[7] *= y;
  m[11] *= z;
  return m;
}
/**
 */
function scalingMat4v(v, m) {
  if (m === void 0) {
    m = identityMat4();
  }
  m[0] = v[0];
  m[5] = v[1];
  m[10] = v[2];
  return m;
}
/**
 * Returns a 3x3 scale matrix.
 */
function scalingMat3v(v, m) {
  if (m === void 0) {
    m = identityMat3();
  }
  m[0] = v[0];
  m[4] = v[1];
  return m;
}
/**
 * Returns a 4x4 scale matrix.
 */
var scalingMat4c = function () {
  var xyz = newFloatArray(3);
  return function (x, y, z, dest) {
    xyz[0] = x;
    xyz[1] = y;
    xyz[2] = z;
    return scalingMat4v(xyz, dest);
  };
}();
/**
 * Efficiently post-concatenates a scaling to the given matrix.
 * @method scaleMat4c
 * @param x
 * @param y
 * @param z
 * @param m
 */
function scaleMat4c(x, y, z, m) {
  m[0] *= x;
  m[4] *= y;
  m[8] *= z;
  m[1] *= x;
  m[5] *= y;
  m[9] *= z;
  m[2] *= x;
  m[6] *= y;
  m[10] *= z;
  m[3] *= x;
  m[7] *= y;
  m[11] *= z;
  return m;
}
/**
 * Returns 4x4 scale matrix.
 */
function scalingMat4s(s) {
  return scalingMat4c(s, s, s);
}
/**
 * Composes a 4x4 matrix from the given position, quaternion and scale.
 * @param position
 * @param quaternion
 * @param scale
 * @param mat
 */
function composeMat4(position, quaternion, scale, mat) {
  if (mat === void 0) {
    mat = createMat4();
  }
  quatToRotationMat4(quaternion, mat);
  scaleMat4v(scale, mat);
  translateMat4v(position, mat);
  return mat;
}
/**
 * Decomposes a 4x4 matrix into position, quaternion and scale.
 */
var decomposeMat4 = function () {
  var vec = createVec3();
  var matrix = createMat4();
  return function decompose(mat, position, quaternion, scale) {
    vec[0] = mat[0];
    vec[1] = mat[1];
    vec[2] = mat[2];
    var sx = lenVec3(vec);
    vec[0] = mat[4];
    vec[1] = mat[5];
    vec[2] = mat[6];
    var sy = lenVec3(vec);
    vec[8] = mat[8];
    vec[9] = mat[9];
    vec[10] = mat[10];
    var sz = lenVec3(vec);
    var det = determinantMat4(mat);
    if (det < 0) {
      sx = -sx;
    }
    position[0] = mat[12];
    position[1] = mat[13];
    position[2] = mat[14];
    // scale the rotation part
    // @ts-ignore
    matrix.set(mat);
    var invSX = 1 / sx;
    var invSY = 1 / sy;
    var invSZ = 1 / sz;
    matrix[0] *= invSX;
    matrix[1] *= invSX;
    matrix[2] *= invSX;
    matrix[4] *= invSY;
    matrix[5] *= invSY;
    matrix[6] *= invSY;
    matrix[8] *= invSZ;
    matrix[9] *= invSZ;
    matrix[10] *= invSZ;
    mat4ToQuat(matrix, quaternion);
    scale[0] = sx;
    scale[1] = sy;
    scale[2] = sz;
  };
}();
/**
 * Efficiently post-concatenates a translation to the given matrix.
 */
function translateMat4v(xyz, m) {
  if (m === void 0) {
    m = identityMat4();
  }
  return translateMat4c(xyz[0], xyz[1], xyz[2], m);
}
/**
 * Efficiently post-concatenates a translation, given as separate components, to the given matrix.
 */
function translateMat4c(x, y, z, m) {
  if (m === void 0) {
    m = identityMat4();
  }
  var m3 = m[3];
  m[0] += m3 * x;
  m[1] += m3 * y;
  m[2] += m3 * z;
  var m7 = m[7];
  m[4] += m7 * x;
  m[5] += m7 * y;
  m[6] += m7 * z;
  var m11 = m[11];
  m[8] += m11 * x;
  m[9] += m11 * y;
  m[10] += m11 * z;
  var m15 = m[15];
  m[12] += m15 * x;
  m[13] += m15 * y;
  m[14] += m15 * z;
  return m;
}
/**
 * Creates a new matrix that replaces the translation in the rightmost column of the given
 * affine matrix with the given translation.
 */
function setMat4Translation(m, translation, dest) {
  dest[0] = m[0];
  dest[1] = m[1];
  dest[2] = m[2];
  dest[3] = m[3];
  dest[4] = m[4];
  dest[5] = m[5];
  dest[6] = m[6];
  dest[7] = m[7];
  dest[8] = m[8];
  dest[9] = m[9];
  dest[10] = m[10];
  dest[11] = m[11];
  dest[12] = translation[0];
  dest[13] = translation[1];
  dest[14] = translation[2];
  dest[15] = m[15];
  return dest;
}
/**
 * Returns 4x4 translation matrix.
 */
function translationMat4v(v, dest) {
  var m = dest || identityMat4();
  m[12] = v[0];
  m[13] = v[1];
  m[14] = v[2];
  return m;
}
/**
 * Returns 3x3 translation matrix.
 */
function translationMat3v(v, dest) {
  var m = dest || identityMat3();
  m[6] = v[0];
  m[7] = v[1];
  return m;
}
/**
 * Returns 4x4 translation matrix.
 */
var translationMat4c = function () {
  var xyz = newFloatArray(3);
  return function (x, y, z, dest) {
    xyz[0] = x;
    xyz[1] = y;
    xyz[2] = z;
    return translationMat4v(xyz, dest);
  };
}();
/**
 * Returns 4x4 translation matrix.
 */
function translationMat4s(s, dest) {
  return translationMat4c(s, s, s, dest);
}
/**
 * Returns the determinant of the given 4x4 matrix.
 */
function determinantMat4(mat) {
  var a00 = mat[0];
  var a01 = mat[1];
  var a02 = mat[2];
  var a03 = mat[3];
  var a10 = mat[4];
  var a11 = mat[5];
  var a12 = mat[6];
  var a13 = mat[7];
  var a20 = mat[8];
  var a21 = mat[9];
  var a22 = mat[10];
  var a23 = mat[11];
  var a30 = mat[12];
  var a31 = mat[13];
  var a32 = mat[14];
  var a33 = mat[15];
  return a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 + a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 + a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 + a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 + a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 + a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33;
}
/**
 * Gets Euler angles from a 4x4 matrix.
 *
 * @param {mat The 4x4 matrix.
 * @param order Desired Euler angle order: "XYZ", "YXZ", "ZXY" etc.
 * @param [dest] Destination Euler angles, created by default.
 * @returns  The Euler angles.
 */
function mat4ToEuler(mat, order, dest) {
  if (dest === void 0) {
    dest = createVec3();
  }
  // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
  var m11 = mat[0];
  var m12 = mat[4];
  var m13 = mat[8];
  var m21 = mat[1];
  var m22 = mat[5];
  var m23 = mat[9];
  var m31 = mat[2];
  var m32 = mat[6];
  var m33 = mat[10];
  if (order === 'XYZ') {
    dest[1] = Math.asin(clamp(m13, -1, 1));
    if (Math.abs(m13) < 0.99999) {
      dest[0] = Math.atan2(-m23, m33);
      dest[2] = Math.atan2(-m12, m11);
    } else {
      dest[0] = Math.atan2(m32, m22);
      dest[2] = 0;
    }
  } else if (order === 'YXZ') {
    dest[0] = Math.asin(-clamp(m23, -1, 1));
    if (Math.abs(m23) < 0.99999) {
      dest[1] = Math.atan2(m13, m33);
      dest[2] = Math.atan2(m21, m22);
    } else {
      dest[1] = Math.atan2(-m31, m11);
      dest[2] = 0;
    }
  } else if (order === 'ZXY') {
    dest[0] = Math.asin(clamp(m32, -1, 1));
    if (Math.abs(m32) < 0.99999) {
      dest[1] = Math.atan2(-m31, m33);
      dest[2] = Math.atan2(-m12, m22);
    } else {
      dest[1] = 0;
      dest[2] = Math.atan2(m21, m11);
    }
  } else if (order === 'ZYX') {
    dest[1] = Math.asin(-clamp(m31, -1, 1));
    if (Math.abs(m31) < 0.99999) {
      dest[0] = Math.atan2(m32, m33);
      dest[2] = Math.atan2(m21, m11);
    } else {
      dest[0] = 0;
      dest[2] = Math.atan2(-m12, m22);
    }
  } else if (order === 'YZX') {
    dest[2] = Math.asin(clamp(m21, -1, 1));
    if (Math.abs(m21) < 0.99999) {
      dest[0] = Math.atan2(-m23, m22);
      dest[1] = Math.atan2(-m31, m11);
    } else {
      dest[0] = 0;
      dest[1] = Math.atan2(m13, m33);
    }
  } else if (order === 'XZY') {
    dest[2] = Math.asin(-clamp(m12, -1, 1));
    if (Math.abs(m12) < 0.99999) {
      dest[0] = Math.atan2(m32, m22);
      dest[1] = Math.atan2(m13, m11);
    } else {
      dest[0] = Math.atan2(-m23, m33);
      dest[1] = 0;
    }
  }
  return dest;
}
/**
 * Linearly interpolates between two 4x4 matrices.
 */
function lerpMat4(t, t1, t2, m1, m2, dest) {
  var result = dest || createMat4();
  var f = (t - t1) / (t2 - t1);
  result[0] = m1[0] + f * (m2[0] - m1[0]);
  result[1] = m1[1] + f * (m2[1] - m1[1]);
  result[2] = m1[2] + f * (m2[2] - m1[2]);
  result[3] = m1[3] + f * (m2[3] - m1[3]);
  result[4] = m1[4] + f * (m2[4] - m1[4]);
  result[5] = m1[5] + f * (m2[5] - m1[5]);
  result[6] = m1[6] + f * (m2[6] - m1[6]);
  result[7] = m1[7] + f * (m2[7] - m1[7]);
  result[8] = m1[8] + f * (m2[8] - m1[8]);
  result[9] = m1[9] + f * (m2[9] - m1[9]);
  result[10] = m1[10] + f * (m2[10] - m1[10]);
  result[11] = m1[11] + f * (m2[11] - m1[11]);
  result[12] = m1[12] + f * (m2[12] - m1[12]);
  result[13] = m1[13] + f * (m2[13] - m1[13]);
  result[14] = m1[14] + f * (m2[14] - m1[14]);
  result[15] = m1[15] + f * (m2[15] - m1[15]);
  return result;
}
/**
 * Craetes an identity quaternion.
 * @param dest Optional quaternion to initialize
 * @returns New quaternion
 */
function identityQuat(dest) {
  if (dest === void 0) {
    dest = createVec4();
  }
  dest[0] = 0.0;
  dest[1] = 0.0;
  dest[2] = 0.0;
  dest[3] = 1.0;
  return dest;
}
/**
 * Initializes a quaternion from Euler angles.
 *
 * @param  euler The Euler angles.
 * @param  order Euler angle order: "XYZ", "YXZ", "ZXY" etc.
 * @param  [dest] Destination quaternion, created by default.
 * @returns  The quaternion.
 */
function eulerToQuat(euler, order, dest) {
  if (dest === void 0) {
    dest = createVec4();
  }
  // http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
  var a = euler[0] * DEGTORAD / 2;
  var b = euler[1] * DEGTORAD / 2;
  var c = euler[2] * DEGTORAD / 2;
  var c1 = Math.cos(a);
  var c2 = Math.cos(b);
  var c3 = Math.cos(c);
  var s1 = Math.sin(a);
  var s2 = Math.sin(b);
  var s3 = Math.sin(c);
  if (order === "XYZ") {
    dest[0] = s1 * c2 * c3 + c1 * s2 * s3;
    dest[1] = c1 * s2 * c3 - s1 * c2 * s3;
    dest[2] = c1 * c2 * s3 + s1 * s2 * c3;
    dest[3] = c1 * c2 * c3 - s1 * s2 * s3;
  } else if (order === "YXZ") {
    dest[0] = s1 * c2 * c3 + c1 * s2 * s3;
    dest[1] = c1 * s2 * c3 - s1 * c2 * s3;
    dest[2] = c1 * c2 * s3 - s1 * s2 * c3;
    dest[3] = c1 * c2 * c3 + s1 * s2 * s3;
  } else if (order === "ZXY") {
    dest[0] = s1 * c2 * c3 - c1 * s2 * s3;
    dest[1] = c1 * s2 * c3 + s1 * c2 * s3;
    dest[2] = c1 * c2 * s3 + s1 * s2 * c3;
    dest[3] = c1 * c2 * c3 - s1 * s2 * s3;
  } else if (order === "ZYX") {
    dest[0] = s1 * c2 * c3 - c1 * s2 * s3;
    dest[1] = c1 * s2 * c3 + s1 * c2 * s3;
    dest[2] = c1 * c2 * s3 - s1 * s2 * c3;
    dest[3] = c1 * c2 * c3 + s1 * s2 * s3;
  } else if (order === "YZX") {
    dest[0] = s1 * c2 * c3 + c1 * s2 * s3;
    dest[1] = c1 * s2 * c3 + s1 * c2 * s3;
    dest[2] = c1 * c2 * s3 - s1 * s2 * c3;
    dest[3] = c1 * c2 * c3 - s1 * s2 * s3;
  } else if (order === "XZY") {
    dest[0] = s1 * c2 * c3 - c1 * s2 * s3;
    dest[1] = c1 * s2 * c3 - s1 * c2 * s3;
    dest[2] = c1 * c2 * s3 + s1 * s2 * c3;
    dest[3] = c1 * c2 * c3 + s1 * s2 * s3;
  }
  return dest;
}
/**
 * Encodes rotation from a matrix into a quaternion.
 * @param m The matrix
 * @param dest The quaternion
 */
function mat4ToQuat(m, dest) {
  if (dest === void 0) {
    dest = createVec4();
  }
  // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
  var m11 = m[0];
  var m12 = m[4];
  var m13 = m[8];
  var m21 = m[1];
  var m22 = m[5];
  var m23 = m[9];
  var m31 = m[2];
  var m32 = m[6];
  var m33 = m[10];
  var s;
  var trace = m11 + m22 + m33;
  if (trace > 0) {
    s = 0.5 / Math.sqrt(trace + 1.0);
    dest[3] = 0.25 / s;
    dest[0] = (m32 - m23) * s;
    dest[1] = (m13 - m31) * s;
    dest[2] = (m21 - m12) * s;
  } else if (m11 > m22 && m11 > m33) {
    s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
    dest[3] = (m32 - m23) / s;
    dest[0] = 0.25 * s;
    dest[1] = (m12 + m21) / s;
    dest[2] = (m13 + m31) / s;
  } else if (m22 > m33) {
    s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
    dest[3] = (m13 - m31) / s;
    dest[0] = (m12 + m21) / s;
    dest[1] = 0.25 * s;
    dest[2] = (m23 + m32) / s;
  } else {
    s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
    dest[3] = (m21 - m12) / s;
    dest[0] = (m13 + m31) / s;
    dest[1] = (m23 + m32) / s;
    dest[2] = 0.25 * s;
  }
  return dest;
}
/**
 *
 * @param u
 * @param v
 * @param dest
 */
function vec3PairToQuat(u, v, dest) {
  if (dest === void 0) {
    dest = createVec4();
  }
  var norm_u_norm_v = Math.sqrt(dotVec3(u, u) * dotVec3(v, v));
  var real_part = norm_u_norm_v + dotVec3(u, v);
  if (real_part < 0.00000001 * norm_u_norm_v) {
    // If u and v are exactly opposite, rotate 180 degrees
    // around an arbitrary orthogonal axis. Axis normalisation
    // can happen later, when we normalise the quaternion.
    real_part = 0.0;
    if (Math.abs(u[0]) > Math.abs(u[2])) {
      dest[0] = -u[1];
      dest[1] = u[0];
      dest[2] = 0;
    } else {
      dest[0] = 0;
      dest[1] = -u[2];
      dest[2] = u[1];
    }
  } else {
    // Otherwise, build quaternion the standard way.
    cross3Vec3(u, v, dest);
  }
  dest[3] = real_part;
  return normalizeQuat(dest);
}
/**
 * Converts an angle-axis rotation representation into a quaternion
 * @param angleAxis
 * @param dest
 */
function angleAxisToQuaternion(angleAxis, dest) {
  if (dest === void 0) {
    dest = createVec4();
  }
  var halfAngle = angleAxis[3] / 2.0;
  var fsin = Math.sin(halfAngle);
  dest[0] = fsin * angleAxis[0];
  dest[1] = fsin * angleAxis[1];
  dest[2] = fsin * angleAxis[2];
  dest[3] = Math.cos(halfAngle);
  return dest;
}
/**
 * Converts a quaternion to Euler angles
 * @param q
 * @param order
 * @param dest
 */
function quatToEuler(q, order, dest) {
  if (dest === void 0) {
    dest = createVec3();
  }
  quatToRotationMat4(q, tempMat4a$1);
  mat4ToEuler(tempMat4a$1, order, dest);
  return dest;
}
/**
 * Multiples a pair of quaternions
 * @param p
 * @param q
 * @param dest
 */
function mulQuats(p, q, dest) {
  if (dest === void 0) {
    dest = createVec4();
  }
  var p0 = p[0];
  var p1 = p[1];
  var p2 = p[2];
  var p3 = p[3];
  var q0 = q[0];
  var q1 = q[1];
  var q2 = q[2];
  var q3 = q[3];
  dest[0] = p3 * q0 + p0 * q3 + p1 * q2 - p2 * q1;
  dest[1] = p3 * q1 + p1 * q3 + p2 * q0 - p0 * q2;
  dest[2] = p3 * q2 + p2 * q3 + p0 * q1 - p1 * q0;
  dest[3] = p3 * q3 - p0 * q0 - p1 * q1 - p2 * q2;
  return dest;
}
/**
 *
 * @param q
 * @param vec
 * @param dest
 */
function vec3ApplyQuat(q, vec, dest) {
  if (dest === void 0) {
    dest = createVec3();
  }
  var x = vec[0];
  var y = vec[1];
  var z = vec[2];
  var qx = q[0];
  var qy = q[1];
  var qz = q[2];
  var qw = q[3];
  // calculate quat * vector
  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z;
  // calculate result * inverse quat
  dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return dest;
}
/**
 * Converts a quaternion into a matrix.
 * @param q
 * @param dest
 */
function quatToMat4(q, dest) {
  dest = identityMat4(dest);
  var q0 = q[0]; //x
  var q1 = q[1]; //y
  var q2 = q[2]; //z
  var q3 = q[3]; //w
  var tx = 2.0 * q0;
  var ty = 2.0 * q1;
  var tz = 2.0 * q2;
  var twx = tx * q3;
  var twy = ty * q3;
  var twz = tz * q3;
  var txx = tx * q0;
  var txy = ty * q0;
  var txz = tz * q0;
  var tyy = ty * q1;
  var tyz = tz * q1;
  var tzz = tz * q2;
  dest[0] = 1.0 - (tyy + tzz);
  dest[1] = txy + twz;
  dest[2] = txz - twy;
  dest[4] = txy - twz;
  dest[5] = 1.0 - (txx + tzz);
  dest[6] = tyz + twx;
  dest[8] = txz + twy;
  dest[9] = tyz - twx;
  dest[10] = 1.0 - (txx + tyy);
  return dest;
}
/**
 * Converts a quaternion into a rotation matrix.
 * @param q
 * @param m
 */
function quatToRotationMat4(q, m) {
  var x = q[0];
  var y = q[1];
  var z = q[2];
  var w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  m[0] = 1 - (yy + zz);
  m[4] = xy - wz;
  m[8] = xz + wy;
  m[1] = xy + wz;
  m[5] = 1 - (xx + zz);
  m[9] = yz - wx;
  m[2] = xz - wy;
  m[6] = yz + wx;
  m[10] = 1 - (xx + yy);
  // last column
  m[3] = 0;
  m[7] = 0;
  m[11] = 0;
  // bottom row
  m[12] = 0;
  m[13] = 0;
  m[14] = 0;
  m[15] = 1;
  return m;
}
/**
 * Normalizes a quaternion
 * @param q
 * @param dest
 * @returns The normalized quaternion
 */
function normalizeQuat(q, dest) {
  if (dest === void 0) {
    dest = q;
  }
  var len = lenVec4([q[0], q[1], q[2], q[3]]);
  dest[0] = q[0] / len;
  dest[1] = q[1] / len;
  dest[2] = q[2] / len;
  dest[3] = q[3] / len;
  return dest;
}
/**
 * Gets the conjugate of a quaternion.
 * @param q
 * @param dest
 * @returns The conjugate of the quaternion
 */
function conjugateQuat(q, dest) {
  if (dest === void 0) {
    dest = q;
  }
  dest[0] = -q[0];
  dest[1] = -q[1];
  dest[2] = -q[2];
  dest[3] = q[3];
  return dest;
}
/**
 * Gets the inverse of a quaternion.
 * @param q
 * @param dest
 * @returns The inverse quaternion
 */
function inverseQuat(q, dest) {
  return normalizeQuat(conjugateQuat(q, dest));
}
/**
 * Converts a quaternion to angle-axis representation.
 * @param q
 * @param angleAxis
 * @returns The angle-axis rotation
 */
function quatToAngleAxis(q, angleAxis) {
  if (angleAxis === void 0) {
    angleAxis = createVec4();
  }
  q = normalizeQuat(q, tempVec4a$2);
  var q3 = q[3];
  var angle = 2 * Math.acos(q3);
  var s = Math.sqrt(1 - q3 * q3);
  if (s < 0.001) {
    // test to avoid divide by zero, s is always positive due to sqrt
    angleAxis[0] = q[0];
    angleAxis[1] = q[1];
    angleAxis[2] = q[2];
  } else {
    angleAxis[0] = q[0] / s;
    angleAxis[1] = q[1] / s;
    angleAxis[2] = q[2] / s;
  }
  angleAxis[3] = angle; // * 57.295779579;
  return angleAxis;
}
/**
 * Finds the intersection of a 3D ray with a 3D triangle.
 */
function rayTriangleIntersect(origin, dir, a, b, c, isect) {
  isect = isect || createVec3();
  var EPSILON = 0.000001;
  var edge1 = subVec3(b, a, tempVec3$3);
  var edge2 = subVec3(c, a, tempVec3b$6);
  var pvec = cross3Vec3(dir, edge2, tempVec3c$5);
  var det = dotVec3(edge1, pvec);
  if (det < EPSILON) {
    return null;
  }
  var tvec = subVec3(origin, a, tempVec3d$2);
  var u = dotVec3(tvec, pvec);
  if (u < 0 || u > det) {
    return null;
  }
  var qvec = cross3Vec3(tvec, edge1, tempVec3e$1);
  var v = dotVec3(dir, qvec);
  if (v < 0 || u + v > det) {
    return null;
  }
  var t = dotVec3(edge2, qvec) / det;
  isect[0] = origin[0] + t * dir[0];
  isect[1] = origin[1] + t * dir[1];
  isect[2] = origin[2] + t * dir[2];
  return isect;
}
/**
 Transforms a ray by a matrix.
 @param matrix 4x4 matrix
 @param rayOrigin The ray origin
 @param rayDir The ray direction
 @param rayOriginDest The transformed ray origin
 @param rayDirDest The transformed ray direction
 */
function transformRay(matrix, rayOrigin, rayDir, rayOriginDest, rayDirDest) {
  tempVec4a$2[0] = rayOrigin[0];
  tempVec4a$2[1] = rayOrigin[1];
  tempVec4a$2[2] = rayOrigin[2];
  tempVec4a$2[3] = 1;
  transformVec4(matrix, tempVec4a$2, tempVec4b$2);
  rayOriginDest[0] = tempVec4b$2[0];
  rayOriginDest[1] = tempVec4b$2[1];
  rayOriginDest[2] = tempVec4b$2[2];
  tempVec4a$2[0] = rayDir[0];
  tempVec4a$2[1] = rayDir[1];
  tempVec4a$2[2] = rayDir[2];
  transformVec3(matrix, tempVec4a$2, tempVec4b$2);
  normalizeVec3(tempVec4b$2);
  rayDirDest[0] = tempVec4b$2[0];
  rayDirDest[1] = tempVec4b$2[1];
  rayDirDest[2] = tempVec4b$2[2];
}

var index$j = {
  __proto__: null,
  dotVec3: dotVec3,
  createVec2: createVec2,
  createVec3: createVec3,
  createVec4: createVec4,
  negateVec3: negateVec3,
  negateVec4: negateVec4,
  addVec4: addVec4,
  addVec4Scalar: addVec4Scalar,
  mulVec4Scalar: mulVec4Scalar,
  mulVec3Scalar: mulVec3Scalar,
  mulVec2Scalar: mulVec2Scalar,
  addVec3: addVec3,
  addVec3Scalar: addVec3Scalar,
  subVec4: subVec4,
  compareVec3: compareVec3,
  subVec3: subVec3,
  subVec2: subVec2,
  geometricMeanVec2: geometricMeanVec2,
  subVec4Scalar: subVec4Scalar,
  subScalarVec4: subScalarVec4,
  mulVec4: mulVec4,
  divVec3: divVec3,
  divVec4: divVec4,
  divScalarVec3: divScalarVec3,
  divVec3Scalar: divVec3Scalar,
  divVec4Scalar: divVec4Scalar,
  divScalarVec4: divScalarVec4,
  dotVec4: dotVec4,
  cross3Vec4: cross3Vec4,
  cross3Vec3: cross3Vec3,
  sqLenVec4: sqLenVec4,
  lenVec4: lenVec4,
  dotVec2: dotVec2,
  sqLenVec3: sqLenVec3,
  sqLenVec2: sqLenVec2,
  lenVec3: lenVec3,
  distVec3: distVec3,
  lenVec2: lenVec2,
  lerpVec3: lerpVec3,
  distVec2: distVec2,
  rcpVec3: rcpVec3,
  normalizeVec4: normalizeVec4,
  normalizeVec3: normalizeVec3,
  normalizeVec2: normalizeVec2,
  angleVec3: angleVec3,
  vec3FromMat4Scale: vec3FromMat4Scale,
  vecToArray: vecToArray,
  triangleNormal: triangleNormal,
  createMat3: createMat3,
  mat3ToMat4: mat3ToMat4,
  createMat4: createMat4,
  compareMat4: compareMat4,
  perspectiveMat4: perspectiveMat4,
  frustumMat4v: frustumMat4v,
  orthoMat4c: orthoMat4c,
  frustumMat4: frustumMat4,
  identityMat4: identityMat4,
  identityMat3: identityMat3,
  isIdentityMat4: isIdentityMat4,
  rotationMat4v: rotationMat4v,
  lookAtMat4v: lookAtMat4v,
  inverseMat4: inverseMat4,
  transposeMat4: transposeMat4,
  mulMat4v4: mulMat4v4,
  mulMat4: mulMat4,
  mulMat3: mulMat3,
  transformPoint3: transformPoint3,
  transformPoint4: transformPoint4,
  transformPoints3: transformPoints3,
  transformPositions3: transformPositions3,
  transformPositions4: transformPositions4,
  transformVec3: transformVec3,
  transformVec4: transformVec4,
  scaleMat4v: scaleMat4v,
  scalingMat4v: scalingMat4v,
  scalingMat3v: scalingMat3v,
  scalingMat4c: scalingMat4c,
  scaleMat4c: scaleMat4c,
  scalingMat4s: scalingMat4s,
  composeMat4: composeMat4,
  decomposeMat4: decomposeMat4,
  translateMat4v: translateMat4v,
  translateMat4c: translateMat4c,
  setMat4Translation: setMat4Translation,
  translationMat4v: translationMat4v,
  translationMat3v: translationMat3v,
  translationMat4c: translationMat4c,
  translationMat4s: translationMat4s,
  determinantMat4: determinantMat4,
  mat4ToEuler: mat4ToEuler,
  lerpMat4: lerpMat4,
  identityQuat: identityQuat,
  eulerToQuat: eulerToQuat,
  mat4ToQuat: mat4ToQuat,
  vec3PairToQuat: vec3PairToQuat,
  angleAxisToQuaternion: angleAxisToQuaternion,
  quatToEuler: quatToEuler,
  mulQuats: mulQuats,
  vec3ApplyQuat: vec3ApplyQuat,
  quatToMat4: quatToMat4,
  quatToRotationMat4: quatToRotationMat4,
  normalizeQuat: normalizeQuat,
  conjugateQuat: conjugateQuat,
  inverseQuat: inverseQuat,
  quatToAngleAxis: quatToAngleAxis,
  rayTriangleIntersect: rayTriangleIntersect,
  transformRay: transformRay
};

var _items = /*#__PURE__*/_classPrivateFieldLooseKey("items");
var _lastUniqueId = /*#__PURE__*/_classPrivateFieldLooseKey("lastUniqueId");
/** @private */
var Map$1 = /*#__PURE__*/function () {
  function Map(items, baseId) {
    Object.defineProperty(this, _items, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _lastUniqueId, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _items)[_items] = items || [];
    _classPrivateFieldLooseBase(this, _lastUniqueId)[_lastUniqueId] = (baseId || 0) + 1;
  }
  /**
   * Usage:
   *
   * id = myMap.addItem("foo") // ID internally generated
   * id = myMap.addItem("foo", "bar") // ID is "foo"
   */
  var _proto = Map.prototype;
  _proto.addItem = function addItem() {
    var item;
    if (arguments.length === 2) {
      var id = arguments[0];
      item = arguments[1];
      if (_classPrivateFieldLooseBase(this, _items)[_items][id]) {
        // Won't happen if given ID is string
        throw "ID clash: '" + id + "'";
      }
      _classPrivateFieldLooseBase(this, _items)[_items][id] = item;
      return id;
    } else {
      item = arguments[0] || {};
      while (true) {
        var findId = _classPrivateFieldLooseBase(this, _lastUniqueId)[_lastUniqueId]++;
        if (!_classPrivateFieldLooseBase(this, _items)[_items][findId]) {
          _classPrivateFieldLooseBase(this, _items)[_items][findId] = item;
          return findId;
        }
      }
    }
  };
  _proto.removeItem = function removeItem(id) {
    var item = _classPrivateFieldLooseBase(this, _items)[_items][id];
    delete _classPrivateFieldLooseBase(this, _items)[_items][id];
    return item;
  };
  return Map;
}();

var Queue = /*#__PURE__*/function () {
  function Queue() {
    this._head = void 0;
    this._headLength = void 0;
    this._tail = void 0;
    this._index = void 0;
    this._length = void 0;
    this._head = [];
    this._headLength = 0;
    this._tail = [];
    this._index = 0;
    this._length = 0;
  }
  var _proto = Queue.prototype;
  _proto.shift = function shift() {
    if (this._index >= this._headLength) {
      var t = this._head;
      t.length = 0;
      this._head = this._tail;
      this._tail = t;
      this._index = 0;
      this._headLength = this._head.length;
      if (!this._headLength) {
        return;
      }
    }
    var value = this._head[this._index];
    if (this._index < 0) {
      delete this._head[this._index++];
    } else {
      this._head[this._index++] = undefined;
    }
    this._length--;
    return value;
  };
  _proto.push = function push(item) {
    this._length++;
    this._tail.push(item);
    return this;
  };
  _proto.unshift = function unshift(item) {
    this._head[--this._index] = item;
    this._length++;
    return this;
  };
  _proto.clear = function clear() {
    this._head = [];
    this._headLength = 0;
    this._tail = [];
    this._index = 0;
    this._length = 0;
  };
  _createClass(Queue, [{
    key: "length",
    get: function get() {
      return this._length;
    }
  }]);
  return Queue;
}();

var LoadingManager = /*#__PURE__*/function () {
  function LoadingManager(onLoad, onProgress, onError) {
    this.isLoading = void 0;
    this.itemsLoaded = void 0;
    this.itemsTotal = void 0;
    this.urlModifier = void 0;
    this.handlers = void 0;
    this.onStart = void 0;
    this.onLoad = void 0;
    this.onProgress = void 0;
    this.onError = void 0;
    this.isLoading = false;
    this.itemsLoaded = 0;
    this.itemsTotal = 0;
    this.urlModifier = undefined;
    this.handlers = [];
    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
  }
  var _proto = LoadingManager.prototype;
  _proto.itemStart = function itemStart(url) {
    this.itemsTotal++;
    if (!this.isLoading) {
      if (this.onStart !== undefined) {
        this.onStart(url, this.itemsLoaded, this.itemsTotal);
      }
    }
    this.isLoading = true;
  };
  _proto.itemEnd = function itemEnd(url) {
    this.itemsLoaded++;
    if (this.onProgress !== undefined) {
      this.onProgress(url, this.itemsLoaded, this.itemsTotal);
    }
    if (this.itemsLoaded === this.itemsTotal) {
      this.isLoading = false;
      if (this.onLoad !== undefined) {
        this.onLoad();
      }
    }
  };
  _proto.itemError = function itemError(url) {
    if (this.onError !== undefined) {
      this.onError(url);
    }
  };
  _proto.resolveURL = function resolveURL(url) {
    if (this.urlModifier) {
      // @ts-ignore
      return this.urlModifier(url);
    }
    return url;
  };
  _proto.setURLModifier = function setURLModifier(transform) {
    this.urlModifier = transform;
    return this;
  };
  _proto.addHandler = function addHandler(regex, loader) {
    this.handlers.push(regex, loader);
    return this;
  };
  _proto.removeHandler = function removeHandler(regex) {
    var index = this.handlers.indexOf(regex);
    if (index !== -1) {
      this.handlers.splice(index, 2);
    }
    return this;
  };
  _proto.getHandler = function getHandler(file) {
    for (var i = 0, l = this.handlers.length; i < l; i += 2) {
      var regex = this.handlers[i];
      var loader = this.handlers[i + 1];
      if (regex.global) regex.lastIndex = 0; // see #17920
      if (regex.test(file)) {
        return loader;
      }
    }
    return null;
  };
  return LoadingManager;
}(); // @ts-ignore
var DefaultLoadingManager = new LoadingManager();

var Loader = /*#__PURE__*/function () {
  function Loader(manager) {
    this.manager = void 0;
    this.crossOrigin = void 0;
    this.withCredentials = void 0;
    this.path = void 0;
    this.resourcePath = void 0;
    this.requestHeader = void 0;
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    this.crossOrigin = 'anonymous';
    this.withCredentials = false;
    this.path = '';
    this.resourcePath = '';
    this.requestHeader = {};
  }
  var _proto = Loader.prototype;
  _proto.load = function load(url, onLoad, onProgress, onError) {};
  _proto.loadAsync = function loadAsync(url, onProgress) {
    var scope = this;
    return new Promise(function (resolve, reject) {
      // @ts-ignore
      scope.load(url, resolve, onProgress, reject);
    });
  };
  _proto.parse = function parse( /* data */
  ) {};
  _proto.setCrossOrigin = function setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  };
  _proto.setWithCredentials = function setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  };
  _proto.setPath = function setPath(path) {
    this.path = path;
    return this;
  };
  _proto.setResourcePath = function setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  };
  _proto.setRequestHeader = function setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  };
  return Loader;
}();

/**
 * @author Deepkolos / https://github.com/deepkolos
 */
var WorkerPool = /*#__PURE__*/function () {
  function WorkerPool(pool) {
    if (pool === void 0) {
      pool = 4;
    }
    this.pool = void 0;
    this.queue = void 0;
    this.workers = void 0;
    this.workersResolve = void 0;
    this.workerStatus = void 0;
    this.workerCreator = void 0;
    this.pool = pool;
    this.queue = [];
    this.workers = [];
    this.workersResolve = [];
    this.workerStatus = 0;
  }
  var _proto = WorkerPool.prototype;
  _proto._initWorker = function _initWorker(workerId) {
    if (!this.workers[workerId]) {
      var worker = this.workerCreator();
      worker.addEventListener('message', this._onMessage.bind(this, workerId));
      this.workers[workerId] = worker;
    }
  };
  _proto._getIdleWorker = function _getIdleWorker() {
    for (var i = 0; i < this.pool; i++) if (!(this.workerStatus & 1 << i)) return i;
    return -1;
  };
  _proto._onMessage = function _onMessage(workerId, msg) {
    var resolve = this.workersResolve[workerId];
    resolve && resolve(msg);
    if (this.queue.length) {
      var _this$queue$shift = this.queue.shift(),
        _resolve = _this$queue$shift.resolve,
        _msg = _this$queue$shift.msg,
        transfer = _this$queue$shift.transfer;
      this.workersResolve[workerId] = _resolve;
      this.workers[workerId].postMessage(_msg, transfer);
    } else {
      this.workerStatus ^= 1 << workerId;
    }
  };
  _proto.setWorkerCreator = function setWorkerCreator(workerCreator) {
    this.workerCreator = workerCreator;
  };
  _proto.setWorkerLimit = function setWorkerLimit(pool) {
    this.pool = pool;
  };
  _proto.postMessage = function postMessage(msg, transfer) {
    var _this = this;
    return new Promise(function (resolve) {
      var workerId = _this._getIdleWorker();
      if (workerId !== -1) {
        _this._initWorker(workerId);
        _this.workerStatus |= 1 << workerId;
        _this.workersResolve[workerId] = resolve;
        _this.workers[workerId].postMessage(msg, transfer);
      } else {
        _this.queue.push({
          resolve: resolve,
          msg: msg,
          transfer: transfer
        });
      }
    });
  };
  _proto.destroy = function destroy() {
    this.workers.forEach(function (worker) {
      return worker.terminate();
    });
    this.workersResolve.length = 0;
    this.workers.length = 0;
    this.queue.length = 0;
    this.workerStatus = 0;
  };
  return WorkerPool;
}();

var Cache = {
  enabled: false,
  files: {},
  add: function add(key, file) {
    {
      return;
    }
  },
  get: function get(key) {
    {
      return;
    }
  },
  remove: function remove(key) {
  },
  clear: function clear() {
    this.files = {};
  }
};

var loading = {};
var FileLoader = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(FileLoader, _Loader);
  function FileLoader(manager) {
    var _this;
    _this = _Loader.call(this, manager) || this;
    _this.mimeType = void 0;
    _this.responseType = void 0;
    return _this;
  }
  var _proto = FileLoader.prototype;
  _proto.load = function load(url, onLoad, onProgress, onError) {
    var _this2 = this;
    if (url === undefined) {
      url = '';
    }
    if (this.path !== undefined) {
      url = this.path + url;
    }
    url = this.manager.resolveURL(url);
    var cached = Cache.get(url);
    if (cached !== undefined) {
      this.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) {
          onLoad(cached);
        }
        _this2.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== undefined) {
      loading[url].push({
        onLoad: onLoad,
        onProgress: onProgress,
        onError: onError
      });
      return;
    }
    loading[url] = [];
    loading[url].push({
      onLoad: onLoad,
      onProgress: onProgress,
      onError: onError
    });
    var req = new Request(url, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? 'include' : 'same-origin'
    });
    var mimeType = this.mimeType;
    var responseType = this.responseType;
    fetch(req).then(function (response) {
      if (response.status === 200 || response.status === 0) {
        // Some browsers return HTTP Status 0 when using non-http protocol
        // e.g. 'file://' or 'data://'. Handle as success.
        if (response.status === 0) {
          console.warn('FileLoader: HTTP Status 0 received.');
        }
        // @ts-ignore
        if (typeof ReadableStream === 'undefined' || response.body.getReader === undefined) {
          return response;
        }
        var callbacks = loading[url];
        // @ts-ignore
        var reader = response.body.getReader();
        var contentLength = response.headers.get('Content-Length');
        var total = contentLength ? parseInt(contentLength) : 0;
        var lengthComputable = total !== 0;
        var loaded = 0;
        var stream = new ReadableStream({
          start: function start(controller) {
            readData();
            function readData() {
              reader.read().then(function (_ref) {
                var done = _ref.done,
                  value = _ref.value;
                if (done) {
                  controller.close();
                } else {
                  // @ts-ignore
                  loaded += value.byteLength;
                  var event = new ProgressEvent('progress', {
                    lengthComputable: lengthComputable,
                    loaded: loaded,
                    total: total
                  });
                  for (var i = 0, il = callbacks.length; i < il; i++) {
                    var callback = callbacks[i];
                    if (callback.onProgress) {
                      callback.onProgress(event);
                    }
                  }
                  controller.enqueue(value);
                  readData();
                }
              });
            }
          }
        });
        return new Response(stream);
      } else {
        throw new Error("fetch for \"" + response.url + "\" responded with " + response.status + ": " + response.statusText);
      }
    }).then(function (response) {
      switch (responseType) {
        case 'arraybuffer':
          return response.arrayBuffer();
        case 'blob':
          return response.blob();
        case 'document':
          return response.text().then(function (text) {
            var parser = new DOMParser();
            // @ts-ignore
            return parser.parseFromString(text, mimeType);
          });
        case 'json':
          return response.json();
        default:
          if (mimeType === undefined) {
            return response.text();
          } else {
            // sniff encoding
            var re = /charset="?([^;"\s]*)"?/i;
            var exec = re.exec(mimeType);
            var label = exec && exec[1] ? exec[1].toLowerCase() : undefined;
            var decoder = new TextDecoder(label);
            return response.arrayBuffer().then(function (ab) {
              return decoder.decode(ab);
            });
          }
      }
    }).then(function (data) {
      // Add to cache only on HTTP success, so that we do not cache
      // error response bodies as proper responses to requests.
      Cache.add(url, data);
      var callbacks = loading[url];
      delete loading[url];
      for (var i = 0, il = callbacks.length; i < il; i++) {
        var callback = callbacks[i];
        if (callback.onLoad) {
          callback.onLoad(data);
        }
      }
    })["catch"](function (err) {
      // Abort errors and other errors are handled the same
      var callbacks = loading[url];
      if (callbacks === undefined) {
        // When onLoad was called and url was deleted in `loading`
        _this2.manager.itemError(url);
        throw err;
      }
      delete loading[url];
      for (var i = 0, il = callbacks.length; i < il; i++) {
        var callback = callbacks[i];
        if (callback.onError) {
          callback.onError(err);
        }
      }
      _this2.manager.itemError(url);
    })["finally"](function () {
      _this2.manager.itemEnd(url);
    });
    this.manager.itemStart(url);
  };
  _proto.setResponseType = function setResponseType(value) {
    this.responseType = value;
    return this;
  };
  _proto.setMimeType = function setMimeType(value) {
    this.mimeType = value;
    return this;
  };
  return FileLoader;
}(Loader);

/**
 * ## xeokit SDK Core Utilities Library
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/utils
 * ````
 *
 * @module @xeokit/utils
 */
/**
 *
 * @param ob
 */
function clone(ob) {
  return JSON.parse(JSON.stringify(ob));
}
var guidChars = [["0", 10], ["A", 26], ["a", 26], ["_", 1], ["$", 1]].map(function (a) {
  var li = [];
  // @ts-ignore
  var st = a[0].charCodeAt(0);
  var en = st + a[1];
  for (var i = st; i < en; ++i) {
    li.push(i);
  }
  return String.fromCharCode.apply(null, li);
}).join("");
/**
 *
 * @param v
 * @param len
 */
function b64(v, len) {
  var r = !len || len === 4 ? [0, 6, 12, 18] : [0, 6];
  return r.map(function (i) {
    return guidChars.substr(parseInt(String(v / (1 << i))) % 64, 1);
  }).reverse().join("");
}
/**
 *
 * @param g
 */
function compressGuid(g) {
  var bs = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30].map(function (i) {
    return parseInt(g.substr(i, 2), 16);
  });
  return b64(bs[0], 2) + [1, 4, 7, 10, 13].map(function (i) {
    return b64((bs[i] << 16) + (bs[i + 1] << 8) + bs[i + 2], 4);
  }).join("");
}
/**
 *
 * @param m
 * @param t
 */
function findNodeOfType(m, t) {
  var li = [];
  var _ = function _(n) {
    if (n.type === t) li.push(n);
    (n.children || []).forEach(function (c) {
      _(c);
    });
  };
  _(m);
  return li;
}
/**
 */
function timeout(dt) {
  return new Promise(function (resolve, reject) {
    setTimeout(resolve, dt);
  });
}
function httpRequest(args) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.open(args.method || "GET", args.url, true);
    xhr.onload = function (e) {
      console.log(args.url, xhr.readyState, xhr.status);
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          resolve(xhr.responseXML);
        } else {
          reject(xhr.statusText);
        }
      }
    };
    xhr.send(null);
  });
}
//
// export const queryString = function () {
//     // This function is anonymous, is executed immediately and
//     // the return value is assigned to QueryString!
//     const query_string = {};
//     const query = window.location.search.substring(1);
//     const vars = query.split("&");
//     for (let i = 0; i < vars.length; i++) {
//         const pair = vars[i].split("=");
//         // If first entry with this name
//         // @ts-ignore
//         if (typeof query_string[pair[0]] === "undefined") {
//             // @ts-ignore
//             query_string[pair[0]] = decodeURIComponent(pair[1]);
//             // If second entry with this name
//         } else { // @ts-ignore
//             if (typeof query_string[pair[0]] === "string") {
//                 // @ts-ignore
//                 query_string[pair[0]] = [query_string[pair[0]], decodeURIComponent(pair[1])];
//                 // If third or later entry with this name
//             } else {
//                 // @ts-ignore
//                 query_string[pair[0]].push(decodeURIComponent(pair[1]));
//             }
//         }
//     }
//     return query_string;
// }();
function loadJSON(url, ok, err) {
  // Avoid checking ok and err on each use.
  // @ts-ignore
  var defaultCallback = function defaultCallback(_value) {
    return undefined;
  };
  ok = ok || defaultCallback;
  err = err || defaultCallback;
  var request = new XMLHttpRequest();
  request.overrideMimeType("application/json");
  request.open('GET', url, true);
  request.addEventListener('load', function (event) {
    // @ts-ignore
    var response = event.target.response;
    if (this.status === 200) {
      var json;
      try {
        json = JSON.parse(response);
      } catch (e) {
        err("utils.loadJSON(): Failed to parse JSON response - " + e);
      }
      ok(json);
    } else if (this.status === 0) {
      // Some browsers return HTTP Status 0 when using non-http protocol
      // e.g. 'file://' or 'data://'. Handle as success.
      console.warn('loadFile: HTTP Status 0 received.');
      try {
        ok(JSON.parse(response));
      } catch (e) {
        err("utils.loadJSON(): Failed to parse JSON response - " + e);
      }
    } else {
      err(event);
    }
  }, false);
  request.addEventListener('error', function (event) {
    err(event);
  }, false);
  request.send(null);
}
function loadArraybuffer(url, ok, err) {
  // Check for data: URI
  // @ts-ignore
  var defaultCallback = function defaultCallback(_value) {
    return undefined;
  };
  ok = ok || defaultCallback;
  err = err || defaultCallback;
  var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
  var dataUriRegexResult = url.match(dataUriRegex);
  if (dataUriRegexResult) {
    // Safari can't handle data URIs through XMLHttpRequest
    var isBase64 = !!dataUriRegexResult[2];
    var data = dataUriRegexResult[3];
    data = window.decodeURIComponent(data);
    if (isBase64) {
      data = window.atob(data);
    }
    try {
      var buffer = new ArrayBuffer(data.length);
      var view = new Uint8Array(buffer);
      for (var i = 0; i < data.length; i++) {
        view[i] = data.charCodeAt(i);
      }
      window.setTimeout(function () {
        ok(buffer);
      }, 0);
    } catch (error) {
      window.setTimeout(function () {
        err(error);
      }, 0);
    }
  } else {
    var request = new XMLHttpRequest();
    request.open('GET', url, true);
    request.responseType = 'arraybuffer';
    request.onreadystatechange = function () {
      if (request.readyState === 4) {
        if (request.status === 200) {
          ok(request.response);
        } else {
          err('loadArrayBuffer error : ' + request.response);
        }
      }
    };
    request.send(null);
  }
}
/**
 Tests if the given object is an array
 */
function isArray(value) {
  return value && !value.propertyIsEnumerable('length') && typeof value === 'object' && typeof value.length === 'number';
}
/**
 Tests if the given value is a string
 */
function isString(value) {
  return typeof value === 'string' || value instanceof String;
}
/**
 Tests if the given value is a number
 */
function isNumeric(value) {
  return !isNaN(parseFloat(value)) && isFinite(value);
}
/**
 Tests if the given value is an ID
 */
function isID(value) {
  return isString(value) || isNumeric(value);
}
/**
 Tests if the given value is a function
 */
function isFunction(value) {
  return typeof value === "function";
}
/**
 Tests if the given value is a JavaScript JSON object, eg, ````{ foo: "bar" }````.
 */
function isObject(value) {
  var objectConstructor = {}.constructor;
  return !!value && value.constructor === objectConstructor;
}
/** Returns a shallow copy
 */
function copy(o) {
  return apply(o, {});
}
/** Add properties of o to o2, overwriting them on o2 if already there
 */
function apply(o, o2) {
  for (var name in o) {
    if (o.hasOwnProperty(name)) {
      o2[name] = o[name];
    }
  }
  return o2;
}
/**
 Add non-null/defined properties of o to o2
 */
function apply2(o, o2) {
  for (var name in o) {
    if (o.hasOwnProperty(name)) {
      if (o[name] !== undefined && o[name] !== null) {
        o2[name] = o[name];
      }
    }
  }
  return o2;
}
/**
 Add properties of o to o2 where undefined or null on o2
 */
function applyIf(o, o2) {
  for (var name in o) {
    if (o.hasOwnProperty(name)) {
      if (o2[name] === undefined || o2[name] === null) {
        o2[name] = o[name];
      }
    }
  }
  return o2;
}
/**
 Returns true if the given map is empty.
 */
function isEmptyObject(obj) {
  for (var name in obj) {
    if (obj.hasOwnProperty(name)) {
      return false;
    }
  }
  return true;
}
/**
 Returns the given ID as a string, in quotes if the ID was a string to begin with.
 This is useful for logging IDs.
 */
function inQuotes(id) {
  return isNumeric(id) ? "" + id : "'" + id + "'";
}
/**
 Returns the concatenation of two typed arrays.
 */
function concat(a, b) {
  var c = new a.constructor(a.length + b.length);
  c.set(a);
  c.set(b, a.length);
  return c;
}
/**
 * Returns a new UUID.
 */
var createUUID = function () {
  var lut = [];
  for (var i = 0; i < 256; i++) {
    lut[i] = (i < 16 ? '0' : '') + i.toString(16);
  }
  return function () {
    var d0 = Math.random() * 0xffffffff | 0;
    var d1 = Math.random() * 0xffffffff | 0;
    var d2 = Math.random() * 0xffffffff | 0;
    var d3 = Math.random() * 0xffffffff | 0;
    return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + "-" + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + "-" + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + "-" + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + "-" + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
  };
}();

var index$i = {
  __proto__: null,
  clone: clone,
  b64: b64,
  compressGuid: compressGuid,
  findNodeOfType: findNodeOfType,
  timeout: timeout,
  httpRequest: httpRequest,
  loadJSON: loadJSON,
  loadArraybuffer: loadArraybuffer,
  isArray: isArray,
  isString: isString,
  isNumeric: isNumeric,
  isID: isID,
  isFunction: isFunction,
  isObject: isObject,
  copy: copy,
  apply: apply,
  apply2: apply2,
  applyIf: applyIf,
  isEmptyObject: isEmptyObject,
  inQuotes: inQuotes,
  concat: concat,
  createUUID: createUUID,
  Map: Map$1,
  Queue: Queue,
  Loader: Loader,
  DefaultLoadingManager: DefaultLoadingManager,
  LoadingManager: LoadingManager,
  WorkerPool: WorkerPool,
  Cache: Cache,
  FileLoader: FileLoader
};

/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2Fcompression.svg)](https://badge.fury.io/js/%40xeokit%2Fcompression)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/compression/badge)](https://www.jsdelivr.com/package/npm/@xeokit/compression)
 *
 * <img style="padding:20px" src="media://images/geometry_icon.png"/>
 *
 * # xeokit Geometry Compression / Decompression Utilities
 *
 * ---
 *
 * ### *Tools for geometry compression and decompression*
 *
 * ---
 *
 * The xeokit Geometry Compression/Decompression Utilities library provides functions used internally within
 * {@link @xeokit/scene!SceneModel.createGeometry | SceneModel.createGeometry} implementations to compress geometry. These functions are also
 * provided for users who want to pre-compress their geometry "offline" and then
 * use {@link @xeokit/scene!SceneModel.createGeometryCompressed | SceneModel.createGeometryCompressed}
 * to create compressed geometry directly.
 *
 * The compression techniques used include simplifying geometry by combining duplicate positions and adjusting indices, generating edge
 * indices for triangle meshes, ignoring normals (as shaders auto-generate them), converting positions to relative-to-center (RTC)
 * coordinates, quantizing positions and UVs as 16-bit unsigned integers, and splitting geometry into buckets to enable indices to use
 * the minimum bits for storage. The bucketing technique was developed for xeokit by Toni Marti with support from Tribia AG.
 *
 * An example usage includes compressing a GeometryParams into a {@link @xeokit/scene!GeometryCompressedParams} using the
 * {@link @xeokit/scene!compressGeometryParams} function. In this example, the geometry is simple, and only one bucket is
 * needed. However, if the positions array was large enough to require some indices to use more than 16 bits for storage, the
 * bucketing mechanism would split the geometry into smaller buckets, each with smaller indices that index a subset of the
 * positions.
 *
 * The resulting GeometryCompressedParams object shows that we have one bucket with vertex positions relative to the origin
 * and quantized to 16-bit integers, duplicate positions removed, and adjusted indices. Additionally, edge indices are
 * generated for the {@link @xeokit/constants!TrianglesPrimitive}, and a positionsDecompressMatrix is included to de-quantize
 * the positions within the Viewer.
 *
 * This library provides a set of functions that are used internally within
 * {@link @xeokit/scene!SceneModel.createGeometry | SceneModel.createGeometry} implementations to
 * compress geometry. The functions are provided here in case users instead want to pre-compress their geometry "offline",
 * and then use {@link @xeokit/scene!SceneModel.createGeometryCompressed | SceneModel.createGeometryCompressed}
 * to create the compressed geometry directly.
 *
 * ### Compression Techniques Used
 *
 * * Simplifies geometry by combining duplicate positions and adjusting indices
 * * Generates edge indices for triangle meshes
 * * Ignores normals (our shaders auto-generate them)
 * * Converts positions to relative-to-center (RTC) coordinates
 * * Quantizes positions and UVs as 16-bit unsigned integers
 * * Splits geometry into {@link @xeokit/scene!GeometryBucketParams | buckets } to enable indices to use the minimum bits for storage
 *
 * ### Aknowledgements
 *
 * * The bucketing technique mentioned above was developed for xeokit by Toni Marti, with support from Tribia AG. Read [the slides](media://pdfs/GPU_RAM_Savings_Toni_Marti_Apr22.pdf) from Toni's presentation at WebGL Meetup 2022.
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/compression
 * ````
 *
 * ## Usage
 *
 * In the example below, we'll use {@link @xeokit/scene!compressGeometryParams} to compress
 * a {@link @xeokit/scene!GeometryParams | GeometryParams} into a
 * {@link @xeokit/scene!GeometryCompressedParams | GeometryCompressedParams}.
 *
 * In this example, our geometry is very simple, and our GeometryCompressedParams only gets a single
 * {@link @xeokit/scene!GeometryBucketParams | GeometryBucketParams }. Note that if the
 * {@link @xeokit/scene!GeometryParams.positions | GeometryParams.positions} array was large enough to require
 * some of the indices to use more than 16 bits for storage, then that's when the function's bucketing mechanism would
 * kick in, to split the geometry into smaller buckets, each with smaller indices that index a subset of the positions.
 *
 * ````javascript
 * import {compressGeometryParams} from "@xeokit/compression";
 * import {TrianglesPrimitive} from "@xeokit/constants";
 *
 * const geometryCompressedParams = compressGeometryParams({
 *      id: "myBoxGeometry",
 *      primitive: TrianglesPrimitive,
 *      positions: [
 *          202, 202, 202, 200, 202, 202,
 *          200, 200, 202, 202, 200, 202,
 *          202, 202, 202, 202, 200, 202,
 *          202, 200, 200, 202, 202, 200,
 *          202, 202, 202, 202, 202, 200,
 *          200, 202, 200, 200, 202, 202,
 *          200, 202, 202, 200, 202, 200,
 *          200, 200, 200, 200, 200, 202,
 *          200, 200, 200, 202, 200, 200,
 *          202, 200, 202, 200, 200, 202,
 *          202, 200, 200, 200, 200, 200,
 *          200, 202, 200, 202, 202, 200
 *      ],
 *      indices: [
 *          0, 1, 2, 0, 2, 3, 4, 5, 6, 4,
 *          6, 7, 8, 9, 10, 8, 10, 11, 12,
 *          13, 14, 12, 14, 15, 16, 17, 18,
 *          16, 18, 19, 20, 21, 22, 20, 22, 23
 *      ]
 *  });
 * ````
 *
 * The value of our new {@link @xeokit/scene!GeometryCompressedParams | GeometryCompressedParams} is shown below.
 *
 * We can see that:
 *
 * * We get one bucket, because we have only a small number of indices
 * * Vertex positions are now relative to ````origin```` and quantized to 16-bit integers
 * * Duplicate positions are removed and indices adjusted
 * * Edge indices generated for our TrianglesPrimitive
 * * A ````positionsDecompressMatrix```` to de-quantize the positions within the Viewer
 *
 * ````javascript
 * {
 *      id: "myBoxGeometry",
 *      primitive: TrianglesPrimitive,
 *      origin: [200,200,200],
 *      positionsDecompressMatrix: [
 *          0.00003052270125906143, 0, 0, 0,
 *          0, 0.00003052270125906143, 0, 0,
 *          0, 0, 0.00003052270125906143, 0,
 *          -1, -1, -1, 1
 *      ],
 *      geometryBuckets: [
 *          {
 *              positionsCompressed: [
 *                  65525, 65525, 65525, 0, 65525, 65525,
 *                  0, 0, 65525, 65525, 0, 65525, 65525,
 *                  0, 0, 65525, 65525, 0, 0, 65525, 0, 0,
 *                  0, 0
 *              ],
 *              indices: [
 *                  0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 5, 0, 5, 6,
 *                  0, 6, 1, 1, 6, 7, 1, 7, 2, 7, 4, 3, 7, 3, 2,
 *                  4, 7, 6, 4, 6, 5
 *              ],
 *              edgeIndices: [
 *                  3, 4, 0, 4, 5, 0, 5, 6,
 *                  0, 6, 1, 1, 6, 7, 1, 7,
 *                  3, 2, 4, 7, 6, 4, 6
 *              ]
 *          }
 *      ]
 * }
 * ````
 *
 * In the next example, we'll again use {@link @xeokit/scene!compressGeometryParams} to compress
 * a {@link @xeokit/scene!GeometryParams | GeometryParams} into a
 * {@link @xeokit/scene!GeometryCompressedParams | GeometryCompressedParams}, which we'll then use to
 * create a compressed geometry within a {@link @xeokit/scene!SceneModel | SceneModel}.
 *
 * ````javascript
 * import {Scene} from "@xeokit/scene";
 * import {TrianglesPrimitive} from "@xeokit/constants";
 * import {compressGeometryParams} from "@xeokit/compression";
 *
 * const scene = new Scene();
 *
 * const sceneModel = scene.createModel({
 *     id: "myModel"
 * });
 *
 * const geometryCompressedParams = compressGeometryParams({
 *      id: "myBoxGeometry",
 *      primitive: TrianglesPrimitive,
 *      positions: [202, 202, 202, 200, 202, 202, ...],
 *      indices: [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, ...]
 * });
 *
 * sceneModel.createGeometryCompressed(geometryCompressedParams);
 *
 * sceneModel.createMesh({ id: "myMesh", geometryId: "myGeometry" });
 *
 * sceneModel.createObject({ id: "myObject1", meshIds: ["myMesh"] });
 * sceneModel.createObject({ id: "myObject2", meshIds: ["myMesh"] });
 *
 * sceneModel.build();
 * ````
 *
 * @module @xeokit/compression
 */
var translate = createMat4();
var scale = createMat4();
/**
 * Gets the boundary of a flat positions array.
 *
 * @param array
 * @param min
 * @param max
 */
function getPositions3MinMax(array, min, max) {
  var i, j;
  min = min || new Float64Array(3);
  max = max || new Float64Array(3);
  for (i = 0; i < 3; i++) {
    min[i] = Number.MAX_VALUE;
    max[i] = -Number.MAX_VALUE;
  }
  for (i = 0; i < array.length; i += 3) {
    for (j = 0; j < 3; j++) {
      min[j] = Math.min(min[j], array[i + j]);
      max[j] = Math.max(max[j], array[i + j]);
    }
  }
  return {
    min: min,
    max: max
  };
}
/**
 * Creates a de-quantization matrix from a boundary.
 */
function createPositions3DecompressMat4(aabb, positionsDecompressMatrix) {
  positionsDecompressMatrix = positionsDecompressMatrix || createMat4();
  var xmin = aabb[0];
  var ymin = aabb[1];
  var zmin = aabb[2];
  var xwid = aabb[3] - xmin;
  var ywid = aabb[4] - ymin;
  var zwid = aabb[5] - zmin;
  var maxInt = 65535;
  identityMat4(translate);
  translationMat4v(aabb, translate);
  identityMat4(scale);
  scalingMat4v([xwid / maxInt, ywid / maxInt, zwid / maxInt], scale);
  mulMat4(translate, scale, positionsDecompressMatrix);
  return positionsDecompressMatrix;
}
/**
 * Compresses a flat positions array
 */
function compressPositions3(array, min, max) {
  var quantized = new Uint16Array(array.length);
  var multiplier = new Float32Array([max[0] !== min[0] ? 65535 / (max[0] - min[0]) : 0, max[1] !== min[1] ? 65535 / (max[1] - min[1]) : 0, max[2] !== min[2] ? 65535 / (max[2] - min[2]) : 0]);
  var i;
  for (i = 0; i < array.length; i += 3) {
    quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);
    quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);
    quantized[i + 2] = Math.floor((array[i + 2] - min[2]) * multiplier[2]);
  }
  identityMat4(translate);
  translationMat4v(min, translate);
  identityMat4(scale);
  scalingMat4v([(max[0] - min[0]) / 65535, (max[1] - min[1]) / 65535, (max[2] - min[2]) / 65535], scale);
  var decompressMatrix = mulMat4(translate, scale, identityMat4());
  return {
    quantized: quantized,
    decompressMatrix: decompressMatrix
  };
}
/**
 * Compresses a 3D position
 * @param p
 * @param aabb
 * @param q
 */
function compressPoint3(p, aabb, dest) {
  if (dest === void 0) {
    dest = p;
  }
  var multiplier = new Float32Array([aabb[3] !== aabb[0] ? 65535 / (aabb[3] - aabb[0]) : 0, aabb[4] !== aabb[1] ? 65535 / (aabb[4] - aabb[1]) : 0, aabb[5] !== aabb[2] ? 65535 / (aabb[5] - aabb[2]) : 0]);
  dest[0] = Math.max(0, Math.min(65535, Math.floor((p[0] - aabb[0]) * multiplier[0])));
  dest[1] = Math.max(0, Math.min(65535, Math.floor((p[1] - aabb[1]) * multiplier[1])));
  dest[2] = Math.max(0, Math.min(65535, Math.floor((p[2] - aabb[2]) * multiplier[2])));
  return dest;
}
/**
 * Decompresses a 3D position
 * @param position
 * @param decompressMatrix
 * @param dest
 */
function decompressPoint3(position, decompressMatrix, dest) {
  if (dest === void 0) {
    dest = position;
  }
  dest[0] = position[0] * decompressMatrix[0] + decompressMatrix[12];
  dest[1] = position[1] * decompressMatrix[5] + decompressMatrix[13];
  dest[2] = position[2] * decompressMatrix[10] + decompressMatrix[14];
  return dest;
}
/**
 * Decompresses an axis-aligned 3D boundary
 * @param aabb
 * @param decompressMatrix
 * @param dest
 */
function decompressAABB3(aabb, decompressMatrix, dest) {
  if (dest === void 0) {
    dest = aabb;
  }
  dest[0] = aabb[0] * decompressMatrix[0] + decompressMatrix[12];
  dest[1] = aabb[1] * decompressMatrix[5] + decompressMatrix[13];
  dest[2] = aabb[2] * decompressMatrix[10] + decompressMatrix[14];
  dest[3] = aabb[3] * decompressMatrix[0] + decompressMatrix[12];
  dest[4] = aabb[4] * decompressMatrix[5] + decompressMatrix[13];
  dest[5] = aabb[5] * decompressMatrix[10] + decompressMatrix[14];
  return dest;
}
/**
 * Decompresses a flat array of positions
 * @param positions
 * @param decompressMatrix
 * @param dest
 */
function decompressPositions3(positions, decompressMatrix, dest) {
  if (dest === void 0) {
    dest = new Float32Array(positions.length);
  }
  for (var i = 0, len = positions.length; i < len; i += 3) {
    dest[i + 0] = positions[i + 0] * decompressMatrix[0] + decompressMatrix[12];
    dest[i + 1] = positions[i + 1] * decompressMatrix[5] + decompressMatrix[13];
    dest[i + 2] = positions[i + 2] * decompressMatrix[10] + decompressMatrix[14];
  }
  return dest;
}
/**
 * Gets the 2D min/max boundary of a flat array of UV coordinate
 * @param array
 */
function getUVBounds(array) {
  var min = new Float32Array(2);
  var max = new Float32Array(2);
  var i, j;
  for (i = 0; i < 2; i++) {
    min[i] = Number.MAX_VALUE;
    max[i] = -Number.MAX_VALUE;
  }
  for (i = 0; i < array.length; i += 2) {
    for (j = 0; j < 2; j++) {
      min[j] = Math.min(min[j], array[i + j]);
      max[j] = Math.max(max[j], array[i + j]);
    }
  }
  return {
    min: min,
    max: max
  };
}
/**
 * Compresses a flat array of UV coordinates
 */
var compressUVs = function () {
  var translate = createMat3();
  var scale = createMat3();
  return function (array, min, max) {
    var quantized = new Uint16Array(array.length);
    var multiplier = new Float32Array([65535 / (max[0] - min[0]), 65535 / (max[1] - min[1])]);
    var i;
    for (i = 0; i < array.length; i += 2) {
      quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);
      quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);
    }
    identityMat3(translate);
    translationMat3v(min, translate);
    identityMat3(scale);
    scalingMat3v([(max[0] - min[0]) / 65535, (max[1] - min[1]) / 65535], scale);
    var decompressMatrix = mulMat3(translate, scale, identityMat3());
    return {
      quantized: quantized,
      decompressMatrix: decompressMatrix
    };
  };
}();
/**
 * Oct-encodes a flat array of normal vectors
 * @param array
 */
function compressNormals(array) {
  // Note: three elements for each encoded normal, in which the last element in each triplet is redundant.
  // This is to work around a mysterious WebGL issue where 2-element normals just wouldn't work in the shader :/
  var encoded = new Int8Array(array.length);
  var oct, dec, best, currentCos, bestCos;
  for (var i = 0; i < array.length; i += 3) {
    // Test various combinations of ceil and floor
    // to minimize rounding errors
    best = oct = octEncodeNormalFromArray(array, i, "floor", "floor");
    dec = octDecodeVec2(oct);
    currentCos = bestCos = dot(array, i, dec);
    oct = octEncodeNormalFromArray(array, i, "ceil", "floor");
    dec = octDecodeVec2(oct);
    currentCos = dot(array, i, dec);
    if (currentCos > bestCos) {
      best = oct;
      bestCos = currentCos;
    }
    oct = octEncodeNormalFromArray(array, i, "floor", "ceil");
    dec = octDecodeVec2(oct);
    currentCos = dot(array, i, dec);
    if (currentCos > bestCos) {
      best = oct;
      bestCos = currentCos;
    }
    oct = octEncodeNormalFromArray(array, i, "ceil", "ceil");
    dec = octDecodeVec2(oct);
    currentCos = dot(array, i, dec);
    if (currentCos > bestCos) {
      best = oct;
      bestCos = currentCos;
    }
    encoded[i] = best[0];
    encoded[i + 1] = best[1];
  }
  return encoded;
}
/**
 */
function octEncodeNormalFromArray(array, i, xfunc, yfunc) {
  var x = array[i] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));
  var y = array[i + 1] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));
  if (array[i + 2] < 0) {
    var tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
    var tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
    x = tempx;
    y = tempy;
  }
  // @ts-ignore
  return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))]);
}
/**
 * Dot product of a normal in an array against a candidate decoding
 */
function dot(array, i, createVec3) {
  return array[i] * createVec3[0] + array[i + 1] * createVec3[1] + array[i + 2] * createVec3[2];
}
/**
 */
function decompressUV(uv, decompressMatrix, dest) {
  if (dest === void 0) {
    dest = new Float32Array(2);
  }
  dest[0] = uv[0] * decompressMatrix[0] + decompressMatrix[6];
  dest[1] = uv[1] * decompressMatrix[4] + decompressMatrix[7];
}
/**
 *
 */
function decompressUVs(uvs, decompressMatrix, dest) {
  if (dest === void 0) {
    dest = new Float32Array(uvs.length);
  }
  for (var i = 0, len = uvs.length; i < len; i += 3) {
    dest[i + 0] = uvs[i + 0] * decompressMatrix[0] + decompressMatrix[6];
    dest[i + 1] = uvs[i + 1] * decompressMatrix[4] + decompressMatrix[7];
  }
  return dest;
}
/**
 *
 */
function decompressNormal(oct, result) {
  var x = oct[0];
  var y = oct[1];
  x = (2 * x + 1) / 255;
  y = (2 * y + 1) / 255;
  var z = 1 - Math.abs(x) - Math.abs(y);
  if (z < 0) {
    x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
    y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
  }
  var length = Math.sqrt(x * x + y * y + z * z);
  result[0] = x / length;
  result[1] = y / length;
  result[2] = z / length;
  return result;
}
/**
 *
 */
function decompressNormals(octs, result) {
  for (var i = 0, j = 0, len = octs.length; i < len; i += 2) {
    var x = octs[i + 0];
    var y = octs[i + 1];
    x = (2 * x + 1) / 255;
    y = (2 * y + 1) / 255;
    var z = 1 - Math.abs(x) - Math.abs(y);
    if (z < 0) {
      x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
      y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
    }
    var length = Math.sqrt(x * x + y * y + z * z);
    result[j + 0] = x / length;
    result[j + 1] = y / length;
    result[j + 2] = z / length;
    j += 3;
  }
  return result;
}
/**
 *
 * @param oct
 * @param result
 */
function octDecodeVec2(oct, result) {
  if (result === void 0) {
    result = createVec3();
  }
  var x = oct[0];
  var y = oct[1];
  x = (2 * x + 1) / 255;
  y = (2 * y + 1) / 255;
  var z = 1 - Math.abs(x) - Math.abs(y);
  if (z < 0) {
    x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
    y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
  }
  var length = Math.sqrt(x * x + y * y + z * z);
  result[0] = x / length;
  result[1] = y / length;
  result[2] = z / length;
  return result;
}
/**
 * @private
 */
function quantizePositions3(positions, aabb, positionsDecompressMatrix) {
  var lenPositions = positions.length;
  var positionsCompressed = new Uint16Array(lenPositions);
  var xmin = aabb[0];
  var ymin = aabb[1];
  var zmin = aabb[2];
  var xwid = aabb[3] - xmin;
  var ywid = aabb[4] - ymin;
  var zwid = aabb[5] - zmin;
  var maxInt = 65525;
  var xMultiplier = maxInt / xwid;
  var yMultiplier = maxInt / ywid;
  var zMultiplier = maxInt / zwid;
  var verify = function verify(num) {
    return num >= 0 ? num : 0;
  };
  for (var i = 0; i < lenPositions; i += 3) {
    positionsCompressed[i + 0] = Math.floor(verify(positions[i + 0] - xmin) * xMultiplier);
    positionsCompressed[i + 1] = Math.floor(verify(positions[i + 1] - ymin) * yMultiplier);
    positionsCompressed[i + 2] = Math.floor(verify(positions[i + 2] - zmin) * zMultiplier);
  }
  identityMat4(translate);
  translationMat4v(aabb, translate);
  identityMat4(scale);
  scalingMat4v([xwid / maxInt, ywid / maxInt, zwid / maxInt], scale);
  mulMat4(translate, scale, positionsDecompressMatrix);
  return positionsCompressed;
}
/**
 * @private
 */
function transformAndOctEncodeNormals(worldNormalMatrix, normals, lenNormals, compressedNormals, lenCompressedNormals) {
  function dot(p, createVec3) {
    return p[0] * createVec3[0] + p[1] * createVec3[1] + p[2] * createVec3[2];
  }
  // http://jcgt.org/published/0003/02/01/
  var oct, dec, best, currentCos, bestCos;
  var i;
  var localNormal = new Float32Array([0, 0, 0, 0]);
  var worldNormal = new Float32Array([0, 0, 0, 0]);
  for (i = 0; i < lenNormals; i += 3) {
    localNormal[0] = normals[i];
    localNormal[1] = normals[i + 1];
    localNormal[2] = normals[i + 2];
    transformVec3(worldNormalMatrix, localNormal, worldNormal);
    normalizeVec3(worldNormal, worldNormal);
    // Test various combinations of ceil and floor to minimize rounding errors
    best = oct = octEncodeVec3(worldNormal, "floor", "floor");
    dec = octDecodeVec2(oct);
    currentCos = bestCos = dot(worldNormal, dec);
    oct = octEncodeVec3(worldNormal, "ceil", "floor");
    dec = octDecodeVec2(oct);
    currentCos = dot(worldNormal, dec);
    if (currentCos > bestCos) {
      best = oct;
      bestCos = currentCos;
    }
    oct = octEncodeVec3(worldNormal, "floor", "ceil");
    dec = octDecodeVec2(oct);
    currentCos = dot(worldNormal, dec);
    if (currentCos > bestCos) {
      best = oct;
      bestCos = currentCos;
    }
    oct = octEncodeVec3(worldNormal, "ceil", "ceil");
    dec = octDecodeVec2(oct);
    currentCos = dot(worldNormal, dec);
    if (currentCos > bestCos) {
      best = oct;
      bestCos = currentCos;
    }
    compressedNormals[lenCompressedNormals + i + 0] = best[0];
    compressedNormals[lenCompressedNormals + i + 1] = best[1];
    compressedNormals[lenCompressedNormals + i + 2] = 0.0; // Unused
  }

  lenCompressedNormals += lenNormals;
  return lenCompressedNormals;
}
/**
 * @private
 */
function octEncodeNormals(normals) {
  var lenNormals = normals.length;
  var compressedNormals = new Int8Array(lenNormals);
  var oct, dec, best, currentCos, bestCos;
  for (var i = 0; i < lenNormals; i += 3) {
    // Test various combinations of ceil and floor to minimize rounding errors
    best = oct = octEncodeNormal(normals, i, "floor", "floor");
    dec = octDecodeVec2(oct);
    currentCos = bestCos = dot(normals, i, dec);
    oct = octEncodeNormal(normals, i, "ceil", "floor");
    dec = octDecodeVec2(oct);
    currentCos = dot(normals, i, dec);
    if (currentCos > bestCos) {
      best = oct;
      bestCos = currentCos;
    }
    oct = octEncodeNormal(normals, i, "floor", "ceil");
    dec = octDecodeVec2(oct);
    currentCos = dot(normals, i, dec);
    if (currentCos > bestCos) {
      best = oct;
      bestCos = currentCos;
    }
    oct = octEncodeNormal(normals, i, "ceil", "ceil");
    dec = octDecodeVec2(oct);
    currentCos = dot(normals, i, dec);
    if (currentCos > bestCos) {
      best = oct;
      bestCos = currentCos;
    }
    compressedNormals[i + 0] = best[0];
    compressedNormals[i + 1] = best[1];
    compressedNormals[i + 2] = 0.0; // Unused
  }

  return compressedNormals;
}
/**
 * @private
 */
function octEncodeVec3(p, xfunc, yfunc) {
  var x = p[0] / (Math.abs(p[0]) + Math.abs(p[1]) + Math.abs(p[2]));
  var y = p[1] / (Math.abs(p[0]) + Math.abs(p[1]) + Math.abs(p[2]));
  if (p[2] < 0) {
    var tempx = x;
    var tempy = y;
    tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
    tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
    x = tempx;
    y = tempy;
  }
  // @ts-ignore
  return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))]);
}
/**
 * @private
 */
function octEncodeNormal(array, i, xfunc, yfunc) {
  var x = array[i] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));
  var y = array[i + 1] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));
  if (array[i + 2] < 0) {
    var tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
    var tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
    x = tempx;
    y = tempy;
  }
  // @ts-ignore
  return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))]);
}

var index$h = {
  __proto__: null,
  getPositions3MinMax: getPositions3MinMax,
  createPositions3DecompressMat4: createPositions3DecompressMat4,
  compressPositions3: compressPositions3,
  compressPoint3: compressPoint3,
  decompressPoint3: decompressPoint3,
  decompressAABB3: decompressAABB3,
  decompressPositions3: decompressPositions3,
  getUVBounds: getUVBounds,
  compressUVs: compressUVs,
  compressNormals: compressNormals,
  decompressUV: decompressUV,
  decompressUVs: decompressUVs,
  decompressNormal: decompressNormal,
  decompressNormals: decompressNormals,
  quantizePositions3: quantizePositions3,
  transformAndOctEncodeNormals: transformAndOctEncodeNormals,
  octEncodeNormals: octEncodeNormals,
  octEncodeVec3: octEncodeVec3,
  octEncodeNormal: octEncodeNormal
};

var tempVec3a$5 = createVec3();
var tempVec3b$5 = createVec3();
var tempMat4a = createMat4();
/**
 * Returns a new, uninitialized 3D axis-aligned bounding box.
 */
function createAABB3(values) {
  // @ts-ignore
  return new Float64Array(values || 6);
}
/**
 * Returns a new, uninitialized 3D axis-aligned bounding box.
 */
function createAABB3Int16(values) {
  // @ts-ignore
  return new Int16Array(values || 6);
}
/**
 * Returns a new, uninitialized 2D axis-aligned bounding box.
 */
function createAABB2(values) {
  // @ts-ignore
  return newFloatArray(values || 4);
}
/**
 * Returns a new, uninitialized 3D oriented bounding box (OBB).
 */
function createOBB3(values) {
  // @ts-ignore
  return newFloatArray(values || 32);
}
/**
 * Returns a new, uninitialized 2D oriented bounding box (OBB).
 */
function createOBB2(values) {
  // @ts-ignore
  return newFloatArray(values || 16);
}
/** Returns a new 3D bounding sphere */
function createSphere3(x, y, z, r) {
  return newFloatArray([x, y, z, r]);
}
/**
 * Transforms an createOBB3 by a 4x4
 */
function transformOBB3(m, p, p2) {
  if (p2 === void 0) {
    p2 = p;
  }
  var i;
  var len = p.length;
  var x;
  var y;
  var z;
  var m0 = m[0];
  var m1 = m[1];
  var m2 = m[2];
  var m3 = m[3];
  var m4 = m[4];
  var m5 = m[5];
  var m6 = m[6];
  var m7 = m[7];
  var m8 = m[8];
  var m9 = m[9];
  var m10 = m[10];
  var m11 = m[11];
  var m12 = m[12];
  var m13 = m[13];
  var m14 = m[14];
  var m15 = m[15];
  for (i = 0; i < len; i += 4) {
    x = p[i + 0];
    y = p[i + 1];
    z = p[i + 2];
    p2[i + 0] = m0 * x + m4 * y + m8 * z + m12;
    p2[i + 1] = m1 * x + m5 * y + m9 * z + m13;
    p2[i + 2] = m2 * x + m6 * y + m10 * z + m14;
    p2[i + 3] = m3 * x + m7 * y + m11 * z + m15;
  }
  return p2;
}
/** Returns true if the first AABB2 contains the second AABB2.
 */
function containsAABB2(aabb1, aabb2) {
  return aabb1[0] <= aabb2[0] && aabb2[3] <= aabb1[3] && aabb1[1] <= aabb2[1] && aabb1[2] <= aabb2[2];
}
/** Returns true if the first AABB3 contains the second AABB3.
 */
function containsAABB3(aabb1, aabb2) {
  var result = aabb1[0] <= aabb2[0] && aabb2[3] <= aabb1[3] && aabb1[1] <= aabb2[1] && aabb2[4] <= aabb1[4] && aabb1[2] <= aabb2[2] && aabb2[5] <= aabb1[5];
  return result;
}
/**
 * Gets the diagonal size of an createAABB3 given as minima and maxima.
 */
var getAABB3Diag = function () {
  var min = newFloatArray(3);
  var max = newFloatArray(3);
  var tempVec3 = newFloatArray(3);
  return function (aabb) {
    min[0] = aabb[0];
    min[1] = aabb[1];
    min[2] = aabb[2];
    max[0] = aabb[3];
    max[1] = aabb[4];
    max[2] = aabb[5];
    subVec3(max, min, tempVec3);
    return Math.abs(lenVec3(tempVec3));
  };
}();
/**
 * Get a diagonal boundary size that is symmetrical about the given point.
 */
var getAABB3DiagPoint = function () {
  var min = newFloatArray(3);
  var max = newFloatArray(3);
  var tempVec3 = newFloatArray(3);
  return function (aabb, p) {
    min[0] = aabb[0];
    min[1] = aabb[1];
    min[2] = aabb[2];
    max[0] = aabb[3];
    max[1] = aabb[4];
    max[2] = aabb[5];
    var diagVec = subVec3(max, min, tempVec3);
    var xneg = p[0] - aabb[0];
    var xpos = aabb[3] - p[0];
    var yneg = p[1] - aabb[1];
    var ypos = aabb[4] - p[1];
    var zneg = p[2] - aabb[2];
    var zpos = aabb[5] - p[2];
    diagVec[0] += xneg > xpos ? xneg : xpos;
    diagVec[1] += yneg > ypos ? yneg : ypos;
    diagVec[2] += zneg > zpos ? zneg : zpos;
    return Math.abs(lenVec3(diagVec));
  };
}();
/**
 * Gets the area of an AABB.
 */
function getAABB3Area(aabb) {
  var width = aabb[3] - aabb[0];
  var height = aabb[4] - aabb[1];
  var depth = aabb[5] - aabb[2];
  return width * height * depth;
}
/**
 * Gets the center of an AABB.
 */
function getAABB3Center(aabb, dest) {
  if (dest === void 0) {
    dest = createVec3();
  }
  dest[0] = (aabb[0] + aabb[3]) / 2;
  dest[1] = (aabb[1] + aabb[4]) / 2;
  dest[2] = (aabb[2] + aabb[5]) / 2;
  return dest;
}
/**
 * Gets the center of a 2D AABB.
 */
function getAABB2Center(aabb, dest) {
  if (dest === void 0) {
    dest = createVec2();
  }
  dest[0] = (aabb[2] + aabb[0]) / 2;
  dest[1] = (aabb[3] + aabb[1]) / 2;
  return dest;
}
/**
 * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.
 * Creates new AABB if none supplied.
 */
function collapseAABB3(aabb) {
  if (aabb === void 0) {
    aabb = createAABB3();
  }
  aabb[0] = MAX_DOUBLE;
  aabb[1] = MAX_DOUBLE;
  aabb[2] = MAX_DOUBLE;
  aabb[3] = MIN_DOUBLE;
  aabb[4] = MIN_DOUBLE;
  aabb[5] = MIN_DOUBLE;
  return aabb;
}
/**
 * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.
 * Creates new AABB if none supplied.
 */
function collapseAABB3Int16(aabb) {
  if (aabb === void 0) {
    aabb = createAABB3Int16();
  }
  aabb[0] = 65535;
  aabb[1] = 65535;
  aabb[2] = 65535;
  aabb[3] = -65535;
  aabb[4] = -65535;
  aabb[5] = -65535;
  return aabb;
}
/**
 * Converts an axis-aligned 3D boundary into an oriented boundary consisting of
 * an array of eight 3D positions, one for each corner of the boundary.
 *
 * @private
 */
function AABB3ToOBB3(aabb, obb) {
  if (aabb === void 0) {
    aabb = createAABB3();
  }
  if (obb === void 0) {
    obb = createOBB3();
  }
  obb[0] = aabb[0];
  obb[1] = aabb[1];
  obb[2] = aabb[2];
  obb[3] = 1;
  obb[4] = aabb[3];
  obb[5] = aabb[1];
  obb[6] = aabb[2];
  obb[7] = 1;
  obb[8] = aabb[3];
  obb[9] = aabb[4];
  obb[10] = aabb[2];
  obb[11] = 1;
  obb[12] = aabb[0];
  obb[13] = aabb[4];
  obb[14] = aabb[2];
  obb[15] = 1;
  obb[16] = aabb[0];
  obb[17] = aabb[1];
  obb[18] = aabb[5];
  obb[19] = 1;
  obb[20] = aabb[3];
  obb[21] = aabb[1];
  obb[22] = aabb[5];
  obb[23] = 1;
  obb[24] = aabb[3];
  obb[25] = aabb[4];
  obb[26] = aabb[5];
  obb[27] = 1;
  obb[28] = aabb[0];
  obb[29] = aabb[4];
  obb[30] = aabb[5];
  obb[31] = 1;
  return obb;
}
/**
 * Expands the first axis-aligned 3D boundary to enclose the second, if required.
 */
function expandAABB3(aabb1, aabb2) {
  if (aabb1[0] > aabb2[0]) {
    aabb1[0] = aabb2[0];
  }
  if (aabb1[1] > aabb2[1]) {
    aabb1[1] = aabb2[1];
  }
  if (aabb1[2] > aabb2[2]) {
    aabb1[2] = aabb2[2];
  }
  if (aabb1[3] < aabb2[3]) {
    aabb1[3] = aabb2[3];
  }
  if (aabb1[4] < aabb2[4]) {
    aabb1[4] = aabb2[4];
  }
  if (aabb1[5] < aabb2[5]) {
    aabb1[5] = aabb2[5];
  }
  return aabb1;
}
/**
 * Expands the first axis-aligned 2D boundary to enclose the second, if required.
 */
function expandAABB2(aabb1, aabb2) {
  if (aabb1[0] > aabb2[0]) {
    aabb1[0] = aabb2[0];
  }
  if (aabb1[1] > aabb2[1]) {
    aabb1[1] = aabb2[1];
  }
  if (aabb1[3] < aabb2[3]) {
    aabb1[3] = aabb2[3];
  }
  if (aabb1[4] < aabb2[4]) {
    aabb1[4] = aabb2[4];
  }
  return aabb1;
}
/**
 * Expands an axis-aligned 3D boundary to enclose the given point, if needed.
 */
function expandAABB3Point3(aabb, p) {
  if (aabb[0] > p[0]) {
    aabb[0] = p[0];
  }
  if (aabb[1] > p[1]) {
    aabb[1] = p[1];
  }
  if (aabb[2] > p[2]) {
    aabb[2] = p[2];
  }
  if (aabb[3] < p[0]) {
    aabb[3] = p[0];
  }
  if (aabb[4] < p[1]) {
    aabb[4] = p[1];
  }
  if (aabb[5] < p[2]) {
    aabb[5] = p[2];
  }
  return aabb;
}
/**
 * Expands an axis-aligned 2D boundary to enclose the given point, if needed.
 */
function expandAABB2Point2(aabb, p) {
  if (aabb[0] > p[0]) {
    aabb[0] = p[0];
  }
  if (aabb[1] > p[1]) {
    aabb[1] = p[1];
  }
  if (aabb[3] < p[0]) {
    aabb[3] = p[0];
  }
  if (aabb[4] < p[1]) {
    aabb[4] = p[1];
  }
  return aabb;
}
/**
 * Expands an axis-aligned 3D boundary to enclose the given points, if needed.
 */
function expandAABB3Points3(aabb, positions) {
  var x;
  var y;
  var z;
  for (var i = 0, len = positions.length; i < len; i += 3) {
    x = positions[i];
    y = positions[i + 1];
    z = positions[i + 2];
    if (aabb[0] > x) {
      aabb[0] = x;
    }
    if (aabb[1] > y) {
      aabb[1] = y;
    }
    if (aabb[2] > z) {
      aabb[2] = z;
    }
    if (aabb[3] < x) {
      aabb[3] = x;
    }
    if (aabb[4] < y) {
      aabb[4] = y;
    }
    if (aabb[5] < z) {
      aabb[5] = z;
    }
  }
  return aabb;
}
/**
 * Converts an axis-aligned 3D boundary into an oriented boundary consisting of
 * an array of eight 3D positions, one for each corner of the boundary.
 */
function ABB3ToOBB3(aabb, obb) {
  if (obb === void 0) {
    obb = createOBB3();
  }
  obb[0] = aabb[0];
  obb[1] = aabb[1];
  obb[2] = aabb[2];
  obb[3] = 1;
  obb[4] = aabb[3];
  obb[5] = aabb[1];
  obb[6] = aabb[2];
  obb[7] = 1;
  obb[8] = aabb[3];
  obb[9] = aabb[4];
  obb[10] = aabb[2];
  obb[11] = 1;
  obb[12] = aabb[0];
  obb[13] = aabb[4];
  obb[14] = aabb[2];
  obb[15] = 1;
  obb[16] = aabb[0];
  obb[17] = aabb[1];
  obb[18] = aabb[5];
  obb[19] = 1;
  obb[20] = aabb[3];
  obb[21] = aabb[1];
  obb[22] = aabb[5];
  obb[23] = 1;
  obb[24] = aabb[3];
  obb[25] = aabb[4];
  obb[26] = aabb[5];
  obb[27] = 1;
  obb[28] = aabb[0];
  obb[29] = aabb[4];
  obb[30] = aabb[5];
  obb[31] = 1;
  return obb;
}
/**
 * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.
 */
var positions3ToAABB3 = function () {
  var p = newFloatArray(3);
  return function (positions, aabb, positionsDecompressMatrix) {
    aabb = aabb || createAABB3();
    var xmin = MAX_DOUBLE;
    var ymin = MAX_DOUBLE;
    var zmin = MAX_DOUBLE;
    var xmax = MIN_DOUBLE;
    var ymax = MIN_DOUBLE;
    var zmax = MIN_DOUBLE;
    var x;
    var y;
    var z;
    for (var i = 0, len = positions.length; i < len; i += 3) {
      if (positionsDecompressMatrix) {
        p[0] = positions[i + 0];
        p[1] = positions[i + 1];
        p[2] = positions[i + 2];
        decompressPoint3(p, positionsDecompressMatrix, p);
        x = p[0];
        y = p[1];
        z = p[2];
      } else {
        x = positions[i + 0];
        y = positions[i + 1];
        z = positions[i + 2];
      }
      if (x < xmin) {
        xmin = x;
      }
      if (y < ymin) {
        ymin = y;
      }
      if (z < zmin) {
        zmin = z;
      }
      if (x > xmax) {
        xmax = x;
      }
      if (y > ymax) {
        ymax = y;
      }
      if (z > zmax) {
        zmax = z;
      }
    }
    aabb[0] = xmin;
    aabb[1] = ymin;
    aabb[2] = zmin;
    aabb[3] = xmax;
    aabb[4] = ymax;
    aabb[5] = zmax;
    return aabb;
  };
}();
/**
 * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.
 */
function OBB3ToAABB3(obb, aabb) {
  if (aabb === void 0) {
    aabb = createAABB3();
  }
  var xmin = MAX_DOUBLE;
  var ymin = MAX_DOUBLE;
  var zmin = MAX_DOUBLE;
  var xmax = MIN_DOUBLE;
  var ymax = MIN_DOUBLE;
  var zmax = MIN_DOUBLE;
  var x;
  var y;
  var z;
  for (var i = 0, len = obb.length; i < len; i += 4) {
    x = obb[i + 0];
    y = obb[i + 1];
    z = obb[i + 2];
    if (x < xmin) {
      xmin = x;
    }
    if (y < ymin) {
      ymin = y;
    }
    if (z < zmin) {
      zmin = z;
    }
    if (x > xmax) {
      xmax = x;
    }
    if (y > ymax) {
      ymax = y;
    }
    if (z > zmax) {
      zmax = z;
    }
  }
  aabb[0] = xmin;
  aabb[1] = ymin;
  aabb[2] = zmin;
  aabb[3] = xmax;
  aabb[4] = ymax;
  aabb[5] = zmax;
  return aabb;
}
/**
 * Finds the minimum axis-aligned 3D boundary enclosing the given 3D points.
 */
function points3ToAABB3(points, aabb) {
  if (aabb === void 0) {
    aabb = createAABB3();
  }
  var xmin = MAX_DOUBLE;
  var ymin = MAX_DOUBLE;
  var zmin = MAX_DOUBLE;
  var xmax = MIN_DOUBLE;
  var ymax = MIN_DOUBLE;
  var zmax = MIN_DOUBLE;
  var x;
  var y;
  var z;
  for (var i = 0, len = points.length; i < len; i++) {
    x = points[i][0];
    y = points[i][1];
    z = points[i][2];
    if (x < xmin) {
      xmin = x;
    }
    if (y < ymin) {
      ymin = y;
    }
    if (z < zmin) {
      zmin = z;
    }
    if (x > xmax) {
      xmax = x;
    }
    if (y > ymax) {
      ymax = y;
    }
    if (z > zmax) {
      zmax = z;
    }
  }
  aabb[0] = xmin;
  aabb[1] = ymin;
  aabb[2] = zmin;
  aabb[3] = xmax;
  aabb[4] = ymax;
  aabb[5] = zmax;
  return aabb;
}
/**
 * Gets the 3D center of the given flat array of 3D positions.
 */
function getPositions3Center(positions, center) {
  if (center === void 0) {
    center = createVec3();
  }
  var xCenter = 0;
  var yCenter = 0;
  var zCenter = 0;
  for (var i = 0, len = positions.length; i < len; i += 3) {
    xCenter += positions[i + 0];
    yCenter += positions[i + 1];
    zCenter += positions[i + 2];
  }
  var numPositions = positions.length / 3;
  center[0] = xCenter / numPositions;
  center[1] = yCenter / numPositions;
  center[2] = zCenter / numPositions;
  return center;
}
/**
 * A plane within a {@link Frustum3}.
 */
var FrustumPlane3 = /*#__PURE__*/function () {
  /**
   * Creates a new frustum plane.
   */
  function FrustumPlane3() {
    this.testVertex = void 0;
    this.offset = void 0;
    this.normal = void 0;
    this.normal = createVec3();
    this.offset = 0;
    this.testVertex = createVec3();
  }
  /**
   * Sets the position and direction of the frustum plane.
   * @param nx
   * @param ny
   * @param nz
   * @param offset
   */
  var _proto = FrustumPlane3.prototype;
  _proto.set = function set(nx, ny, nz, offset) {
    var s = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);
    this.normal[0] = nx * s;
    this.normal[1] = ny * s;
    this.normal[2] = nz * s;
    this.offset = offset * s;
    this.testVertex[0] = this.normal[0] >= 0.0 ? 1 : 0;
    this.testVertex[1] = this.normal[1] >= 0.0 ? 1 : 0;
    this.testVertex[2] = this.normal[2] >= 0.0 ? 1 : 0;
  };
  return FrustumPlane3;
}();
/**
 * Intersection state in which first boundary is completely inside the second.
 */
var INSIDE = 1;
/**
 * Intersection state in which two boundaries partially intersect.
 */
var INTERSECT = 2;
/**
 * Intersection state in which two boundaries do not intersect.
 */
var OUTSIDE = 3;
/**
 * A 3D frustum defined as six planes.
 */
var Frustum3 =
/**
 * Creates a new FrustumProjection
 */
function Frustum3() {
  /**
   * The six planes that comprise the frustum boundary.
   */
  this.planes = void 0;
  this.planes = [new FrustumPlane3(), new FrustumPlane3(), new FrustumPlane3(), new FrustumPlane3(), new FrustumPlane3(), new FrustumPlane3()];
};
/**
 * Sets the extents of a frustum to the World-space volume defined by view and projection matrices.
 * Creates the frustum first if not given.
 */
function setFrustum3(viewMat, projMat, frustum) {
  var m = mulMat4(projMat, viewMat, tempMat4a);
  var m0 = m[0];
  var m1 = m[1];
  var m2 = m[2];
  var m3 = m[3];
  var m4 = m[4];
  var m5 = m[5];
  var m6 = m[6];
  var m7 = m[7];
  var m8 = m[8];
  var m9 = m[9];
  var m10 = m[10];
  var m11 = m[11];
  var m12 = m[12];
  var m13 = m[13];
  var m14 = m[14];
  var m15 = m[15];
  frustum = frustum || new Frustum3();
  frustum.planes[0].set(m3 - m0, m7 - m4, m11 - m8, m15 - m12);
  frustum.planes[1].set(m3 + m0, m7 + m4, m11 + m8, m15 + m12);
  frustum.planes[2].set(m3 - m1, m7 - m5, m11 - m9, m15 - m13);
  frustum.planes[3].set(m3 + m1, m7 + m5, m11 + m9, m15 + m13);
  frustum.planes[4].set(m3 - m2, m7 - m6, m11 - m10, m15 - m14);
  frustum.planes[5].set(m3 + m2, m7 + m6, m11 + m10, m15 + m14);
  return frustum;
}
/**
 * Tests for intersection between a frustum and an axis-aligned 3D boundary.
 * @param frustum
 * @param aabb
 */
function intersectFrustum3AABB3(frustum, aabb) {
  var ret = INSIDE;
  var min = tempVec3a$5;
  var max = tempVec3b$5;
  min[0] = aabb[0];
  min[1] = aabb[1];
  min[2] = aabb[2];
  max[0] = aabb[3];
  max[1] = aabb[4];
  max[2] = aabb[5];
  var bminmax = [min, max];
  for (var i = 0; i < 6; ++i) {
    var plane = frustum.planes[i];
    if (plane.normal[0] * bminmax[plane.testVertex[0]][0] + plane.normal[1] * bminmax[plane.testVertex[1]][1] + plane.normal[2] * bminmax[plane.testVertex[2]][2] + plane.offset < 0.0) {
      return OUTSIDE;
    }
    if (plane.normal[0] * bminmax[1 - plane.testVertex[0]][0] + plane.normal[1] * bminmax[1 - plane.testVertex[1]][1] + plane.normal[2] * bminmax[1 - plane.testVertex[2]][2] + plane.offset < 0.0) {
      ret = INTERSECT;
    }
  }
  return ret;
}
/**
 * Tests for intersection between two axis-aligned 3D boundaries.
 * @param aabb1
 * @param aabb2
 */
function intersectAABB3s(aabb1, aabb2) {
  return INTERSECT;
  // let ret = INSIDE;
  // const min = tempVec3a;
  // const max = tempVec3b;
  // min[0] = aabb[0];
  // min[1] = aabb[1];
  // min[2] = aabb[2];
  // max[0] = aabb[3];
  // max[1] = aabb[4];
  // max[2] = aabb[5];
  // const bminmax = [min, max];
  // for (let i = 0; i < 6; ++i) {
  //     const plane = frustum.planes[i];
  //     if (((plane.normal[0] * bminmax[plane.testVertex[0]][0]) +
  //         (plane.normal[1] * bminmax[plane.testVertex[1]][1]) +
  //         (plane.normal[2] * bminmax[plane.testVertex[2]][2]) +
  //         (plane.offset)) < 0.0) {
  //         return OUTSIDE;
  //     }
  //     if (((plane.normal[0] * bminmax[1 - plane.testVertex[0]][0]) +
  //         (plane.normal[1] * bminmax[1 - plane.testVertex[1]][1]) +
  //         (plane.normal[2] * bminmax[1 - plane.testVertex[2]][2]) +
  //         (plane.offset)) < 0.0) {
  //         ret = INTERSECT;
  //     }
  // }
  // return ret;
}
/**
 * Tests if the given {@link @xeokit/boundaries!Frustum3 | Frustum3} intersects the given {@link @xeokit/constants!TrianglesPrimitive | TrianglesPrimitive} geometry.
 *
 * Returns ```` true```` if intersection else ````false````.
 *
 * @param frustum
 * @param positions
 * @param indices
 */
function intersectFrustum3Triangles3(frustum, positions, indices) {
  return true;
}
/**
 * Tests if the given {@link @xeokit/boundaries!Frustum3 | Frustum3} intersects the given triangle primitive.
 *
 * Returns ```` true```` if intersection else ````false````.
 *
 * @param frustum
 * @param a
 * @param b
 * @param c
 */
function intersectFrustum3Triangle3(frustum, a, b, c) {
  return true;
}
/**
 * Tests if the given {@link @xeokit/boundaries!Frustum3 | Frustum3} intersects the given
 * {@link @xeokit/constants!LinesPrimitive | LinesPrimitive} geometry.
 *
 * Returns ```` true```` if intersection else ````false````.
 *
 * @param frustum
 * @param positions
 * @param indices
 */
function intersectFrustum3Lines3(frustum, positions, indices) {
  return true;
}
/**
 * Tests if the given {@link @xeokit/boundaries!Frustum3 | Frustum3} intersects the
 * given {@link @xeokit/constants!PointsPrimitive | PointsPrimitive} geometry.
 *
 * Returns ```` true```` if intersection else ````false````.
 *
 * @param frustum
 * @param positions
 */
function intersectFrustum3Positions3(frustum, positions) {
  return true;
}
/**
 * Tests if the given {@link @xeokit/boundaries!Frustum3 | Frustum3} intersects the given position.
 *
 * Returns ```` true```` if intersection else ````false````.
 *
 * @param frustum
 * @param position
 */
function intersectFrustum3Point3(frustum, position) {
  return true;
}
/**
 * Tests if the given AABB intersects the given {@link @xeokit/constants!TrianglesPrimitive | TrianglesPrimitive} geometry.
 *
 * Returns ```` true```` if intersection else ````false````.
 *
 * @param aabb
 * @param positions
 * @param indices
 */
function intersectAABB3Triangles3(aabb, positions, indices) {
  return false;
}
/**
 * Tests if the given AABB intersects the given {@link @xeokit/constants!LinesPrimitive | LinesPrimitive} geometry.
 *
 * Returns ```` true```` if intersection else ````false````.
 *
 * @param aabb
 * @param positions
 * @param indices
 */
function intersectAABB3Lines3(aabb, positions, indices) {
  return false;
}
/**
 * Tests if the given AABB intersects the given {@link @xeokit/constants!PointsPrimitive | PointsPrimitive} vertex positions.
 *
 * Returns ```` true```` if intersection else ````false````.
 *
 * @param aabb
 * @param positions
 */
function intersectAABB3Positions3(aabb, positions) {
  var xmin = aabb[0];
  var ymin = aabb[1];
  var zmin = aabb[2];
  var xmax = aabb[3];
  var ymax = aabb[4];
  var zmax = aabb[5];
  for (var i = 0, len = positions.length; i < len; i += 3) {
    var x = positions[i];
    if (xmin <= x && x <= xmax) {
      var y = positions[i + 1];
      if (ymin <= y && y <= ymax) {
        var z = positions[i + 2];
        if (zmin <= z && z <= zmax) {
          return true;
        }
      }
    }
  }
  return false;
}
/**
 * Tets if the given 3D AABB contains the given 3D position.
 * @param aabb
 * @param p
 */
function containsAABB3Point3(aabb, p) {
  return aabb[0] <= p[0] && p[0] <= aabb[3] && aabb[1] <= p[1] && p[1] <= aabb[4] && aabb[2] <= p[2] && p[2] <= aabb[5];
}
/**
 * Tets if the given 2D AABB contains the given 2D position.
 * @param aabb
 * @param p
 */
function containsAABB2Point2(aabb, p) {
  return aabb[0] <= p[0] && p[0] <= aabb[3] && aabb[1] <= p[1] && p[1] <= aabb[4];
}

var index$g = {
  __proto__: null,
  createAABB3: createAABB3,
  createAABB3Int16: createAABB3Int16,
  createAABB2: createAABB2,
  createOBB3: createOBB3,
  createOBB2: createOBB2,
  createSphere3: createSphere3,
  transformOBB3: transformOBB3,
  containsAABB2: containsAABB2,
  containsAABB3: containsAABB3,
  getAABB3Diag: getAABB3Diag,
  getAABB3DiagPoint: getAABB3DiagPoint,
  getAABB3Area: getAABB3Area,
  getAABB3Center: getAABB3Center,
  getAABB2Center: getAABB2Center,
  collapseAABB3: collapseAABB3,
  collapseAABB3Int16: collapseAABB3Int16,
  AABB3ToOBB3: AABB3ToOBB3,
  expandAABB3: expandAABB3,
  expandAABB2: expandAABB2,
  expandAABB3Point3: expandAABB3Point3,
  expandAABB2Point2: expandAABB2Point2,
  expandAABB3Points3: expandAABB3Points3,
  ABB3ToOBB3: ABB3ToOBB3,
  positions3ToAABB3: positions3ToAABB3,
  OBB3ToAABB3: OBB3ToAABB3,
  points3ToAABB3: points3ToAABB3,
  getPositions3Center: getPositions3Center,
  FrustumPlane3: FrustumPlane3,
  INSIDE: INSIDE,
  INTERSECT: INTERSECT,
  OUTSIDE: OUTSIDE,
  Frustum3: Frustum3,
  setFrustum3: setFrustum3,
  intersectFrustum3AABB3: intersectFrustum3AABB3,
  intersectAABB3s: intersectAABB3s,
  intersectFrustum3Triangles3: intersectFrustum3Triangles3,
  intersectFrustum3Triangle3: intersectFrustum3Triangle3,
  intersectFrustum3Lines3: intersectFrustum3Lines3,
  intersectFrustum3Positions3: intersectFrustum3Positions3,
  intersectFrustum3Point3: intersectFrustum3Point3,
  intersectAABB3Triangles3: intersectAABB3Triangles3,
  intersectAABB3Lines3: intersectAABB3Lines3,
  intersectAABB3Positions3: intersectAABB3Positions3,
  containsAABB3Point3: containsAABB3Point3,
  containsAABB2Point2: containsAABB2Point2
};

var tempVec3a$4 = createVec3();
var tempMat$1 = new Float32Array(16);
var rtcCenterWorld = new Float64Array(4);
var rtcCenterView = new Float64Array(4);
/**
 * Given a view matrix and a relative-to-center (RTC) coordinate origin, returns a view matrix
 * to transform RTC coordinates to View-space.
 */
function createRTCViewMat(viewMat, rtcCenter, rtcViewMat) {
  if (rtcViewMat === void 0) {
    rtcViewMat = tempMat$1;
  }
  rtcCenterWorld[0] = rtcCenter[0];
  rtcCenterWorld[1] = rtcCenter[1];
  rtcCenterWorld[2] = rtcCenter[2];
  rtcCenterWorld[3] = 1;
  transformVec4(viewMat, rtcCenterWorld, rtcCenterView);
  setMat4Translation(viewMat, rtcCenterView, rtcViewMat);
  return rtcViewMat;
}
/**
 * Converts a World-space 3D position to RTC.
 *
 * Given a double-precision World-space position, returns a double-precision relative-to-center (RTC) center pos
 * and a single-precision offset fom that center.
 *
 * @param worldPos The World-space position.
 * @param rtcCenter Double-precision relative-to-center (RTC) center pos.
 * @param rtcPos Single-precision offset fom that center.
 */
function worldToRTCPos(worldPos, rtcCenter, rtcPos) {
  var xHigh = Float32Array.from([worldPos[0]])[0];
  var xLow = worldPos[0] - xHigh;
  var yHigh = Float32Array.from([worldPos[1]])[0];
  var yLow = worldPos[1] - yHigh;
  var zHigh = Float32Array.from([worldPos[2]])[0];
  var zLow = worldPos[2] - zHigh;
  rtcCenter[0] = xHigh;
  rtcCenter[1] = yHigh;
  rtcCenter[2] = zHigh;
  rtcPos[0] = xLow;
  rtcPos[1] = yLow;
  rtcPos[2] = zLow;
}
/**
 * Converts a World-space 3D position to RTC.
 *
 * Given a double-precision World-space position, returns a double-precision relative-to-center (RTC) center.
 *
 * @param worldCenter The World-space position.
 * @param rtcCenter Double-precision relative-to-center (RTC) center pos.
 * @param [cellSize=200] The size of each coordinate cell within the RTC coordinate system.
 */
function worldToRTCCenter(worldCenter, rtcCenter, cellSize) {
  if (cellSize === void 0) {
    cellSize = 200;
  }
  rtcCenter[0] = Math.round(worldCenter[0] / cellSize) * cellSize;
  rtcCenter[1] = Math.round(worldCenter[1] / cellSize) * cellSize;
  rtcCenter[2] = Math.round(worldCenter[2] / cellSize) * cellSize;
  return rtcCenter;
}
/**
 * Converts a flat array of double-precision positions to RTC positions.
 *
 * Returns the RTC positions, along with a computed RTC center for those positions.
 *
 * When computing the RTC position, this function uses a modulus operation to ensure that, whenever possible,
 * identical RTC positions are reused for different positions arrays.
 *
 * @param worldPositions Flat array of World-space 3D positions.
 * @param rtcPositions Outputs the computed flat array of 3D RTC positions.
 * @param rtcCenter Outputs the computed double-precision relative-to-center (RTC) center pos.
 * @param [cellSize=200] The size of each coordinate cell within the RTC coordinate system.
 * @returns ````True```` if the positions actually needed conversion to RTC, else ````false````. When
 * ````false````, we can safely ignore the data returned in ````rtcPositions```` and ````rtcCenter````,
 * since ````rtcCenter```` will equal ````[0,0,0]````, and ````rtcPositions```` will contain identical values to ````positions````.
 */
function worldToRTCPositions(worldPositions, rtcPositions, rtcCenter, cellSize) {
  if (cellSize === void 0) {
    cellSize = 200;
  }
  var center = getPositions3Center(worldPositions, tempVec3a$4);
  var rtcCenterX = Math.round(center[0] / cellSize) * cellSize;
  var rtcCenterY = Math.round(center[1] / cellSize) * cellSize;
  var rtcCenterZ = Math.round(center[2] / cellSize) * cellSize;
  for (var i = 0, len = worldPositions.length; i < len; i += 3) {
    rtcPositions[i + 0] = worldPositions[i + 0] - rtcCenterX;
    rtcPositions[i + 1] = worldPositions[i + 1] - rtcCenterY;
    rtcPositions[i + 2] = worldPositions[i + 2] - rtcCenterZ;
  }
  rtcCenter[0] = rtcCenterX;
  rtcCenter[1] = rtcCenterY;
  rtcCenter[2] = rtcCenterZ;
  var rtcNeeded = rtcCenter[0] !== 0 || rtcCenter[1] !== 0 || rtcCenter[2] !== 0;
  return rtcNeeded;
}
/**
 * Converts an RTC 3D position to World-space.
 *
 * @param rtcCenter Double-precision relative-to-center (RTC) center pos.
 * @param rtcPos Single-precision offset fom that center.
 * @param worldPos The World-space position.
 */
function rtcToWorldPos(rtcCenter, rtcPos, worldPos) {
  worldPos[0] = rtcCenter[0] + rtcPos[0];
  worldPos[1] = rtcCenter[1] + rtcPos[1];
  worldPos[2] = rtcCenter[2] + rtcPos[2];
  return worldPos;
}
/**
 * Given a 3D plane defined by distance from origin and direction, and an RTC center position,
 * return a plane position that is relative to the RTC center.
 *
 * @param dist
 * @param dir
 * @param rtcCenter
 * @param rtcPlanePos
 * @returns {*}
 */
function getPlaneRTCPos(dist, dir, rtcCenter, rtcPlanePos) {
  var rtcCenterToPlaneDist = dotVec3(dir, rtcCenter) + dist;
  var dirNormalized = normalizeVec3(dir, tempVec3a$4);
  mulVec3Scalar(dirNormalized, -rtcCenterToPlaneDist, rtcPlanePos);
  return rtcPlanePos;
}

var index$f = {
  __proto__: null,
  createRTCViewMat: createRTCViewMat,
  worldToRTCPos: worldToRTCPos,
  worldToRTCCenter: worldToRTCCenter,
  worldToRTCPositions: worldToRTCPositions,
  rtcToWorldPos: rtcToWorldPos,
  getPlaneRTCPos: getPlaneRTCPos
};

/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2Fmath.svg)](https://badge.fury.io/js/%40xeokit%2Fmath)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/badge)](https://www.jsdelivr.com/package/npm/@xeokit/math)
 *
 * # xeokit Curves Math Library
 *
 * ---
 *
 * ### *Spline curve math functions*
 *
 * ---
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/curves
 * ````
 *
 * ````javascript
 * import * as curves from "@xeokit/curves";
 *
 * //..
 * ````
 *
 * @module @xeokit/curves
 */
/**
 * Finds a tangent to a quadratic Bézier curve.
 *
 * @param t
 * @param p0
 * @param p1
 * @param p2
 */
function tangentQuadraticBézier(t, p0, p1, p2) {
  return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
}
/**
 * Finds a tangent to a quadratic Bézier curve.
 *
 * @param t
 * @param p0
 * @param p1
 * @param p2
 */
function tangentQuadraticBézier3(t, p0, p1, p2, p3) {
  return -3 * p0 * (1 - t) * (1 - t) + 3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) + 6 * t * p2 * (1 - t) - 3 * t * t * p2 + 3 * t * t * p3;
}
/**
 * Finds a tangent to a spline.
 * @param t
 */
function tangentSpline(t) {
  var h00 = 6 * t * t - 6 * t;
  var h10 = 3 * t * t - 4 * t + 1;
  var h01 = -6 * t * t + 6 * t;
  var h11 = 3 * t * t - 2 * t;
  return h00 + h10 + h01 + h11;
}
/**
 * Catmull-Rom interpolation on a curve.
 * @param p0
 * @param p1
 * @param p2
 * @param p3
 * @param t
 */
function catmullRomInterpolate(p0, p1, p2, p3, t) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  var t2 = t * t;
  var t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}
// Bézier Curve formulii from http://en.wikipedia.org/wiki/B%C3%A9zier_curve
// Quad Bézier Functions
/**
 * Quad Bézier curve function b2p0
 *
 * @param t
 * @param p
 */
function b2p0(t, p) {
  var k = 1 - t;
  return k * k * p;
}
/**
 * Quad Bézier curve function b2p1
 * @param t
 * @param p
 */
function b2p1(t, p) {
  return 2 * (1 - t) * t * p;
}
/**
 * Quad Bézier curve function b2p2
 * @param t
 * @param p
 */
function b2p2(t, p) {
  return t * t * p;
}
/**
 * Quad Bézier curve function b2
 * @param t
 * @param p0
 * @param p1
 * @param p2
 */
function b2(t, p0, p1, p2) {
  return this.b2p0(t, p0) + this.b2p1(t, p1) + this.b2p2(t, p2);
}
// Cubic Bézier Functions
/**
 * Cubic Bézier curve function b3p0
 * @param t
 * @param p
 */
function b3p0(t, p) {
  var k = 1 - t;
  return k * k * k * p;
}
/**
 * Cubic Bézier curve function b3p1
 * @param t
 * @param p
 */
function b3p1(t, p) {
  var k = 1 - t;
  return 3 * k * k * t * p;
}
/**
 * Cubic Bézier curve function b3p2
 * @param t
 * @param p
 */
function b3p2(t, p) {
  var k = 1 - t;
  return 3 * k * t * t * p;
}
/**
 * Cubic Bézier curve function b3p3
 * @param t
 * @param p
 */
function b3p3(t, p) {
  return t * t * t * p;
}
/**
 * Cubic Bézier curve function b3
 * @param t
 * @param p0
 * @param p1
 * @param p2
 * @param p3
 */
function b3(t, p0, p1, p2, p3) {
  return this.b3p0(t, p0) + this.b3p1(t, p1) + this.b3p2(t, p2) + this.b3p3(t, p3);
}

var index$e = {
  __proto__: null,
  'tangentQuadraticBézier': tangentQuadraticBézier,
  'tangentQuadraticBézier3': tangentQuadraticBézier3,
  tangentSpline: tangentSpline,
  catmullRomInterpolate: catmullRomInterpolate,
  b2p0: b2p0,
  b2p1: b2p1,
  b2p2: b2p2,
  b2: b2,
  b3p0: b3p0,
  b3p1: b3p1,
  b3p2: b3p2,
  b3p3: b3p3,
  b3: b3
};

/**
 * The localization service for a {@link @xeokit/viewer!Viewer}.
 *
 * See {@link "@xeokit/localization"} for usage.
 */
var _messages = /*#__PURE__*/_classPrivateFieldLooseKey("messages");
var _locales = /*#__PURE__*/_classPrivateFieldLooseKey("locales");
var _locale = /*#__PURE__*/_classPrivateFieldLooseKey("locale");
var LocaleService = /*#__PURE__*/function () {
  /**
   * Constructs a LocaleService.
   *
   * @param cfg LocaleService configuration
   * @param cfg.messages Set of locale translations
   * @param cfg.locale Initial locale
   */
  function LocaleService(cfg) {
    if (cfg === void 0) {
      cfg = {
        messages: {},
        locale: ""
      };
    }
    /**
     * Emits an event each time the locale translations have updated.
     *
     * @event
     */
    this.onUpdated = void 0;
    Object.defineProperty(this, _messages, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _locales, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _locale, {
      writable: true,
      value: "en"
    });
    this.onUpdated = new EventEmitter(new dist.EventDispatcher());
    this.messages = cfg.messages;
    this.locale = cfg.locale;
  }
  /**
   * Replaces the current set of locale translations.
   *
   * * Fires an "updated" event when done.
   * * Automatically refreshes any plugins that depend on the translations.
   * * Does not change the current locale.
   *
   * ## Usage
   *
   * ````javascript
   * viewer.localeService.setMessages({
   *     messages: {
   *         "en": { // English
   *             "NavCube": {
   *                 "front": "Front",
   *                 "back": "Back",
   *                 "top": "Top",
   *                 "bottom": "Bottom",
   *                 "left": "Left",
   *                 "right": "Right"
   *             }
   *         },
   *         "mi": { // Māori
   *             "NavCube": {
   *                 "front": "Mua",
   *                 "back": "Tuarā",
   *                 "top": "Runga",
   *                 "bottom": "Raro",
   *                 "left": "Mauī",
   *                 "right": "Tika"
   *             }
   *         }
   *    }
   * });
   * ````
   *
   * @param messages The new translations.
   */
  var _proto = LocaleService.prototype;
  /**
   * Loads a new set of locale translations, adding them to the existing translations.
   *
   * * Fires an "updated" event when done.
   * * Automatically refreshes any plugins that depend on the translations.
   * * Does not change the current locale.
   *
   * ## Usage
   *
   * ````javascript
   * viewer.localeService.loadMessages({
   *     "jp": { // Japanese
   *         "NavCube": {
   *             "front": "前部",
   *             "back": "裏",
   *             "top": "上",
   *             "bottom": "底",
   *             "left": "左",
   *             "right": "右"
   *         }
   *     }
   * });
   * ````
   *
   * @param messages The new translations.
   */
  _proto.loadMessages = function loadMessages(messages) {
    if (messages === void 0) {
      messages = {};
    }
    for (var locale in messages) {
      _classPrivateFieldLooseBase(this, _messages)[_messages][locale] = messages[locale];
    }
    this.messages = _classPrivateFieldLooseBase(this, _messages)[_messages];
  }
  /**
   * Clears all locale translations.
   *
   * * Fires an "updated" event when done.
   * * Does not change the current locale.
   * * Automatically refreshes any plugins that depend on the translations, which will cause those
   * plugins to fall back on their internal hard-coded text values, since this method removes all
   * our translations.
   */;
  _proto.clearMessages = function clearMessages() {
    this.messages = {};
  }
  /**
   * Translates the given string according to the current locale.
   *
   * Returns null if no translation can be found.
   *
   * @param msg String to translate.
   * @param args Extra parameters.
   * @returns  Translated string if found, else null.
   */;
  _proto.translate = function translate(msg, args) {
    var localeMessages = _classPrivateFieldLooseBase(this, _messages)[_messages][_classPrivateFieldLooseBase(this, _locale)[_locale]];
    if (!localeMessages) {
      return null;
    }
    var localeMessage = resolvePath(msg, localeMessages);
    if (localeMessage) {
      if (args) {
        return vsprintf(localeMessage, args);
      }
      return localeMessage;
    }
    return null;
  }
  /**
   * Translates the given phrase according to the current locale.
   *
   * Returns null if no translation can be found.
   *
   * @param msg Phrase to translate.
   * @param count The plural number.
   * @param [args] Extra parameters.
   * @returns String|null Translated string if found, else null.
   */;
  _proto.translatePlurals = function translatePlurals(msg, count, args) {
    var localeMessages = _classPrivateFieldLooseBase(this, _messages)[_messages][_classPrivateFieldLooseBase(this, _locale)[_locale]];
    if (!localeMessages) {
      return null;
    }
    var localeMessage = resolvePath(msg, localeMessages);
    count = parseInt("" + count, 10);
    if (count === 0) {
      localeMessage = localeMessage.zero;
    } else {
      localeMessage = count > 1 ? localeMessage.other : localeMessage.one;
    }
    if (!localeMessage) {
      return null;
    }
    localeMessage = vsprintf(localeMessage, [count]);
    if (args) {
      localeMessage = vsprintf(localeMessage, args);
    }
    return localeMessage;
  };
  _createClass(LocaleService, [{
    key: "messages",
    set: function set(messages) {
      _classPrivateFieldLooseBase(this, _messages)[_messages] = messages || {};
      _classPrivateFieldLooseBase(this, _locales)[_locales] = Object.keys(_classPrivateFieldLooseBase(this, _messages)[_messages]);
      this.onUpdated.dispatch(this, _classPrivateFieldLooseBase(this, _locale)[_locale]);
    }
    /**
     * Gets the list of available locales.
     *
     * These are derived from the currently configured set of translations.
     *
     * @returns The list of available locales.
     */
  }, {
    key: "locales",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _locales)[_locales];
    }
    /**
     * Gets the current locale.
     *
     * @returns {String} The current locale.
     */
  }, {
    key: "locale",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _locale)[_locale];
    }
    /**
     * Sets the current locale.
     *
     * * Fires an "updated" event when done.
     * * The given locale does not need to be in the list of available locales returned by {@link LocaleService.locales}, since
     * this method assumes that you may want to load the locales at a later point.
     * * Automatically refreshes any plugins that depend on the translations.
     * * We can then get translations for the locale, if translations have been loaded for it, via {@link LocaleService.translate} and {@link LocaleService.translatePlurals}.
     *
     * @param locale The new current locale.
     */,
    set: function set(locale) {
      locale = locale || "de";
      if (_classPrivateFieldLooseBase(this, _locale)[_locale] === locale) {
        return;
      }
      _classPrivateFieldLooseBase(this, _locale)[_locale] = locale;
      this.onUpdated.dispatch(this, _classPrivateFieldLooseBase(this, _locale)[_locale]);
    }
  }]);
  return LocaleService;
}();
function resolvePath(key, json) {
  if (json[key]) {
    return json[key];
  }
  var parts = key.split(".");
  var obj = json;
  for (var i = 0, len = parts.length; obj && i < len; i++) {
    var part = parts[i];
    obj = obj[part];
  }
  return obj;
}
function vsprintf(msg, args) {
  if (args === void 0) {
    args = [];
  }
  return msg.replace(/\{\{|\}\}|\{(\d+)\}/g, function (m, n) {
    if (m === "{{") {
      return "{";
    }
    if (m === "}}") {
      return "}";
    }
    return args[n];
  });
}

/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2Flocale.svg)](https://badge.fury.io/js/%40xeokit%2Flocale)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/locale/badge)](https://www.jsdelivr.com/package/npm/@xeokit/locale)
 *
 * <img style="padding:0px; padding-top:20px; padding-bottom:20px; height:150px; width:150px;" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F45c3a188-6ed1-4540-9f33-37af754accbd%2Fi1n8_icon.png?id=06769198-9d4e-48fe-b891-7447f85222d1&table=block&spaceId=8ed52f91-a7f1-46bf-b39b-49af46e0a158&width=1000&userId=&cache=v2"/>
 *
 * # xeokit Localization Service
 *
 * ---
 *
 * ### Repository of locale-specific translations for words and phrases
 *
 * ---
 *
 * A container of string translations ("messages") for various locales.
 *
 * <br>
 *
 * [![](https://mermaid.ink/img/pako:eNqNUsFuwjAM_ZXKp00CabtWqIeN0wQD0WsupnFHpjSpnORQIf59SUMHCImtl9TPznvPjo_QWElQQqPRuaXCL8ZOGGGkYmq8sqZY7VI85ou6IUPreEMXR2GK-CmZT7v_jvUuBw0TetqM0NNzxvZBaTkFkpxnO6TwlNgn_iV6HOkfsfdse2I_1PRIL2M70pi6cAfV32a2F5Z_WcwGVxblu_LDR7353GKclZsGsVj0KSZPXFUZQmYc3kLbEmfA_Y7vrDG1e6OhrzQu7G0w43sk8rH43oqAFwHzeSXgVUB9pfVH6fJi41p7St_fhhl0xB0qGTdndCjAH6gjAWX8ldRi0F5AdBpLMXhbD6aB0nOgGYQ-9k3nXYOyRe0iSlJ5y-vzNqbj9AOT7uJt?type=png)](https://mermaid.live/edit#pako:eNqNUsFuwjAM_ZXKp00CabtWqIeN0wQD0WsupnFHpjSpnORQIf59SUMHCImtl9TPznvPjo_QWElQQqPRuaXCL8ZOGGGkYmq8sqZY7VI85ou6IUPreEMXR2GK-CmZT7v_jvUuBw0TetqM0NNzxvZBaTkFkpxnO6TwlNgn_iV6HOkfsfdse2I_1PRIL2M70pi6cAfV32a2F5Z_WcwGVxblu_LDR7353GKclZsGsVj0KSZPXFUZQmYc3kLbEmfA_Y7vrDG1e6OhrzQu7G0w43sk8rH43oqAFwHzeSXgVUB9pfVH6fJi41p7St_fhhl0xB0qGTdndCjAH6gjAWX8ldRi0F5AdBpLMXhbD6aB0nOgGYQ-9k3nXYOyRe0iSlJ5y-vzNqbj9AOT7uJt)
 *
 * <br>
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/locale
 * ````
 * ## Usage
 *
 *  In the example below, we'll create a {@link @xeokit/locale!LocaleService | LocaleService} instance, configured with some English, Māori and French
 *  translations for a NavCube widget.
 *
 *  Our LocaleServe will provide translations for the following terms:
 *
 * * "NavCube.front"
 * * "NavCube.back"
 * * "NavCube.top"
 * * "NavCube.bottom"
 * * "NavCube.left"
 * * "NavCube.right"
 *
 *  These terms are effectively paths that map to translations for the currently active locale.
 *
 *  For example, if  the {@link @xeokit/locale!LocaleService | LocaleService}'s locale is set to "fr", then the path "NavCube.back" will drill down
 *  into ````messages->fr->NavCube->front```` and fetch "Arrière".
 *
 *  ````javascript
 *  import {LocaleService} from "@xeokit/locale";
 *
 *  const localeService= new LocaleService({
 *           messages: {
 *               "en": { // English
 *                   "NavCube": {
 *                       "front": "Front",
 *                       "back": "Back",
 *                       "top": "Top",
 *                       "bottom": "Bottom",
 *                       "left": "Left",
 *                       "right": "Right"
 *                   }
 *               },
 *               "mi": { // Māori
 *                   "NavCube": {
 *                       "front": "Mua",
 *                       "back": "Tuarā",
 *                       "top": "Runga",
 *                       "bottom": "Raro",
 *                       "left": "Mauī",
 *                       "right": "Tika"
 *                   }
 *               },
 *               "fr": { // Francais
 *                   "NavCube": {
 *                       "front": "Avant",
 *                       "back": "Arrière",
 *                       "top": "Supérieur",
 *                       "bottom": "Inférieur",
 *                       "left": "Gauche",
 *                       "right": "Droit"
 *                   }
 *               }
 *           },
 *           locale: "en"
 *       })
 *   });
 * ````
 *
 *  We can dynamically switch to a different locale at any time:
 *
 *  ````javascript
 *  localeService.locale = "mi"; // Switch to Māori
 *  ````
 *
 *  We can load new translations at any time:
 *
 *  ````javascript
 *  localeService.loadMessages({
 *      "jp": { // Japanese
 *          "NavCube": {
 *              "front": "前部",
 *              "back": "裏",
 *              "top": "上",
 *              "bottom": "底",
 *              "left": "左",
 *              "right": "右"
 *          }
 *      }
 *  });
 *  ````
 *
 *  And we can clear the translations if needed:
 *
 *  ````javascript
 *  localeService.clearMessages();
 *  ````
 *
 *  We can also get an event from the {@link @xeokit/locale!LocaleService | LocaleService} whenever we switch locales or load messages, which is useful
 *  for triggering UI elements to refresh themselves with updated translations:
 *
 *  ````javascript
 *  localeService.onUpdated.subscribe(() => {
 *      console.log( viewer.localeService.translate("NavCube.left") );
 *  });
 *  ````
 *
 *  @module @xeokit/locale
 */

var index$d = {
  __proto__: null,
  LocaleService: LocaleService
};

/**
 * A property in a {@link @xeokit/data!PropertySet}.
 *
 * See {@link "@xeokit/data"} for usage.
 */
var Property =
/**
 * @private
 * @ignore
 */
function Property(propertySet, propertyCfg) {
  /**
   * The PropertySet to which this Property belongs.
   */
  this.propertySet = void 0;
  /**
   * The name of this property.
   */
  this.name = void 0;
  /**
   * The value of this property.
   */
  this.value = void 0;
  /**
   * The type of this property.
   */
  this.type = void 0;
  /**
   * The type of this property's value.
   */
  this.valueType = void 0;
  /**
   * Informative text to explain the property.
   */
  this.description = void 0;
  this.propertySet = propertySet;
  this.name = propertyCfg.name;
  this.type = propertyCfg.type;
  this.value = propertyCfg.value;
  this.valueType = propertyCfg.valueType;
  this.description = propertyCfg.description;
};

/**
 * A set of {@link Property | Properties} in a {@link @xeokit/data!DataModel | DataModel}.
 *
 * * Created with {@link @xeokit/data!DataModel.createPropertySet | DataModel.createPropertySet}
 * * Stored in {@link @xeokit/data!Data.propertySets | Data.propertySets} and {@link @xeokit/data!DataModel.propertySets | Data.propertySets}
 *
 * See {@link "@xeokit/data"} for usage.
 */
var PropertySet =
/**
 * @private
 */
function PropertySet(dataModel, propertySetCfg) {
  /**
   * The DataModels to which this PropertySet belongs.
   */
  this.models = void 0;
  /**
   * Unique ID.
   *
   * PropertySet instances are registered by this ID in {@link @xeokit/data!Data.propertySets | Data.propertySets}
   * and {@link @xeokit/data!DataModel.propertySets | DataModel.propertySets}.
   */
  this.id = void 0;
  /**
   * ID of the corresponding object within the originating system, if any.
   */
  this.originalSystemId = void 0;
  /**
   * Human-readable name of this PropertySet.
   */
  this.name = void 0;
  /**
   * Type of this PropertySet.
   */
  this.type = void 0;
  /**
   * Properties within this PropertySet.
   */
  this.properties = void 0;
  this.models = [dataModel];
  this.id = propertySetCfg.id;
  this.name = propertySetCfg.name;
  this.type = propertySetCfg.type;
  this.properties = [];
  if (propertySetCfg.properties) {
    for (var i = 0, len = propertySetCfg.properties.length; i < len; i++) {
      var property = new Property(this, propertySetCfg.properties[i]);
      this.properties.push(property);
    }
  }
};

/**
 * An object in a {@link @xeokit/data!DataModel}.
 *
 * * Created with {@link @xeokit/data!DataModel.createObject | DataModel.createObject}
 * * Stored in {@link @xeokit/data!Data.objects | Data.objects}, {@link @xeokit/data!Data.rootObjects | Data.rootObjects}, {@link @xeokit/data!Data.objectsByType | Data.objectsByType}, {@link @xeokit/data!DataModel.objects | Data.objects}, {@link @xeokit/data!DataModel.rootObjects | Data.rootObjects}
 *
 * See {@link "@xeokit/data"} for usage.
 */
var DataObject =
/**
 * @private
 */
function DataObject(data, model, id, name, type, propertySets) {
  /**
   *  {@link @xeokit/data!Data} that contains this DataObject.
   */
  this.data = void 0;
  /**
   * {@link @xeokit/data!DataModel | DataModels} that share this DataObject.
   */
  this.models = void 0;
  /**
   * Globally-unique ID.
   *
   * DataObjects are stored by ID in {@link @xeokit/data!Data.objects | Data.objects}, {@link @xeokit/data!Data.rootObjects | Data.rootObjects}, {@link @xeokit/data!Data.objectsByType | Data.objectsByType} and {@link @xeokit/data!DataModel.rootObjects | Data.rootObjects}.
   */
  this.id = void 0;
  /**
   * Human-readable name.
   */
  this.name = void 0;
  /**
   * DataObject's type.
   */
  this.type = void 0;
  /**
   *{@link @xeokit/data!PropertySet | PropertySets} referenced by this DataObject.
   */
  this.propertySets = void 0;
  /**
   * The {@link @xeokit/data!Relationship | Relations} in which this DataObject is the {@link @xeokit/data!Relationship.relatingObject | Relationship.relatingObject} participant.
   *
   * Each DataObject is mapped here by {@link @xeokit/data!Relationship.type | Relationship.type} and sub-mapped by {@link @xeokit/data!Relationship.relatingObject | Relationship.relatingObject}.
   */
  this.relating = void 0;
  /**
   * The {@link @xeokit/data!Relationship | Relationships} in which this DataObject is the {@link @xeokit/data!Relationship.relatedObject | Relationship.relatedObject} participant.
   *
   * Each DataObject is mapped here by {@link @xeokit/data!Relationship.type | Relationship.type} and sub-mapped by {@link @xeokit/data!Relationship.relatedObject | Relationship.relatedObject}.
   */
  this.related = void 0;
  this.data = data;
  this.models = [model];
  this.id = id;
  this.name = name;
  this.type = type;
  this.propertySets = propertySets || [];
  this.related = {};
  this.relating = {};
};

/**
 * A one-to-one relationship between two {@link @xeokit/data!DataObject | DataObjects}.
 *
 * See {@link "@xeokit/data"} for usage.
 */
var Relationship =
/**
 * @private
 * @ignore
 */
function Relationship(type, relatingObject, relatedObject) {
  /**
   * The type of this Relationship.
   *
   * This can be any value that identifies the Relationship type within your DataModel.
   */
  this.type = void 0;
  /**
   * The relating {@link @xeokit/data!DataObject} in this Relationship.
   *
   * This Relationship will be stored by {@link @xeokit/data!DataObject.type | DataObject.type}
   * in the DataObject's {@link @xeokit/data!DataObject.related | DataObject.related} attribute.
   */
  this.relatingObject = void 0;
  /**
   * The related {@link @xeokit/data!DataObject} in this Relationship.
   *
   * This Relationship will be stored by {@link @xeokit/data!DataObject.type | DataObject.type} in
   * the DataObject's {@link @xeokit/data!DataObject.relating | DataObject.relating} attribute.
   */
  this.relatedObject = void 0;
  this.type = type;
  this.relatingObject = relatingObject;
  this.relatedObject = relatedObject;
};

/**
 * xeokit Semantic Data Model.
 *
 * See {@link "@xeokit/data"} for usage.
 */
var _destroyed$1 = /*#__PURE__*/_classPrivateFieldLooseKey("destroyed");
var _removeObjectFromModels = /*#__PURE__*/_classPrivateFieldLooseKey("removeObjectFromModels");
var DataModel = /*#__PURE__*/function (_Component) {
  _inheritsLoose(DataModel, _Component);
  /**
   * @private
   */
  function DataModel(data, id, dataModelParams, options) {
    var _this;
    _this = _Component.call(this, data) || this;
    // #removePropertySetFromModels(dataObject: DataObject) {
    //     for (let i = 0, len = dataObject.models.length; i < len; i++) {
    //         if (dataObject.models[i] === this) {
    //             dataObject.models = dataObject.models.splice(i, 1);
    //             break;
    //         }
    //     }
    // }
    Object.defineProperty(_assertThisInitialized(_this), _removeObjectFromModels, {
      value: _removeObjectFromModels2
    });
    /**
     * The Data that contains this DataModel.
     */
    _this.data = void 0;
    /**
     * The model name, if available.
     */
    _this.name = void 0;
    /**
     * The project ID, if available.
     */
    _this.projectId = void 0;
    /**
     * The revision ID, if available.
     */
    _this.revisionId = void 0;
    /**
     * The model author, if available.
     */
    _this.author = void 0;
    /**
     * The date the model was created, if available.
     */
    _this.createdAt = void 0;
    /**
     * The application that created the model, if available.
     */
    _this.creatingApplication = void 0;
    /**
     * The model schema version, if available.
     */
    _this.schema = void 0;
    /**
     * The{@link @xeokit/data!PropertySet | PropertySets} in this DataModel, mapped to{@link @xeokit/data!PropertySet.id | PropertySet.id}.
     *
     * PropertySets have globally-unique IDs and will also be stored in {@link @xeokit/data!Data.propertySets | Data.propertySets}.
     */
    _this.propertySets = void 0;
    /**
     * The {@link @xeokit/data!DataObject | DataObjects} in this DataModel, mapped to {@link @xeokit/data!DataObject.id | DataObject.id}.
     *
     * DataObjects have globally-unique IDs and will also be stored in {@link @xeokit/data!Data.objects | Data.objects}.
     */
    _this.objects = void 0;
    /**
     * The root {@link @xeokit/data!DataObject | DataObjects} in this DataModel, mapped
     * to {@link @xeokit/data!DataObject.id | DataObject.id}.
     *
     * * This is the set of DataObjects in this DataModel that are not the *related* participant in
     * any {@link @xeokit/data!Relationship | Relationships}, where they have no incoming Relationships and
     * their {@link @xeokit/data!DataObject.relating} property is empty.
     */
    _this.rootObjects = void 0;
    /**
     * The {@link @xeokit/data!DataObject | DataObjects} in this DataModel, mapped to {@link @xeokit/data!DataObject.type | DataObject.type},
     * sub-mapped to {@link @xeokit/data!DataObject.id | DataObject.id}.
     */
    _this.objectsByType = void 0;
    /**
     * The {@link @xeokit/data!Relationship | Relationships} in this DataModel.
     *
     * * The Relationships can be between DataObjects in different DataModels, but always within the same Data.
     */
    _this.relationships = void 0;
    /**
     * The count of each type of {@link @xeokit/data!DataObject} in this DataModel, mapped to {@link @xeokit/data!DataObject.type | DataObject.type}.
     */
    _this.typeCounts = void 0;
    /**
     * Emits an event when the {@link @xeokit/data!DataModel} has been built.
     *
     * * The DataModel is built using {@link @xeokit/data!DataModel.build | DataModel.build}.
     * * {@link @xeokit/data!DataModel.built | DataModel.built} indicates if the DataModel is currently built.
     * * Don't create anything more in this DataModel once it's built.
     *
     * @event
     */
    _this.onBuilt = void 0;
    /**
     * Indicates if this DataModel has been built.
     *
     * * Set true by {@link @xeokit/data!DataModel.build | DataModel.build}.
     * * Subscribe to updates using {@link @xeokit/data!DataModel.onBuilt | DataModel.onBuilt} and {@link @xeokit/data!Data.onModelCreated | Data.onModelCreated}.
     */
    _this.built = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _destroyed$1, {
      writable: true,
      value: void 0
    });
    _this.onBuilt = new EventEmitter(new dist.EventDispatcher());
    _this.data = data;
    _this.id = id;
    _this.projectId = dataModelParams.projectId || "";
    _this.revisionId = dataModelParams.revisionId || "";
    _this.author = dataModelParams.author || "";
    _this.createdAt = dataModelParams.createdAt || "";
    _this.creatingApplication = dataModelParams.creatingApplication || "";
    _this.schema = dataModelParams.schema || "";
    _this.propertySets = {};
    _this.objects = {};
    _this.objectsByType = {};
    _this.relationships = [];
    _this.typeCounts = {};
    _this.rootObjects = {};
    _this.built = false;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _destroyed$1)[_destroyed$1] = false;
    _this.fromJSON(dataModelParams);
    return _this;
  }
  /**
   * Adds the given components to this DataModel.
   *
   * See {@link "@xeokit/data"} for usage.
   *
   * @param dataModelParams
   * @returns *void*
   * * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * If this DataModel has already been built.
   * * If this DataModel has already been destroyed.
   * * A duplicate PropertySet was already created for this DataModel.
   * * A duplicate DataObject was already created in this DataModel.
   * * DataObjects were not found for a Relationship.
   */
  var _proto = DataModel.prototype;
  _proto.fromJSON = function fromJSON(dataModelParams) {
    if (this.destroyed) {
      return new SDKError("Failed to add components to DataModel - DataModel already destroyed");
    }
    if (this.built) {
      throw new SDKError("Failed to add components to DataModel - DataModel already built");
    }
    if (dataModelParams.propertySets) {
      for (var i = 0, len = dataModelParams.propertySets.length; i < len; i++) {
        this.createPropertySet(dataModelParams.propertySets[i]);
      }
    }
    if (dataModelParams.objects) {
      for (var _i = 0, _len = dataModelParams.objects.length; _i < _len; _i++) {
        this.createObject(dataModelParams.objects[_i]);
      }
    }
    if (dataModelParams.relationships) {
      for (var _i2 = 0, _len2 = dataModelParams.relationships.length; _i2 < _len2; _i2++) {
        this.createRelationship(dataModelParams.relationships[_i2]);
      }
    }
  }
  /**
   * Creates a new {@link @xeokit/data!PropertySet}.
   *
   * * Stores the new PropertySet in {@link @xeokit/data!DataModel.propertySets | DataModel.propertySets}
   * and {@link @xeokit/data!Data.propertySets | Data.propertySets}.
   * * Note that PropertySet IDs are globally unique. PropertySet instances are automatically reused and shared among DataModels
   * when IDs given to {@link @xeokit/data!DataModel.createPropertySet | DataModel.createPropertySet} match existing PropertySet
   * instances in the same Data.
   *
   * ### Usage
   *
   * ````javascript
   *  const propertySet = dataModel.createPropertySet({
   *      id: "myPropertySet",
   *      name: "My properties",
   *      properties: [{
   *          name: "Weight",
   *          value: 5,
   *          type: "",
   *          valueType: "",
   *          description: "Weight of a thing"
   *      }, {
   *          name: "Height",
   *          value: 12,
   *          type: "",
   *          valueType: "",
   *          description: "Height of a thing"
   *      }]
   * });
   *
   * if (propertySet instanceof SDKError) {
   *     console.error(propertySet.message);
   * } else {
   *     // Success
   * }
   * ````
   *
   * See {@link "@xeokit/data"} for more usage info.
   *
   * @param propertySetCfg - PropertySet creation parameters.
   * @returns *{@link PropertySet}*
   * * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * If this DataModel has already been built.
   * * If this DataModel has already been destroyed.
   * * A PropertySet of the given ID was already created for this DataModel. While it's OK
   * for multiple DataModels to *share* PropertySets with duplicate IDs between them, it's not permitted to
   * create duplicate PropertySets within the same DataModel.
   */;
  _proto.createPropertySet = function createPropertySet(propertySetCfg) {
    if (this.destroyed) {
      return new SDKError("Failed to create PropertySet - DataModel already destroyed");
    }
    if (this.built) {
      return new SDKError("DataModel already built");
    }
    if (this.propertySets[propertySetCfg.id]) {
      return new SDKError("Failed to create PropertySet - PropertySet with same ID already created in this DataModel. It's OK to have duplicates shared between DataModels, but they must be unique within each DataModel.");
    }
    var propertySet = this.data.propertySets[propertySetCfg.id];
    if (propertySet) {
      this.propertySets[propertySetCfg.id] = propertySet;
      propertySet.models.push(this);
      return propertySet;
    }
    propertySet = new PropertySet(this, propertySetCfg);
    this.propertySets[propertySetCfg.id] = propertySet;
    this.data.propertySets[propertySetCfg.id] = propertySet;
    return propertySet;
  }
  /**
   * Creates a new {@link @xeokit/data!DataObject}.
   *
   * * Stores the new {@link @xeokit/data!DataObject} in {@link DataModel.objects | DataModel.objects} and {@link Data.objects | Data.objects}.
   * * Fires an event via {@link Data.onObjectCreated | Data.onObjectCreated}.
   * * Note that DataObject IDs are globally unique. DataObject instances are automatically reused and shared among DataModels when
   * IDs given to {@link DataModel.createObject | DataModel.createObject} match existing DataObject instances in the same
   * Data. This feature is part of how xeokit supports [*federated data models*](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#federated-models).
   *
   * ### Usage
   *
   * ````javascript
   * const myDataObject = dataModel.createObject({
   *     id: "myDataObject",
   *     type: BasicEntity,     // @xeokit/basictypes!basicTypes
   *     name: "My Object",
   *     propertySetIds: ["myPropertySet"]
   * });
   *
   * const myDataObject2 = dataModel.createObject({
   *     id: "myDataObject2",
   *     name: "My Other Object",
   *     type: BasicEntity,
   *     propertySetIds: ["myPropertySet"]
   * });
   *
   * if (myDataObject instanceof SDKError) {
   *     console.error(myDataObject.message);
   *
   * } else if (myDataObject2 instanceof SDKError) {
   *     console.error(myDataObject2.message);
   *
   * } else { // Success
   *     const gotMyDataObject = dataModel.objects["myDataObject"];
   *     const gotMyDataObjectAgain = data.objects["myDataObject"];
   * }
   * ````
   *
   * See {@link "@xeokit/data"} for more usage info.
   *
   * @param dataObjectParams - DataObject creation parameters.
   * @returns *{@link DataObject}*
   * * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * If this DataModel has already been built.
   * * If this DataModel has already been destroyed.
   * * A DataObject of the given ID was already created in this DataModel. While it's OK
   * for multiple DataModels to *share* DataObjects with duplicate IDs between them, we're not permitted to
   * create duplicate DataObjects within the same DataModel.
   * * A specified PropertySet could not be found.
   */;
  _proto.createObject = function createObject(dataObjectParams) {
    if (this.destroyed) {
      return new SDKError("Failed to create DataObject - DataModel already destroyed");
    }
    if (this.built) {
      return new SDKError("Failed to create DataObject - DataModel already built");
    }
    var id = dataObjectParams.id;
    if (this.objects[id]) {
      return new SDKError("Failed to create DataObject - DataObject with same ID already created in this DataModel. It's OK to have duplicates shared between DataModels, but they must be unique within each DataModel.");
    }
    var type = dataObjectParams.type;
    var dataObject = this.data.objects[id];
    if (!dataObject) {
      var propertySets = [];
      if (dataObjectParams.propertySetIds) {
        for (var i = 0, len = dataObjectParams.propertySetIds.length; i < len; i++) {
          var propertySetId = dataObjectParams.propertySetIds[i];
          var propertySet = this.propertySets[propertySetId];
          if (!propertySet) {
            return new SDKError("Failed to create DataObject - PropertySet not found: \"" + propertySetId + "\"");
          } else {
            propertySets.push(propertySet);
          }
        }
      }
      dataObject = new DataObject(this.data, this, id, dataObjectParams.name, dataObjectParams.type, propertySets);
      this.objects[id] = dataObject;
      this.data.objects[id] = dataObject;
      if (!this.data.objectsByType[type]) {
        this.data.objectsByType[type] = {};
      }
      this.data.objectsByType[type][id] = dataObject;
      this.data.typeCounts[type] = this.data.typeCounts[type] === undefined ? 1 : this.data.typeCounts[type] + 1;
      dataObject.models.push(this);
      // if (dataObjectParams.relations) {
      //     for (let relationType in dataObjectParams.relations) {
      //         if (!dataObject.relating[relationType]) {
      //             dataObject.relating[relationType] = [];
      //         }
      //         const relatedObjectIds = dataObjectParams.relations[relationType];
      //         for (let j = 0, lenj = relatedObjectIds.length; j < lenj; j++) {
      //             const relatedObjectId = relatedObjectIds[j];
      //             const relatedObject = this.data.objects[relatedObjectId];
      //             if (!relatedObject) {
      //                 this.error(`[createObject] Can't create Relationship - DataObject not found: ${relatedObjectId}`);
      //             } else {
      //                 // @ts-ignore
      //                 const relation = new Relationship(relationType, this, relatedObject);
      //                 relatedObject.relating[relationType].push(relation);
      //                 dataObject.related[relationType].push(relation);
      //             }
      //         }
      //     }
      // }
      this.data.onObjectCreated.dispatch(this.data, dataObject);
    } else {
      this.objects[id] = dataObject;
      this.data.objects[id] = dataObject;
      if (!this.objectsByType[type]) {
        this.objectsByType[type] = {};
      }
      this.objectsByType[type][id] = dataObject;
      this.typeCounts[type] = this.typeCounts[type] === undefined ? 1 : this.typeCounts[type] + 1;
      dataObject.models.push(this);
    }
    return dataObject;
  }
  /**
   * Creates a new {@link @xeokit/data!Relationship} between two existing {@link DataObject | DataObjects}.
   *
   * * A Relationship involves a *relating* DataObject and a *related* DataObject.
   * * The *relating* and *related* DataObjects can exist within different DataModels,
   * as long as the DataModels both exist in the same {@link Data}. This feature is part of
   * how xeokit supports the viewing of [*federated models*](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#federated-models).
   * * The new Relationship will be stored in
   *   - {@link DataModel.relationships | DataModel.relationships},
   *   - {@link DataObject.related | DataObject.related} on the *relating* DataObject, and
   *   - {@link DataObject.relating | DataObject.relating} on the *related* DataObject.
   *
   * ### Usage
   *
   * ````javascript
   * const myRelationship = dataModel.createRelationship({
   *     type: BasicAggregation,            // @xeokit/basictypes!basicTypes
   *     relatingObjectId: "myDataObject",
   *     relatedObjectId: "myDataObject2"
   * });
   *
   * if (myRelationship instanceof SDKError) {
   *     console.error(myRelationship.message);
   *
   * } else { // Success
   *     const myDataObject = dataModel.objects["myDataObject"];
   *     const myDataObject2 = dataModel.objects["myDataObject2"];
   *
   *     const gotMyRelationship = myDataObject.related[BasicAggregation][0];
   *     const gotMyRelationshipAgain = myDataObject2.relating[BasicAggregation][0];
   * }
   * ````
   *
   * See {@link "@xeokit/data"} for more usage info.
   *
   * @param relationshipParams - Relationship creation parameters.
   * @returns *{@link @xeokit/data!Relationship}*
   * * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * If this DataModel has already been built or destroyed.
   * * The *relating* DataObject was not found in the {@link Data} that contains this DataModel.
   * * The *related* DataObject was not found in the Data that contains this DataModel.
   */;
  _proto.createRelationship = function createRelationship(relationshipParams) {
    if (this.destroyed) {
      return new SDKError("Failed to create Relationship - DataModel already destroyed");
    }
    if (this.built) {
      return new SDKError("Failed to create Relationship - DataModel already built");
    }
    var relatingObject = this.data.objects[relationshipParams.relatingObjectId];
    if (!relatingObject) {
      return new SDKError("Failed to create Relationship - relating DataObject not found: " + relationshipParams.relatingObjectId);
    }
    var relatedObject = this.data.objects[relationshipParams.relatedObjectId];
    if (!relatedObject) {
      return new SDKError("Failed to create Relationship - related DataObject not found: " + relationshipParams.relatedObjectId);
    }
    var relation = new Relationship(relationshipParams.type, relatingObject, relatedObject);
    if (!relatedObject.relating[relationshipParams.type]) {
      relatedObject.relating[relationshipParams.type] = [];
    }
    relatedObject.relating[relationshipParams.type].push(relation);
    if (!relatingObject.related[relationshipParams.type]) {
      relatingObject.related[relationshipParams.type] = [];
    }
    relatingObject.related[relationshipParams.type].push(relation);
    this.relationships.push(relation);
    return relation;
  }
  /**
   * Finalizes this DataModel, readying it for use.
   *
   * * Fires an event via {@link DataModel.onBuilt | DataModel.onBuilt} and {@link Data.onModelCreated | DataModel.onCreated}, to indicate to subscribers that
   * the DataModel is complete and ready to use.
   * * Sets {@link DataModel.built | DataModel.built} ````true````.
   * * You can only call this method once on a DataModel.
   * * Once built, no more components can be created in a DataModel.
   *
   * ````javascript
   * dataModel.onBuilt.subscribe(()=>{
   *     // Our DataModel is built and ready to use
   * });
   *
   * data.onModelCreated.subscribe((dataModel)=>{
   *     // Another way to subscribe to DataModel readiness
   * });
   *
   * const result = dataModel.build();
   *
   * if (result instanceof SDKError) {
   *     console.error(result.message);
   * } else {
   *     // Success
   * }
   * ````
   *
   * See {@link "@xeokit/data"} for usage.
   *
   * @throws *{@link @xeokit/core!SDKError}*
   * * If DataModel has already been built or destroyed.
   */;
  _proto.build = function build() {
    var _this2 = this;
    return new Promise(function (resolve) {
      if (_this2.destroyed) {
        throw new SDKError("Failed to build DataModel - DataModel already destroyed");
      }
      if (_this2.built) {
        throw new SDKError("Failed to build DataModel - DataModel already built");
      }
      _this2.built = true;
      _this2.onBuilt.dispatch(_this2, null);
      resolve(_this2);
    });
  }
  /**
   * Gets this DataModel as JSON.
   */;
  _proto.getJSON = function getJSON() {
    if (this.destroyed) {
      return new SDKError("DataModel already destroyed");
    }
    var dataModelParams = {
      id: this.id,
      propertySets: [],
      objects: [],
      relationships: []
    };
    for (var id in this.propertySets) {
      var _dataModelParams$prop;
      var propertySet = this.propertySets[id];
      var propertySetParams = {
        id: id,
        name: propertySet.name,
        properties: [],
        type: propertySet.type,
        originalSystemId: propertySet.originalSystemId
      };
      for (var i = 0, len = propertySet.properties.length; i < len; i++) {
        var property = propertySet.properties[i];
        var propertyParams = {
          name: property.name,
          value: property.value,
          type: property.type,
          valueType: property.valueType,
          description: property.description
        };
        propertySetParams.properties.push(propertyParams);
      }
      (_dataModelParams$prop = dataModelParams.propertySets) == null ? void 0 : _dataModelParams$prop.push(propertySetParams);
    }
    for (var _id in this.objects) {
      var _dataModelParams$obje;
      var object = this.objects[_id];
      var objectParams = {
        id: _id,
        type: object.type,
        name: object.name,
        propertySetIds: []
      };
      if (object.propertySets) {
        for (var _i3 = 0, _len3 = object.propertySets.length; _i3 < _len3; _i3++) {
          var _objectParams$propert;
          var _propertySet = object.propertySets[_i3];
          (_objectParams$propert = objectParams.propertySetIds) == null ? void 0 : _objectParams$propert.push(_propertySet.id);
        }
      }
      (_dataModelParams$obje = dataModelParams.objects) == null ? void 0 : _dataModelParams$obje.push(objectParams);
    }
    for (var _i4 = 0, _len4 = this.relationships.length; _i4 < _len4; _i4++) {
      var _dataModelParams$rela;
      var relationship = this.relationships[_i4];
      var relationParams = {
        type: relationship.type,
        relatingObjectId: relationship.relatingObject.id,
        relatedObjectId: relationship.relatedObject.id
      };
      (_dataModelParams$rela = dataModelParams.relationships) == null ? void 0 : _dataModelParams$rela.push(relationParams);
    }
    return dataModelParams;
  }
  /**
   * Destroys this DataModel.
   *
   * * Fires an event via {@link DataModel.onDestroyed | DataModel.onDestroyed} and {@link Data.onModelDestroyed | Data.onModelDestroyed}.
   * * You can only call this method once on a DataModel.
   * * Once destroyed, no more components can be created in a DataModel.
   * * Does not matter if the DataModel has not yet been built.
   *
   * See {@link "@xeokit/data"} for usage.
   *
   * @returns *void*
   * * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * If this DataModel has already been destroyed.
   */;
  _proto.destroy = function destroy() {
    if (this.destroyed) {
      return new SDKError("Failed to destroy DataModel - DataModel already destroyed");
    }
    for (var id in this.objects) {
      var dataObject = this.objects[id];
      if (dataObject.models.length > 1) {
        _classPrivateFieldLooseBase(this, _removeObjectFromModels)[_removeObjectFromModels](dataObject);
      } else {
        delete this.data.objects[id];
        var type = dataObject.type;
        if (--this.data.typeCounts[type] === 0) {
          delete this.data.typeCounts[type];
          delete this.data.objectsByType[type];
          this.data.onObjectDestroyed.dispatch(this.data, dataObject);
          for (var _type in dataObject.relating) {
            var relations = dataObject.relating[_type];
            for (var i = 0, len = relations.length; i < len; i++) {
              var relation = relations[i];
              var related = relation.relatedObject;
              var list = related.relating[_type];
              for (var j = 0, k = 0, lenj = list.length; j < lenj; j++) {
                if (list[k].relatingObject === dataObject) {
                  // Splice j from related.relating[type]
                  list[j] = list[j];
                }
              }
            }
          }
        }
      }
      // if (dataObject.parent) {
      //     const objects = dataObject.parent.objects;
      //     objects.length--;
      //     let f = false;
      //     for (let i = 0, len = objects.length; i < len; i++) {
      //         if (f || (f = objects[i] === dataObject)) {
      //             objects[i] = objects[i + 1];
      //         }
      //     }
      // }
    }

    _classPrivateFieldLooseBase(this, _destroyed$1)[_destroyed$1] = true;
    this.onBuilt.clear();
    _Component.prototype.destroy.call(this);
  };
  return DataModel;
}(Component);
function _removeObjectFromModels2(dataObject) {
  for (var i = 0, len = dataObject.models.length; i < len; i++) {
    if (dataObject.models[i] === this) {
      dataObject.models = dataObject.models.splice(i, 1);
      break;
    }
  }
}

/**
 * An entity-relationship semantic data model.
 *
 * See {@link "@xeokit/data"} for usage.
 */
var Data = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Data, _Component);
  /**
   * Creates a new Data.
   *
   * See {@link "@xeokit/data"} for usage.
   */
  function Data() {
    var _this;
    _this = _Component.call(this, null, {}) || this;
    /**
     * The {@link @xeokit/data!DataModel | DataModels} belonging to this Data, each keyed to
     * its {@link @xeokit/data!DataModel.id | DataModel.id}.
     */
    _this.models = void 0;
    /**
     * The{@link @xeokit/data!PropertySet | PropertySets} belonging to this Data, mapped to{@link @xeokit/data!PropertySet.id | PropertySet.id}.
     */
    _this.propertySets = void 0;
    /**
     * The {@link @xeokit/data!DataObject | DataObjects} in this Data, mapped to {@link @xeokit/data!DataObject.id | DataObject.id}.
     */
    _this.objects = void 0;
    /**
     * The root {@link @xeokit/data!DataObject | DataObjects} belonging to this Data, each keyed to its {@link @xeokit/data!DataObject.id | DataObject.id}.
     *
     * * This is the set of DataObjects in the DataModels within this Data that are not the *related* participant in
     * any {@link @xeokit/data!Relationship | Relationships}, where they have no incoming Relationships and
     * their {@link @xeokit/data!DataObject.relating} property is empty.
     */
    _this.rootObjects = void 0;
    /**
     * The {@link @xeokit/data!DataObject | DataObjects} belonging to this Data, each map keyed to {@link @xeokit/data!DataObject.type | DataObject.type},
     * containing {@link @xeokit/data!DataObject | DataObjects} keyed to {@link @xeokit/data!DataObject.id | DataObject.id}.
     */
    _this.objectsByType = void 0;
    /**
     * Tracks number of {@link @xeokit/data!DataObject | DataObjects} of each type in this Data.
     */
    _this.typeCounts = void 0;
    /**
     * Emits an event each time a {@link @xeokit/data!DataModel} has been created in this Data.
     *
     * @event
     */
    _this.onModelCreated = void 0;
    /**
     * Emits an event each time a {@link @xeokit/data!DataModel} has been destroyed within this Data.
     *
     * @event
     */
    _this.onModelDestroyed = void 0;
    /**
     * Emits an event each time a {@link @xeokit/data!DataObject} is created within this Data.
     *
     * @event
     */
    _this.onObjectCreated = void 0;
    /**
     * Emits an event each time a {@link @xeokit/data!DataObject} is destroyed within this Data.
     *
     * @event
     */
    _this.onObjectDestroyed = void 0;
    _this.models = {};
    _this.propertySets = {};
    _this.objects = {};
    _this.rootObjects = {};
    _this.objectsByType = {};
    _this.typeCounts = {};
    _this.onModelCreated = new EventEmitter(new dist.EventDispatcher());
    _this.onModelDestroyed = new EventEmitter(new dist.EventDispatcher());
    _this.onObjectCreated = new EventEmitter(new dist.EventDispatcher());
    _this.onObjectDestroyed = new EventEmitter(new dist.EventDispatcher());
    return _this;
  }
  /**
   * Creates a new {@link @xeokit/data!DataModel} in this Data.
   *
   * Remember to call {@link @xeokit/data!DataModel.build | DataModel.build} when you've finished building or loading the DataModel. That will
   * fire events via {@link @xeokit/data!Data.onModelCreated | Data.onModelCreated} and {@link @xeokit/data!DataModel.onBuilt | DataModel.onBuilt}, to
   * indicate to any subscribers that the DataModel is built and ready for use.
   *
   * Note that while we're building/loading the SceneModel, each call that we make to {@link @xeokit/data!DataModel.createObject | DataModel.createObject}
   * will create a new {@link @xeokit/data!DataObject}
   * in {@link @xeokit/data!Data.objects | Data.objects} and {@link @xeokit/data!DataModel.objects | DataModel.objects}, and will also fire an event
   * via {@link @xeokit/data!Data.onObjectCreated | Data.onObjectCreated}. However,
   * only when we've received the {@link @xeokit/data!Data.onModelCreated | Data.onModelCreated} and {@link @xeokit/data!DataModel.onBuilt | DataModel.onBuilt}
   * events can we actually consider the DataModel to be fully constructed.
   *
   * See {@link "@xeokit/data"} for more details on usage.
   *
   * @param  dataModelParams Creation parameters for the new {@link @xeokit/data!DataModel}.
   * @param [options] Options for creating the {@link @xeokit/data!DataModel}.
   * @param [options.includeTypes] When provided, only create {@link @xeokit/data!DataObject | DataObjects} with types in this list.
   * @param  [options.excludeRelating] When provided, never create {@link @xeokit/data!DataObject | DataObjects} with types in this list.
   * @returns {@link @xeokit/data!DataModel}
   * * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * This Data has already been destroyed.
   * * A DataModel with the given ID already exists in this Data.
   */
  var _proto = Data.prototype;
  _proto.createModel = function createModel(dataModelParams, options) {
    var _this2 = this;
    if (this.destroyed) {
      return new SDKError("Data already destroyed");
    }
    var id = dataModelParams.id;
    if (this.models[id]) {
      return new SDKError("DataModel already created in this Data: " + id);
    }
    // @ts-ignore
    var dataModel = new DataModel(this, id, dataModelParams, options);
    this.models[dataModel.id] = dataModel;
    dataModel.onDestroyed.one(function () {
      delete _this2.models[dataModel.id];
      _this2.onModelDestroyed.dispatch(_this2, dataModel);
    });
    dataModel.onBuilt.one(function () {
      _this2.onModelCreated.dispatch(_this2, dataModel);
    });
    return dataModel;
  }
  /**
   * Gets the {@link @xeokit/data!DataObject.id}s of the {@link DataObject | DataObjects} that have the given {@link DataObject.type}.
   *
   * See {@link "@xeokit/data"} for usage.
   *
   * @param type The type.
   * @returns {string[]}
   * * Array of {@link DataObject.id}s on success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * This Data has already been destroyed.
   */;
  _proto.getObjectIdsByType = function getObjectIdsByType(type) {
    if (this.destroyed) {
      return new SDKError("Data already destroyed");
    }
    var objects = this.objectsByType[type];
    return objects ? Object.keys(objects) : [];
  }
  /**
   * Finds {@link DataObject | DataObjects} using a customized depth-first traversal.
   *
   * Usually we use this method to recursively find DataObjects of specific {@link DataObject.type | types} within
   * a hierarchy.
   *
   * See {@link "@xeokit/data"} for usage.
   *
   * @param searchParams Search parameters.
   * @returns *void*
   * * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * This Data has already been destroyed.
   * * The specified starting DataObject was not found in this Data.
   * * The specified starting DataObject is contained in a different Data than this one.
   */;
  _proto.searchObjects = function searchObjects(searchParams) {
    if (this.destroyed) {
      return new SDKError("Data already destroyed");
    }
    var includeObjects = searchParams.includeObjects && searchParams.includeObjects.length > 0 ? arrayToMap(searchParams.includeObjects) : null;
    var excludeObjects = searchParams.excludeObjects && searchParams.excludeObjects.length > 0 ? arrayToMap(searchParams.excludeObjects) : null;
    var includeRelating = searchParams.includeRelating && searchParams.includeRelating.length > 0 ? arrayToMap(searchParams.includeRelating) : null;
    var excludeRelating = searchParams.excludeRelating && searchParams.excludeRelating.length > 0 ? arrayToMap(searchParams.excludeRelating) : null;
    function visit(dataObject, depth) {
      if (!dataObject) {
        return;
      }
      var includeObject = true;
      if (excludeObjects && excludeObjects[dataObject.type]) {
        includeObject = false;
      } else {
        // @ts-ignore
        if (includeObjects && !includeObjects[dataObject.type]) {
          includeObject = false;
        }
      }
      if (depth === 0 && searchParams.includeStart === false) {
        includeObject = false;
      }
      if (includeObject) {
        if (searchParams.resultObjectIds) {
          searchParams.resultObjectIds.push(dataObject.id);
        } else if (searchParams.resultObjects) {
          searchParams.resultObjects.push(dataObject);
        } else if (searchParams.resultCallback) {
          if (searchParams.resultCallback(dataObject)) ;
        }
      }
      var related = dataObject.related;
      for (var type in related) {
        var relations = related[type];
        if (relations) {
          for (var i = 0, len = relations.length; i < len; i++) {
            var includeRelation = true;
            if (excludeRelating && excludeRelating[dataObject.type]) {
              includeRelation = false;
            } else {
              if (includeRelating && !includeRelating[dataObject.type]) {
                includeRelation = false;
              }
            }
            if (includeRelation) {
              visit(relations[i].relatedObject, depth + 1);
            }
          }
        }
      }
    }
    var depth = 0;
    if (searchParams.startObjectId) {
      var startObject = this.objects[searchParams.startObjectId];
      if (!startObject) {
        return new SDKError("Failed to search DataObjects - starting DataObject not found in Data: \"" + searchParams.startObjectId + "\"");
      }
      visit(startObject, depth);
    } else if (searchParams.startObject) {
      if (searchParams.startObject.data != this) {
        return new SDKError("Failed to search DataObjects - starting DataObject not in same Data: \"" + searchParams.startObjectId + "\"");
      }
      visit(searchParams.startObject, depth + 1);
    } else {
      for (var id in this.rootObjects) {
        visit(this.rootObjects[id], depth + 1);
      }
    }
  }
  /**
   * Destroys all contained {@link DataModel | DataModels}.
   *
   * * Fires {@link Data.onModelDestroyed | Data.onModelDestroyed} and {@link DataModel.onDestroyed | DataModel.onDestroyed}
   * for each existing DataModel in this Data.
   *
   * See {@link "@xeokit/data"} for usage.
   *
   * @returns *void*
   * * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * This Data has already been destroyed.
   */;
  _proto.clear = function clear() {
    if (this.destroyed) {
      return new SDKError("Data already destroyed");
    }
    for (var id in this.models) {
      this.models[id].destroy();
    }
  }
  /**
   * Destroys this Data and all contained {@link DataModel | DataModels}.
   *
   * * Fires {@link Data.onModelDestroyed | Data.onModelDestroyed} and {@link DataModel.onDestroyed | DataModel.onDestroyed}
   * for each existing DataModels in this Data.
   * * Unsubscribes all subscribers to {@link Data.onModelCreated | Data.onModelCreated}, {@link Data.onModelDestroyed | Data.onModelDestroyed}, {@link DataModel.onDestroyed | DataModel.onDestroyed}
   *
   * See {@link "@xeokit/data"} for usage.
   *
   * @returns *void*
   * * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * This Data has already been destroyed.
   */;
  _proto.destroy = function destroy() {
    if (this.destroyed) {
      return new SDKError("Data already destroyed");
    }
    this.clear();
    this.onModelCreated.clear();
    this.onModelDestroyed.clear();
    _Component.prototype.destroy.call(this);
  };
  return Data;
}(Component);
function arrayToMap(array) {
  var map = {};
  for (var i = 0, len = array.length; i < len; i++) {
    map[array[i]] = true;
  }
  return map;
}

/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2Fdata.svg)](https://badge.fury.io/js/%40xeokit%2Fdata)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/data/badge)](https://www.jsdelivr.com/package/npm/@xeokit/data)
 *
 * <img style="padding:50px" src="media://images/xeokit_datamodel_icon.png"/>
 *
 * # xeokit Semantic Data Model
 *
 * ---
 *
 * ### *The SDK's buildable, queryable, importable and exportable semantic data model*
 *
 * ---
 *
 * The xeokit SDK uses a generic entity-relationship data graph to manage model semantics. This graph includes entities,
 * properties, and relationships and is compatible with both the browser and NodeJS. It serves as a versatile tool for generating
 * models, converting between model formats, and navigating content within the model viewer.
 *
 * In more detail, the xeokit SDK provides a {@link @xeokit/data!Data | Data} container class that holds
 * {@link @xeokit/data!DataModel | DataModels} consisting of {@link @xeokit/data!DataObject | DataObjects},
 * {@link @xeokit/data!PropertySet | PropertySets}, and
 * {@link @xeokit/data!Relationship | Relationships}, as shown in the diagram below.
 *
 * <br>
 *
 * [![](https://mermaid.ink/img/pako:eNqNVMFunDAU_BX0Tu1qgxaW9QLnHBOlSm4VFwc7WVeAkTFV6Wr_vcZmu89A0nIBzxvPmzdGPkMpGYccyop23b2g74rWRcOE4qUWsgkenosmsI9lBPdU0_MVcrjiVPNHI1N9-epVOk5VeXp6_WG0ulmtrExxhtWjRudB0m32sFbJlis9vHC_cP2-LB1bd9i2YGixbLLewk3q5sHWHf7MKzpG1p1Eu6x-uyni4msvKoYBxjut5HCDVqZxDrxT8OYJ9NByvF4bZ6aL_CFhLDuJCP4viQAJNLRGTn7SqkdLbHOmhcPEev5kyrKadxfIDOfMh_92GCMMCogK2NzdmXcYbgq4_SaYZoF1ri_-seaS5xDD3kzsnWOjI_hA9hPWwuk61cvVCl7JN2f5eqz_v3WePPKxzOhanMiwhZqrmgpmLiV78AXoEzd_EeTmk_E32le6gKK5GCrttXwZmhJyrXq-hb5lpv10jUH-RqvOoC1tID_DL8hjEoVRdDxEJE73GSHZYQuDgeMwyY7kkGTRMSbp_nDZwm8pjcIuTGOSJGS_yxKSpjvD50xoqR6na3N82Q7fLX-0cfkD0IeHkg?type=png)](https://mermaid.live/edit#pako:eNqNVMFunDAU_BX0Tu1qgxaW9QLnHBOlSm4VFwc7WVeAkTFV6Wr_vcZmu89A0nIBzxvPmzdGPkMpGYccyop23b2g74rWRcOE4qUWsgkenosmsI9lBPdU0_MVcrjiVPNHI1N9-epVOk5VeXp6_WG0ulmtrExxhtWjRudB0m32sFbJlis9vHC_cP2-LB1bd9i2YGixbLLewk3q5sHWHf7MKzpG1p1Eu6x-uyni4msvKoYBxjut5HCDVqZxDrxT8OYJ9NByvF4bZ6aL_CFhLDuJCP4viQAJNLRGTn7SqkdLbHOmhcPEev5kyrKadxfIDOfMh_92GCMMCogK2NzdmXcYbgq4_SaYZoF1ri_-seaS5xDD3kzsnWOjI_hA9hPWwuk61cvVCl7JN2f5eqz_v3WePPKxzOhanMiwhZqrmgpmLiV78AXoEzd_EeTmk_E32le6gKK5GCrttXwZmhJyrXq-hb5lpv10jUH-RqvOoC1tID_DL8hjEoVRdDxEJE73GSHZYQuDgeMwyY7kkGTRMSbp_nDZwm8pjcIuTGOSJGS_yxKSpjvD50xoqR6na3N82Q7fLX-0cfkD0IeHkg)
 *
 * Various model file formats can be imported into DataModels using methods such as {@link @xeokit/gltf!loadGLTF}, {@link @xeokit/las!loadLAS},
 * {@link @xeokit/cityjson!loadCityJSON}, and {@link @xeokit/xkt!loadXKT},
 * while DataModels can be exported to the native [XKT](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#xkt) format using {@link @xeokit/xkt!saveXKT}.
 *
 * To programmatically build DataModels, builder methods
 * such as {@link @xeokit/data!Data.createModel | Data.createModel}, {@link @xeokit/data!DataModel.createObject | DataModel.createObject},
 * {@link @xeokit/data!DataModel.createPropertySet | DataModel.createPropertySet}, and
 * {@link @xeokit/data!DataModel.createRelationship | DataModel.createRelationship} can be employed.
 * DataObjects can be queried using the {@link @xeokit/data!Data.searchObjects | Data.searchObjects} method, and
 * semantic data can be attached to model representations by
 * using it alongside SceneModel.
 *
 * It's important to note that DataObjects and PropertySets are global, created on their DataModels but stored globally
 * on the Data. Additionally, DataModels automatically reuse DataObjects and PropertySets wherever they're already
 * created by other DataModels. Finally, DataObjects can have Relationships with other DataObjects in different DataModels.
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/data
 * ````
 *
 * ## Usage
 *
 * * [Creating a DataModel from JSON](#creating-a-scenemodel)
 * * [Creating a DataModel using Builder Methods](#creating-a-scenemodel)
 * * [Reading DataObjects](#reading-dataobjects)
 * * [Searching DataObjects](#searching-dataobjects)
 *
 * ### Creating a DataModel from JSON
 *
 * We will start with an example where we create a {@link @xeokit/data!DataModel} using a single parameter object of type {@link @xeokit/data!DataModelParams}.
 * The DataModel we create will define a simple piece of furniture - a table consisting of a tabletop and four legs.
 * We will then query the data model to retrieve all the {@link @xeokit/data!DataObject | DataObjects} within it.
 *
 * To achieve this, we will create a DataModel that contains six DataObjects: one for the
 * table, one for the tabletop, and one for each of the four legs. We will also define Relationships
 * to connect the DataObjects into an aggregation hierarchy, and we will assign {@link Property | Properties} to the
 * DataObjects to give them attributes such as height and weight.
 *
 * To give the DataObjects and {@link @xeokit/data!Relationship | Relationships} semantic meaning, we will assign
 * them types from one of the SDK's bundled data type sets, basicTypes. This set of types classifies each DataObject
 * as a {@link @xeokit/basictypes!BasicEntity | BasicEntity} and each Relationship as
 * a {@link @xeokit/basictypes!BasicAggregation | BasicAggregation}.
 *
 * It's worth noting that in a real-world scenario, we would likely use a more complex set of data types, such as
 * {@link @xeokit/ifctypes}. However, we cannot mix different sets of data types within our {@link @xeokit/data!Data},
 * as traversals of the DataObjects with {@link @xeokit/data!Data.searchObjects | Data.searchObjects } must be
 * guided uniformly by the same set of types across all the DataObjects and Relationships in the graph.
 *
 * To create our DataModel, we will use the following code, which creates a new Data object and then
 * creates a DataModel from a set of objects, relationships, and property sets. The {@link @xeokit/core!SDKError} class
 * is used to handle errors that may occur during the process:
 *
 * ````javascript
 * import { SDKError } from "@xeokit/core";
 * import { Data } from "@xeokit/data";
 * import * as basicTypes from "@xeokit/basictypes/basicTypes";
 *
 * const myData = new Data({});
 *
 * const myDataModel = myData.createModel({
 *   id: "myTableModel",
 *   objects: [
 *     {
 *       id: "table",
 *       type: basicTypes.BasicEntity,
 *       name: "Table",
 *       propertySetIds: ["tablePropertySet"],
 *     },
 *     {
 *       id: "redLeg",
 *       name: "Red table Leg",
 *       type: basicTypes.BasicEntity,
 *       propertySetIds: ["legPropertySet"],
 *     },
 *     {
 *       id: "greenLeg",
 *       name: "Green table leg",
 *       type: basicTypes.BasicEntity,
 *       propertySetIds: ["legPropertySet"],
 *     },
 *     {
 *       id: "blueLeg",
 *       name: "Blue table leg",
 *       type: basicTypes.BasicEntity,
 *       propertySetIds: ["legPropertySet"],
 *     },
 *     {
 *       id: "yellowLeg",
 *       name: "Yellow table leg",
 *       type: basicTypes.BasicEntity,
 *       propertySetIds: ["legPropertySet"],
 *     },
 *     {
 *       id: "tableTop",
 *       name: "Purple table top",
 *       type: basicTypes.BasicEntity,
 *       propertySetIds: ["tableTopPropertySet"],
 *     },
 *   ],
 *   relationships: [
 *     {
 *       type: basicTypes.BasicAggregation,
 *       relatingObjectId: "table",
 *       relatedObjectId: "tableTop",
 *     },
 *     {
 *       type: basicTypes.BasicAggregation,
 *       relatingObjectId: "tableTop",
 *       relatedObjectId: "redLeg",
 *     },
 *     {
 *       type: basicTypes.BasicAggregation,
 *       relatingObjectId: "tableTop",
 *       relatedObjectId: "greenLeg",
 *     },
 *     {
 *       type: basicTypes.BasicAggregation,
 *       relatingObjectId: "tableTop",
 *       relatedObjectId: "blueLeg",
 *     },
 *     {
 *       type: basicTypes.BasicAggregation,
 *       relatingObjectId: "tableTop",
 *       relatedObjectId: "yellowLeg",
 *     },
 *   ],
 *   propertySets: [
 *     {
 *       id: "tablePropertySet",
 *       originalSystemId: "tablePropertySet",
 *       name: "Table properties",
 *       type: "",
 *       properties: [
 *         {
 *           name: "Weight",
 *           value: 5,
 *           type: "",
 *           valueType: "",
 *           description: "Weight of the thing",
 *         },
 *         {
 *           name: "Height",
 *           value: 12,
 *           type: "",
 *           valueType: "",
 *           description: "Height of the thing",
 *         },
 *       ],
 *     },
 *     {
 *       id: "legPropertySet",
 *       originalSystemId: "legPropertySet",
 *       name: "Table leg properties",
 *       type: "",
 *       properties: [
 *         {
 *           name: "Weight",
 *           value: 5,
 *           type: "",
 *           valueType: "",
 *           description: "Weight of the thing",
 *         },
 *         {
 *           name: "Height",
 *           value: 12,
 *           type: "",
 *           valueType: "",
 *           description: "Height of the thing",
 *         },
 *       ],
 *     },
 *   ],
 * });
 *
 * if (myDataModel instanceof SDKError) {
 *   console.log(myDataModel.message);
 * } else {
 *   myDataModel.build();
 * }
 * ````
 *
 * ### Creating a DataModel using Builder Methods
 *
 * In our second example, we'll create our {@link @xeokit/data!DataModel} again, this time instantiating
 * each {@link @xeokit/data!PropertySet}, {@link Property}, {@link @xeokit/data!DataObject} and {@link @xeokit/data!Relationship} individually, using the
 * {@link @xeokit/data!DataModel | DataModel's} builder methods.
 *
 * ````javascript
 * import {SDKError} from "@xeokit/core";
 * import {Data} from "@xeokit/data";
 * import * as basicTypes from "@xeokit/basictypes/basicTypes";
 *
 * const data = new Data();
 *
 * const dataModel = data.createModel({ // DataModel | SDKError
 *     id: "myTableModel"
 * });
 *
 * if (dataModel instanceof SDKError) {
 *      console.log(dataModel.message);
 *
 * } else {
 *
 *      const tablePropertySet = dataModel.createPropertySet({ // PropertySet | SDKError
 *          id: "tablePropertySet",
 *          name: "Table properties",
 *          type: "",
 *          properties: [ // Property[]
 *              {
 *                  name: "Weight",
 *                  value: 5,
 *                  type: "",
 *                  valueType: "",
 *                  description: "Weight of the thing"
 *              },
 *              {
 *                  name: "Height",
 *                  value: 12,
 *                  type: "",
 *                  valueType: "",
 *                  description: "Height of the thing"
 *              }
 *          ]
 *      });
 *
 *      if (tablePropertySet instanceof SDKError) {
 *          console.log(tablePropertySet.message);
 *      }
 *
 *      const legPropertySet = dataModel.createPropertySet({
 *          id: "legPropertySet",
 *          name: "Table leg properties",
 *          type: "",
 *          properties: [
 *              {
 *                  name: "Weight",
 *                  value: 5,
 *                  type: "",
 *                  valueType: "",
 *                  description: "Weight of the thing"
 *              },
 *              {
 *                  name: "Height",
 *                  value: 12,
 *                  type: "",
 *                  valueType: "",
 *                  description: "Height of the thing"
 *              }
 *          ]
 *      });
 *
 *      const myTableObject = dataModel.createObject({ // DataObject | SDKError
 *          id: "table",
 *          type:  basicTypes.BasicEntity,
 *          name: "Table",
 *          propertySetIds: ["tablePropertySet"]
 *      });
 *
 *      if (myTableObject instanceof SDKError) {
 *          console.log(myTableObject.message);
 *      }
 *
 *      dataModel.createObject({
 *          id: "redLeg",
 *          name: "Red table Leg",
 *          type:  basicTypes.BasicEntity,
 *          propertySetIds: ["tableLegPropertySet"]
 *      });
 *
 *      dataModel.createObject({
 *          id: "greenLeg",
 *          name: "Green table leg",
 *          type:  basicTypes.BasicEntity,
 *          propertySetIds: ["tableLegPropertySet"]
 *      });
 *
 *      dataModel.createObject({
 *          id: "blueLeg",
 *          name: "Blue table leg",
 *          type:  basicTypes.BasicEntity,
 *          propertySetIds: ["tableLegPropertySet"]
 *      });
 *
 *      dataModel.createObject({
 *          id: "yellowLeg",
 *          name: "Yellow table leg",
 *          type: "leg",
 *          propertySetIds: ["tableLegPropertySet"]
 *      });
 *
 *      dataModel.createObject({
 *          id: "tableTop",
 *          name: "Purple table top",
 *          type:  basicTypes.BasicEntity,
 *          propertySetIds: ["tableTopPropertySet"]
 *      });
 *
 *      const myRelationship = dataModel.createRelationship({
 *          type: basicTypes.BasicAggregation,
 *          relatingObjectId: "table",
 *          relatedObjectId: "tableTop"
 *      });
 *
 *      if (myRelationship instanceof SDKError) {
 *              console.log(myRelationship.message);
 *      }
 *
 *      dataModel.createRelationship({
 *          type: basicTypes.BasicAggregation,
 *          relatingObjectId: "tableTop",
 *          relatedObjectId: "redLeg"
 *      });
 *
 *      dataModel.createRelationship({
 *          type: basicTypes.BasicAggregation,
 *          relatingObjectId: "tableTop",
 *          relatedObjectId: "greenLeg"
 *      });
 *
 *      dataModel.createRelationship({
 *          type: basicTypes.BasicAggregation,
 *          relatingObjectId: "tableTop",
 *          relatedObjectId: "blueLeg"
 *      });
 *
 *      dataModel.createRelationship({
 *          type: basicTypes.BasicAggregation,
 *          relatingObjectId: "tableTop",
 *          relatedObjectId: "yellowLeg"
 *      });
 *
 *      dataModel.build()
 *          .then(()=>{
 *              // Ready for action
 *          })
 *          .catch((sdkError) => {
 *              console.error(sdkError.message);
 *          });
 * }
 * ````
 *
 * ### Reading DataObjects
 *
 * With our {@link @xeokit/scene!SceneModel} built, we'll now use the {@link @xeokit/data!Data.searchObjects} method to
 * traverse it to fetch the IDs of the {@link @xeokit/data!DataObject | DataObjects} we find on that path.
 *
 * One example of where we use this method is to query the aggregation hierarchy of the DataObjects for building
 * a tree view of an IFC element hierarchy.
 *
 * ````javascript
 * const resultObjectIds = [];
 *
 * data.searchObjects({
 *     startObjectId: "table",
 *     includeObjects: [basicTypes.BasicEntity],
 *     includeRelated: [basicTypes.BasicAggregation],
 *     resultObjectIds
 * });
 *
 * // resultObjectIds == ["table", "tableTop", "redLeg", "greenLeg", "blueLeg", "yellowLeg"];
 * ````
 *
 * ### Searching DataObjects
 *
 * In our fourth example, we'll demonstrate how to traverse the {@link @xeokit/data!DataObject | DataObjects} along their
 * {@link @xeokit/data!Relationship | Relationships}. We'll start at the root DataObject and visit all the DataObjects
 * we encounter along the outgoing Relationships.
 *
 * ````javascript
 * const table = data.objects["table"];
 *
 * const relations = table.related[basicTypes.BasicAggregation];
 *
 * for (let i = 0, len = relations.length; i < len; i++) {
 *
 *      const relation = relations[i];
 *      const dataObject = relation.related;
 *
 *      //..
 * }
 * ````
 *
 * @module @xeokit/data
 */

var index$c = {
  __proto__: null,
  Data: Data,
  DataModel: DataModel,
  DataObject: DataObject,
  Relationship: Relationship,
  Property: Property,
  PropertySet: PropertySet
};

/**
 * A geometry bucket within {@link @xeokit/scene!Geometry.geometryBuckets | Geometry.geometryBuckets}.
 *
 * See usage in:
 *
 * * [@xeokit/scene](/docs/modules/_xeokit_scene.html)
 * * [@xeokit/viewer](/docs/modules/_xeokit_viewer.html)
 */
var GeometryBucket = function GeometryBucket(geometryBucketParams) {
  /**
   * GeometryBucket's 3D vertex positions, quantized as 16-bit integers.
   *
   * Internally, the Viewer dequantizes these with {@link @xeokit/scene!Geometry.positionsDecompressMatrix | Geometry.positionsDecompressMatrix}.
   *
   * Vertex positions are required for all primitive types.
   */
  this.positionsCompressed = void 0;
  /**
   * GeometryBucket's UV coordinates, quantized as 16-bit integers.
   *
   * Internally, the Viewer de-quantizes these with {@link @xeokit/scene!Geometry.uvsDecompressMatrix | Geometry.uvsDecompressMatrix}.
   */
  this.uvsCompressed = void 0;
  /**
   * GeometryBucket's vertex RGB colors, quantized as 8-bit integers.
   */
  this.colorsCompressed = void 0;
  /**
   * GeometryBucket's primitive indices.
   *
   * This is either an array of 8-bit, 16-bit or 32-bit values.
   */
  this.indices = void 0;
  /**
   * GeometryBucket's edge indices.
   *
   * This is either an array of 8-bit, 16-bit or 32-bit values.
   */
  this.edgeIndices = void 0;
  this.positionsCompressed = geometryBucketParams.positionsCompressed;
  this.uvsCompressed = geometryBucketParams.uvsCompressed;
  this.colorsCompressed = geometryBucketParams.colorsCompressed;
  this.indices = geometryBucketParams.indices;
  this.edgeIndices = geometryBucketParams.edgeIndices;
};

/**
 * A geometry in a {@link @xeokit/scene!SceneModel}.
 *
 * * Stored in {@link @xeokit/scene!SceneModel.geometries | SceneModel.geometries}
 * * Created with {@link @xeokit/scene!SceneModel.createGeometry | SceneModel.createGeometry}
 * and {@link @xeokit/scene!SceneModel.createGeometryCompressed | SceneModel.createGeometryCompressed}
 * * Referenced by {@link @xeokit/scene!Mesh.geometry | Mesh.geometry}
 *
 * See {@link "@xeokit/scene"} for usage.
 */
var Geometry = function Geometry(params) {
  /**
   * ID for the geometry.
   */
  this.id = void 0;
  /**
   * Primitive type.
   *
   * Possible values are {@link @xeokit/constants!SolidPrimitive}, {@link @xeokit/constants!SurfacePrimitive},
   * {@link @xeokit/constants!LinesPrimitive}, {@link @xeokit/constants!PointsPrimitive}
   * and {@link @xeokit/constants!TrianglesPrimitive}.
   */
  this.primitive = void 0;
  /**
   * Matrix to decompress {@link @xeokit/scene!GeometryBucketParams.positionsCompressed}.
   */
  this.positionsDecompressMatrix = void 0;
  /**
   * Axis-aligned, non-quantized 3D boundary of the geometry's vertex positions.
   */
  this.aabb = void 0;
  /**
   * 4x4 matrix to de-quantize the geometry's UV coordinates, when UVs are provided.
   */
  this.uvsDecompressMatrix = void 0;
  /**
   * The geometry arrays, organized into buckets for optimal memory use.
   *
   * The bucketing strategy aims to reduce memory consumed by indices. There are three buckets, each with an indices array that
   * requires a different number of bits for its values. The first bucket's indices contain 8-bit values in range [0...255],
   * the second contains 16-bit values in range ````[256..65535]````, and the third contains 32-bit values in
   * range ````[65536...2147483647]````. With this strategy, we avoid wasting storage bits on the 8-bit and 16-bit values.
   *
   * The buckets also partition the geometry positions and UVs, so that the indices are indexing positions and UVs
   * that are local to their bucket. This further optimizes memory use, by reducing the values of large indices to small
   * locally-offset values, which can reduce the number of bits they need.
   */
  this.geometryBuckets = void 0;
  /**
   * Interface through which this Geometry can load any user-updated geometry arrays into the renderer.
   *
   * @internal
   */
  this.rendererGeometry = void 0;
  this.geometryBuckets = [];
  for (var i = 0, len = params.geometryBuckets.length; i < len; i++) {
    this.geometryBuckets[i] = new GeometryBucket(params.geometryBuckets[i]);
  }
  this.id = params.id;
  this.positionsDecompressMatrix = params.positionsDecompressMatrix;
  this.primitive = params.primitive;
};

var _positionsDecompressed = /*#__PURE__*/_classPrivateFieldLooseKey("positionsDecompressed");
var _positionsWorld = /*#__PURE__*/_classPrivateFieldLooseKey("positionsWorld");
var GeometryViewImpl = /*#__PURE__*/function () {
  function GeometryViewImpl() {
    this.object = void 0;
    this.mesh = void 0;
    this.meshIndex = void 0;
    this.geometry = void 0;
    this.geometryBucket = void 0;
    this.geometryBucketIndex = void 0;
    Object.defineProperty(this, _positionsDecompressed, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _positionsWorld, {
      writable: true,
      value: void 0
    });
    this.object = null;
    this.mesh = null;
    this.meshIndex = 0;
    this.geometry = null;
    this.geometryBucket = null;
    this.geometryBucketIndex = 0;
    _classPrivateFieldLooseBase(this, _positionsDecompressed)[_positionsDecompressed] = null;
    _classPrivateFieldLooseBase(this, _positionsWorld)[_positionsWorld] = null;
  }
  var _proto = GeometryViewImpl.prototype;
  _proto.reset = function reset() {
    _classPrivateFieldLooseBase(this, _positionsDecompressed)[_positionsDecompressed] = null;
    _classPrivateFieldLooseBase(this, _positionsWorld)[_positionsWorld] = null;
  };
  _createClass(GeometryViewImpl, [{
    key: "totalGeometryBuckets",
    get: function get() {
      var totalGeometryBuckets = 0;
      if (this.object) {
        for (var i = 0, len = this.object.meshes.length; i < len; i++) {
          totalGeometryBuckets += this.object.meshes[i].geometry.geometryBuckets.length;
        }
      }
      return totalGeometryBuckets;
    }
  }, {
    key: "numPrimitives",
    get: function get() {
      var primitiveType = this.geometry.primitive;
      var elementsPerPrimitiveType = primitiveType === TrianglesPrimitive ? 3 : primitiveType === LinesPrimitive ? 2 : 1;
      return this.geometryBucket.indices.length / elementsPerPrimitiveType;
    }
  }, {
    key: "positionsDecompressed",
    get: function get() {
      if (!_classPrivateFieldLooseBase(this, _positionsDecompressed)[_positionsDecompressed]) {
        _classPrivateFieldLooseBase(this, _positionsDecompressed)[_positionsDecompressed] = new Float32Array(this.geometryBucket.positionsCompressed.length);
        decompressPositions3(this.geometryBucket.positionsCompressed, this.geometry.positionsDecompressMatrix, _classPrivateFieldLooseBase(this, _positionsDecompressed)[_positionsDecompressed]);
      }
      return _classPrivateFieldLooseBase(this, _positionsDecompressed)[_positionsDecompressed];
    }
  }, {
    key: "positionsWorld",
    get: function get() {
      if (!_classPrivateFieldLooseBase(this, _positionsWorld)[_positionsWorld]) {
        var positionsDecompressed = this.positionsDecompressed;
        _classPrivateFieldLooseBase(this, _positionsWorld)[_positionsWorld] = new Float64Array(positionsDecompressed.length);
        transformPositions3(positionsDecompressed, this.mesh.matrix, _classPrivateFieldLooseBase(this, _positionsWorld)[_positionsWorld]);
      }
      return _classPrivateFieldLooseBase(this, _positionsWorld)[_positionsWorld];
    }
  }, {
    key: "uvsDecompressed",
    get: function get() {
      return null;
    }
  }]);
  return GeometryViewImpl;
}();
var geometryView = new GeometryViewImpl();
/**
 * Gets the uncompressed, World-space geometry of each {@link @xeokit/scene!GeometryBucket} in each
 * {@link @xeokit/scene!Geometry} in each {@link @xeokit/scene!Mesh} in a {@link @xeokit/scene!SceneObject}.
 *
 * If the callback returns ````true````, then this method immediately stops iterating and also returns ````true````.
 *
 * @param sceneObject
 * @param withEachGeometry
 */
function getSceneObjectGeometry(sceneObject, withEachGeometry) {
  geometryView.reset();
  geometryView.object = sceneObject;
  for (var i = 0, len = sceneObject.meshes.length; i < len; i++) {
    var mesh = sceneObject.meshes[i];
    geometryView.mesh = mesh;
    geometryView.meshIndex = i;
    var geometry = mesh.geometry;
    geometryView.geometry = geometry;
    for (var j = 0, lenj = geometry.geometryBuckets.length; j < lenj; j++) {
      geometryView.geometryBucket = geometry.geometryBuckets[j];
      geometryView.geometryBucketIndex = j;
      if (withEachGeometry(geometryView)) {
        return true;
      }
    }
  }
  return false;
}

/**
 * An object in a {@link @xeokit/scene!SceneModel}.
 *
 * * Stored in {@link @xeokit/scene!SceneModel.objects | SceneModel.objects} and {@link @xeokit/scene!Scene.objects | Scene.objects}
 * * Created with {@link @xeokit/scene!SceneModel.createObject | SceneModel.createObject}
 *
 * See {@link "@xeokit/scene"} for usage.
 */
var _aabb$1 = /*#__PURE__*/_classPrivateFieldLooseKey("aabb");
var _aabbDirty$1 = /*#__PURE__*/_classPrivateFieldLooseKey("aabbDirty");
var SceneObject = /*#__PURE__*/function () {
  /**
   * @private
   */
  function SceneObject(cfg) {
    /**
     * The {@link @xeokit/scene!SceneModel} that contains this SceneObject.
     */
    this.model = void 0;
    /**
     * Unique ID of this SceneObject.
     *
     * SceneObjects are stored by ID in {@link @xeokit/scene!Scene.objects | Scene.objects}
     * and {@link @xeokit/scene!SceneModel.objects | SceneModel.objects}.
     */
    this.id = void 0;
    /**
     * The {@link @xeokit/scene!Mesh | Meshes} belonging to this SceneObject.
     */
    this.meshes = void 0;
    /**
     * Optional layer ID for this SceneObject.
     */
    this.layerId = void 0;
    /**
     *  Internal interface through which a {@link @xeokit/scene!SceneObject} can load property updates into a renderer.
     *
     *  This is defined while the owner {@link @xeokit/scene!SceneModel} has been added to a {@link @xeokit/viewer!Viewer | Viewer}.
     *
     * @internal
     */
    this.rendererObject = void 0;
    Object.defineProperty(this, _aabb$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _aabbDirty$1, {
      writable: true,
      value: void 0
    });
    this.id = cfg.id;
    this.layerId = cfg.layerId;
    this.meshes = cfg.meshes;
    _classPrivateFieldLooseBase(this, _aabb$1)[_aabb$1] = createAABB3();
    _classPrivateFieldLooseBase(this, _aabbDirty$1)[_aabbDirty$1] = true;
    this.rendererObject = null;
  }
  /**
   * Gets the axis-aligned 3D World-space boundary of this SceneObject.
   */
  var _proto = SceneObject.prototype;
  /**
   * @private
   */
  _proto.setAABBDirty = function setAABBDirty() {
    _classPrivateFieldLooseBase(this, _aabbDirty$1)[_aabbDirty$1] = true;
  };
  _createClass(SceneObject, [{
    key: "aabb",
    get: function get() {
      var _this = this;
      if (_classPrivateFieldLooseBase(this, _aabbDirty$1)[_aabbDirty$1]) {
        collapseAABB3(_classPrivateFieldLooseBase(this, _aabb$1)[_aabb$1]);
        getSceneObjectGeometry(this, function (geometryView) {
          expandAABB3Points3(_classPrivateFieldLooseBase(_this, _aabb$1)[_aabb$1], geometryView.positionsWorld);
          return false;
        });
        _classPrivateFieldLooseBase(this, _aabbDirty$1)[_aabbDirty$1] = false;
      }
      return _classPrivateFieldLooseBase(this, _aabb$1)[_aabb$1];
    }
  }]);
  return SceneObject;
}();

/**
 * A set of {@link @xeokit/scene!Texture | Textures} in a {@link @xeokit/scene!SceneModel}.
 *
 * * Stored in {@link @xeokit/scene!SceneModel.textureSets | SceneModel.textureSets}
 * * Created with {@link @xeokit/scene!SceneModel.createTextureSet | SceneModel.createTextureSet}
 * * Referenced by {@link @xeokit/scene!Mesh.textureSet | Mesh.textureSet}
 *
 * See {@link "@xeokit/scene"} for usage.
 */
var TextureSet =
/**
 * @private
 */
function TextureSet(textureSetParams, textures) {
  /**
   * The ID of this TextureSet.
   */
  this.id = void 0;
  /**
   * The color {@link @xeokit/scene!Texture} in this set.
   */
  this.colorTexture = void 0;
  /**
   * The metallic-roughness {@link @xeokit/scene!Texture} in this set.
   */
  this.metallicRoughnessTexture = void 0;
  /**
   * The occlusion {@link @xeokit/scene!Texture} in this set.
   */
  this.occlusionTexture = void 0;
  /**
   * The emissive {@link @xeokit/scene!Texture} in this set.
   */
  this.emissiveTexture = void 0;
  /**
   *  Internal interface through which a TextureSet can load property updates into a renderer.
   *
   *  This is defined while the owner {@link @xeokit/scene!SceneModel} has been added to a {@link @xeokit/viewer!Viewer | Viewer}.
   *
   * @internal
   */
  this.rendererTextureSet = void 0;
  this.id = textureSetParams.id;
  this.colorTexture = textures.colorTexture;
  this.metallicRoughnessTexture = textures.metallicRoughnessTexture;
  this.occlusionTexture = textures.occlusionTexture;
  this.emissiveTexture = textures.emissiveTexture;
  this.rendererTextureSet = null;
};

/**
 * A texture in a {@link @xeokit/scene!SceneModel}.
 *
 * * Stored in {@link @xeokit/scene!SceneModel.textures | SceneModel.textures}
 * * Created with {@link @xeokit/scene!SceneModel.createTexture | SceneModel.createTexture}
 * * Referenced by {@link @xeokit/scene!TextureSet.colorTexture | TextureSet.colorTexture},
 * {@link @xeokit/scene!TextureSet.metallicRoughnessTexture | TextureSet.metallicRoughnessTexture},
 * {@link @xeokit/scene!TextureSet.occlusionTexture | TextureSet.occlusionTexture} and {@link @xeokit/scene!TextureSet.emissiveTexture | TextureSet.emissiveTexture}
 *
 * See {@link "@xeokit/scene"} for usage.
 */
var Texture =
/**
 * @private
 */
function Texture(params) {
  /**
   *  Internal interface through which this {@link @xeokit/scene!Texture} can load property updates into a renderer.
   *
   *  This is defined when the owner {@link @xeokit/scene!SceneModel} has been added to a {@link @xeokit/viewer!Viewer | Viewer}.
   *
   * @internal
   */
  this.rendererTexture = void 0;
  /**
   * ID for the texture.
   */
  this.id = void 0;
  /**
   * Path to an image file.
   */
  this.src = void 0;
  /**
   * Image file data.
   */
  this.imageData = void 0;
  /**
   * Transcoded texture data.
   */
  this.buffers = void 0;
  /**
   * HTMLImage containing the texture image.
   */
  this.image = void 0;
  /**
   * Pixel height of the texture.
   */
  this.height = void 0;
  /**
   * Pixel width of the texture.
   */
  this.width = void 0;
  /**
   * True if the texture is compressed.
   */
  this.compressed = void 0;
  /**
   * Media type of this Texture.
   *
   * Supported values are {@link @xeokit/constants!GIFMediaType}, {@link @xeokit/constants!PNGMediaType} and {@link @xeokit/constants!JPEGMediaType}.
   *
   * Ignored for compressed textures.
   */
  this.mediaType = void 0;
  /**
   * How the texture is sampled when a texel covers more than one pixel.
   *
   * Supported values are {@link @xeokit/constants!LinearFilter} and {@link @xeokit/constants!NearestFilter}.
   */
  this.magFilter = void 0;
  /**
   * How the texture is sampled when a texel covers less than one pixel. Supported values
   * are {@link @xeokit/constants!LinearMipmapLinearFilter}, {@link @xeokit/constants!LinearMipMapNearestFilter},
   * {@link @xeokit/constants!NearestMipMapNearestFilter}, {@link @xeokit/constants!NearestMipMapLinearFilter}
   * and {@link @xeokit/constants!LinearMipMapLinearFilter}.
   *
   * Ignored for compressed textures.
   */
  this.minFilter = void 0;
  /**
   * S wrapping mode.
   *
   * Supported values are {@link @xeokit/constants!ClampToEdgeWrapping}, {@link @xeokit/constants!MirroredRepeatWrapping} and {@link @xeokit/constants!RepeatWrapping}.
   *
   * Ignored for compressed textures.
   */
  this.wrapS = void 0;
  /**
   * T wrapping mode.
   *
   * Supported values are {@link @xeokit/constants!ClampToEdgeWrapping}, {@link @xeokit/constants!MirroredRepeatWrapping} and {@link @xeokit/constants!RepeatWrapping}.
   *
   * Ignored for compressed textures.
   */
  this.wrapT = void 0;
  /**
   * R wrapping mode.
   *
   * Supported values are {@link @xeokit/constants!ClampToEdgeWrapping}, {@link @xeokit/constants!MirroredRepeatWrapping} and {@link @xeokit/constants!RepeatWrapping}.
   *
   * Ignored for compressed textures.
   */
  this.wrapR = void 0;
  /**
   * Flips this Texture's source data along its vertical axis when ````true````.
   */
  this.flipY = void 0;
  /**
   * Texture encoding format.
   *
   * Supported values are {@link @xeokit/constants!LinearEncoding} and {@link @xeokit/constants!sRGBEncoding}.
   */
  this.encoding = void 0;
  /**
   * RGBA color to preload the texture with.
   */
  this.preloadColor = void 0;
  /**
   * @private
   */
  this.channel = void 0;
  this.id = params.id;
  this.imageData = params.imageData;
  this.src = params.src;
  this.mediaType = params.mediaType;
  this.minFilter = params.minFilter || LinearMipMapNearestFilter;
  this.magFilter = params.magFilter || LinearMipMapNearestFilter;
  this.wrapS = params.wrapS || RepeatWrapping;
  this.wrapT = params.wrapT || RepeatWrapping;
  this.wrapR = params.wrapR || RepeatWrapping;
  this.encoding = params.encoding || LinearEncoding;
  this.preloadColor = createVec4(params.preloadColor || [1, 1, 1, 1]);
  this.channel = 0;
  this.rendererTexture = null;
};

/**
 * A mesh in a {@link @xeokit/scene!SceneModel}.
 *
 * * Stored in {@link @xeokit/scene!SceneModel.meshes | SceneModel.meshes}
 * * Created with {@link @xeokit/scene!SceneModel.createMesh | SceneModel.createMesh}
 * * Referenced by {@link @xeokit/scene!SceneModel.meshes | SceneObject.meshes}
 *
 * See {@link "@xeokit/scene"} for usage.
 */
var _color = /*#__PURE__*/_classPrivateFieldLooseKey("color");
var _matrix = /*#__PURE__*/_classPrivateFieldLooseKey("matrix");
var _metallic = /*#__PURE__*/_classPrivateFieldLooseKey("metallic");
var _roughness = /*#__PURE__*/_classPrivateFieldLooseKey("roughness");
var _opacity = /*#__PURE__*/_classPrivateFieldLooseKey("opacity");
var Mesh = /*#__PURE__*/function () {
  /**
   * @private
   */
  function Mesh(meshParams) {
    /**
     * Unique ID of this Mesh.
     *
     * Mesh is stored by this ID in {@link @xeokit/scene!SceneModel.meshes}.
     */
    this.id = void 0;
    /**
     * {@link @xeokit/scene!Geometry} used by this Mesh.
     */
    this.geometry = void 0;
    /**
     * {@link @xeokit/scene!TextureSet} used by this Mesh.
     */
    this.textureSet = void 0;
    /**
     *  Internal interface through which a {@link @xeokit/scene!Mesh} can load property updates into a renderer.
     *
     *  This is defined when the owner {@link @xeokit/scene!SceneModel} has been added to
     *  a {@link @xeokit/viewer!Viewer | Viewer}.
     *
     * @internal
     */
    this.rendererMesh = void 0;
    /**
     * The {@link @xeokit/scene!SceneObject} that uses this Mesh.
     */
    this.object = void 0;
    Object.defineProperty(this, _color, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _matrix, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _metallic, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _roughness, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _opacity, {
      writable: true,
      value: void 0
    });
    this.id = meshParams.id;
    _classPrivateFieldLooseBase(this, _matrix)[_matrix] = meshParams.matrix ? createMat4(meshParams.matrix) : identityMat4();
    this.geometry = meshParams.geometry;
    this.textureSet = meshParams.textureSet;
    this.rendererMesh = null;
    this.color = meshParams.color || createVec3([1, 1, 1]);
    this.metallic = meshParams.metallic !== null && meshParams.metallic !== undefined ? meshParams.metallic : 0;
    this.roughness = meshParams.roughness !== null && meshParams.roughness !== undefined ? meshParams.roughness : 1;
    this.opacity = meshParams.opacity !== undefined && meshParams.opacity !== null ? meshParams.opacity : 1.0;
  }
  /**
   * Gets the RGB color for this Mesh.
   *
   * Each element of the color is in range ````[0..1]````.
   */
  _createClass(Mesh, [{
    key: "color",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _color)[_color];
    }
    /**
     * Sets the RGB color for this Mesh.
     *
     * Each element of the color is in range ````[0..1]````.
     */,
    set: function set(value) {
      var color = _classPrivateFieldLooseBase(this, _color)[_color];
      if (!color) {
        color = _classPrivateFieldLooseBase(this, _color)[_color] = new Float32Array(4);
        color[3] = 1;
      }
      if (value) {
        color[0] = value[0];
        color[1] = value[1];
        color[2] = value[2];
      } else {
        color[0] = 1;
        color[1] = 1;
        color[2] = 1;
      }
      if (this.rendererMesh) {
        this.rendererMesh.setColor(_classPrivateFieldLooseBase(this, _color)[_color]);
      }
    }
    /**
     * Gets this Mesh's local modeling transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @type {FloatArrayParam}
     */
  }, {
    key: "matrix",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _matrix)[_matrix];
    }
    /**
     * Updates this Mesh's local modeling transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @type {FloatArrayParam}
     */,
    set: function set(matrix) {
      if (matrix) {
        // @ts-ignore
        _classPrivateFieldLooseBase(this, _matrix)[_matrix].set(matrix);
      } else {
        identityMat4(_classPrivateFieldLooseBase(this, _matrix)[_matrix]);
      }
      if (this.rendererMesh) {
        this.rendererMesh.setMatrix(_classPrivateFieldLooseBase(this, _matrix)[_matrix]);
      }
      if (this.object) {
        this.object.setAABBDirty();
      }
    }
    /**
     * Gets this Mesh's metallic factor.
     *
     * This is in the range ````[0..1]```` and indicates how metallic this Mesh is.
     *
     * ````1```` is metal, ````0```` is non-metal.
     *
     * Default value is ````1.0````.
     */
  }, {
    key: "metallic",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _metallic)[_metallic];
    }
    /**
     * Sets this Mesh's metallic factor.
     *
     * This is in the range ````[0..1]```` and indicates how metallic this Mesh is.
     *
     * ````1```` is metal, ````0```` is non-metal.
     *
     * Default value is ````1.0````.
     */,
    set: function set(value) {
      value = value !== undefined && value !== null ? value : 1.0;
      if (_classPrivateFieldLooseBase(this, _metallic)[_metallic] === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _metallic)[_metallic] = value;
      if (this.rendererMesh) {
        this.rendererMesh.setMetallic(_classPrivateFieldLooseBase(this, _metallic)[_metallic]);
      }
    }
    /**
     * Gets this Mesh's roughness factor.
     *
     * This factor is in the range ````[0..1]````, where ````0```` is fully smooth,````1```` is fully rough.
     *
     * Default value is ````1.0````.
     */
  }, {
    key: "roughness",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _roughness)[_roughness];
    }
    /**
     * Sets this Mesh's roughness factor.
     *
     * This factor is in the range ````[0..1]````, where ````0```` is fully smooth,````1```` is fully rough.
     *
     * Default value is ````1.0````.
     */,
    set: function set(value) {
      value = value !== undefined && value !== null ? value : 1.0;
      if (_classPrivateFieldLooseBase(this, _roughness)[_roughness] === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _roughness)[_roughness] = value;
      if (this.rendererMesh) {
        this.rendererMesh.setRoughness(_classPrivateFieldLooseBase(this, _roughness)[_roughness]);
      }
    }
    /**
     * Gets the opacity factor for this Mesh.
     *
     * This is a factor in range ````[0..1]````.
     */
  }, {
    key: "opacity",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _opacity)[_opacity];
    }
    /**
     * Sets the opacity factor for this Mesh.
     *
     * This is a factor in range ````[0..1]````.
     */,
    set: function set(opacity) {
      opacity = opacity !== undefined && opacity !== null ? opacity : 1.0;
      if (_classPrivateFieldLooseBase(this, _opacity)[_opacity] === opacity) {
        return;
      }
      _classPrivateFieldLooseBase(this, _opacity)[_opacity] = opacity;
    }
  }]);
  return Mesh;
}();

var uniquePositions = [];
var indicesLookup = [];
var indicesReverseLookup = [];
var weldedIndices = [];
// TODO: Optimize with caching, but need to cater to both compressed and uncompressed positions
var faces = [];
var numFaces = 0;
var compa = new Uint16Array(3);
var compb = new Uint16Array(3);
var compc = new Uint16Array(3);
var a = createVec3();
var b = createVec3();
var c = createVec3();
var cb = createVec3();
var ab = createVec3();
var cross = createVec3();
var normal = createVec3();
function weldVertices(positions, indices) {
  var positionsMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
  var vx;
  var vy;
  var vz;
  var key;
  var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
  var precision = Math.pow(10, precisionPoints);
  var i;
  var len;
  var lenUniquePositions = 0;
  for (i = 0, len = positions.length; i < len; i += 3) {
    vx = positions[i];
    vy = positions[i + 1];
    vz = positions[i + 2];
    key = Math.round(vx * precision) + '_' + Math.round(vy * precision) + '_' + Math.round(vz * precision);
    // @ts-ignore
    if (positionsMap[key] === undefined) {
      // @ts-ignore
      positionsMap[key] = lenUniquePositions / 3;
      uniquePositions[lenUniquePositions++] = vx;
      uniquePositions[lenUniquePositions++] = vy;
      uniquePositions[lenUniquePositions++] = vz;
    }
    // @ts-ignore
    indicesLookup[i / 3] = positionsMap[key];
  }
  for (i = 0, len = indices.length; i < len; i++) {
    weldedIndices[i] = indicesLookup[indices[i]];
    indicesReverseLookup[weldedIndices[i]] = indices[i];
  }
}
function buildFaces(numIndices, positionsDecompressMatrix) {
  numFaces = 0;
  for (var i = 0, len = numIndices; i < len; i += 3) {
    var ia = weldedIndices[i] * 3;
    var ib = weldedIndices[i + 1] * 3;
    var ic = weldedIndices[i + 2] * 3;
    if (positionsDecompressMatrix) {
      compa[0] = uniquePositions[ia];
      compa[1] = uniquePositions[ia + 1];
      compa[2] = uniquePositions[ia + 2];
      compb[0] = uniquePositions[ib];
      compb[1] = uniquePositions[ib + 1];
      compb[2] = uniquePositions[ib + 2];
      compc[0] = uniquePositions[ic];
      compc[1] = uniquePositions[ic + 1];
      compc[2] = uniquePositions[ic + 2];
      // Decode
      decompressPoint3(compa, positionsDecompressMatrix, a);
      decompressPoint3(compb, positionsDecompressMatrix, b);
      decompressPoint3(compc, positionsDecompressMatrix, c);
    } else {
      a[0] = uniquePositions[ia];
      a[1] = uniquePositions[ia + 1];
      a[2] = uniquePositions[ia + 2];
      b[0] = uniquePositions[ib];
      b[1] = uniquePositions[ib + 1];
      b[2] = uniquePositions[ib + 2];
      c[0] = uniquePositions[ic];
      c[1] = uniquePositions[ic + 1];
      c[2] = uniquePositions[ic + 2];
    }
    subVec3(c, b, cb);
    subVec3(a, b, ab);
    cross3Vec3(cb, ab, cross);
    normalizeVec3(cross, normal);
    // @ts-ignore
    var face = faces[numFaces] || (faces[numFaces] = {
      normal: createVec3()
    });
    face.normal[0] = normal[0];
    face.normal[1] = normal[1];
    face.normal[2] = normal[2];
    numFaces++;
  }
}
/**
 * Builds edge connectivity indices from a 3D triangle mesh given as vertex positions and triangle indices
 * @private
 */
function buildEdgeIndices(positions, indices, positionsDecompressMatrix, edgeThreshold) {
  weldVertices(positions, indices);
  buildFaces(indices.length, positionsDecompressMatrix);
  var edgeIndices = [];
  var thresholdDot = Math.cos(DEGTORAD * edgeThreshold);
  var edges = {};
  var edge1;
  var edge2;
  var index1;
  var index2;
  var key;
  var largeIndex = false;
  var edge;
  var normal1;
  var normal2;
  var dot;
  var ia;
  var ib;
  for (var i = 0, len = indices.length; i < len; i += 3) {
    var faceIndex = i / 3;
    for (var j = 0; j < 3; j++) {
      edge1 = weldedIndices[i + j];
      edge2 = weldedIndices[i + (j + 1) % 3];
      index1 = Math.min(edge1, edge2);
      index2 = Math.max(edge1, edge2);
      key = index1 + "," + index2;
      // @ts-ignore
      if (edges[key] === undefined) {
        // @ts-ignore
        edges[key] = {
          index1: index1,
          index2: index2,
          face1: faceIndex,
          face2: undefined
        };
      } else {
        // @ts-ignore
        edges[key].face2 = faceIndex;
      }
    }
  }
  for (key in edges) {
    // @ts-ignore
    edge = edges[key];
    // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.
    if (edge.face2 !== undefined) {
      normal1 = faces[edge.face1].normal;
      normal2 = faces[edge.face2].normal;
      dot = dotVec3(normal1, normal2);
      if (dot > thresholdDot) {
        continue;
      }
    }
    ia = indicesReverseLookup[edge.index1];
    ib = indicesReverseLookup[edge.index2];
    if (!largeIndex && ia > 65535 || ib > 65535) {
      largeIndex = true;
    }
    edgeIndices.push(ia);
    edgeIndices.push(ib);
  }
  return largeIndex ? new Uint32Array(edgeIndices) : new Uint16Array(edgeIndices);
}

/**
 * @author https://github.com/tmarti, with support from https://tribia.com/
 * @license MIT
 *
 * This file takes a geometry given by { positions, indices }, and returns
 * equivalent { positions, indices } arrays but which only contain unique
 * positions.
 *
 * The time is O(N logN) with the number of positions due to a pre-sorting
 * step, but is much more GC-friendly and actually faster than the classic O(N)
 * approach based in keeping a hash-based LUT to identify unique positions.
 */
var comparePositions = null;
/**
 * This function obtains unique positions in the provided object
 * .positions array and calculates an index mapping, which is then
 * applied to the provided object .indices and .edgeindices.
 *
 * The input object items are not modified, and instead new set
 * of positions, indices and edgeIndices with the applied optimization
 * are returned.
 *
 * The algorithm, instead of being based in a hash-like LUT for
 * identifying unique positions, is based in pre-sorting the input
 * positions...
 *
 * (it's possible to define a _"consistent ordering"_ for the positions
 *  as positions are quantized and thus not suffer from float number
 *  comparison artifacts)
 *
 * ... so same positions are adjacent in the sorted array, and then
 * it's easy to scan linearly the sorted array. During the linear run,
 * we will know that we found a different position because the comparison
 * function will return != 0 between current and previous element.
 *
 * During this linear traversal of the array, a `unique counter` is used
 * in order to calculate the mapping between original indices and unique
 * indices.
 *
 * @param {*} mesh The input mesh to process, with `positions`, `indices` and `edgeIndices` keys.
 * @private
 * @returns An array with 3 elements: 0 => the uniquified positions; 1 and 2 => the remapped edges and edgeIndices arrays
 */
function uniquifyPositions(mesh) {
  var positionsCompressed = mesh.positionsCompressed;
  var indices = mesh.indices;
  var edgeIndices = mesh.edgeIndices;
  setMaxNumberOfPositions(positionsCompressed.length / 3);
  var seq = seqInit.slice(0, positionsCompressed.length / 3);
  var remappings = seqInit.slice(0, positionsCompressed.length / 3);
  comparePositions = positionsCompressed;
  seq.sort(compareVertex);
  var uniqueIdx = 0;
  remappings[seq[0]] = 0;
  for (var i = 1, len = seq.length; i < len; i++) {
    if (0 != compareVertex(seq[i], seq[i - 1])) {
      uniqueIdx++;
    }
    remappings[seq[i]] = uniqueIdx;
  }
  var numUniquePositions = uniqueIdx + 1;
  var uniquePositionsCompressed = new Uint16Array(numUniquePositions * 3);
  uniqueIdx = 0;
  uniquePositionsCompressed[uniqueIdx * 3 + 0] = positionsCompressed[seq[0] * 3 + 0];
  uniquePositionsCompressed[uniqueIdx * 3 + 1] = positionsCompressed[seq[0] * 3 + 1];
  uniquePositionsCompressed[uniqueIdx * 3 + 2] = positionsCompressed[seq[0] * 3 + 2];
  for (var _i = 1, _len = seq.length; _i < _len; _i++) {
    if (0 !== compareVertex(seq[_i], seq[_i - 1])) {
      uniqueIdx++;
      uniquePositionsCompressed[uniqueIdx * 3 + 0] = positionsCompressed[seq[_i] * 3 + 0];
      uniquePositionsCompressed[uniqueIdx * 3 + 1] = positionsCompressed[seq[_i] * 3 + 1];
      uniquePositionsCompressed[uniqueIdx * 3 + 2] = positionsCompressed[seq[_i] * 3 + 2];
    }
    remappings[seq[_i]] = uniqueIdx;
  }
  comparePositions = null;
  var uniqueIndices = new Uint32Array(indices.length);
  for (var _i2 = 0, _len2 = indices.length; _i2 < _len2; _i2++) {
    uniqueIndices[_i2] = remappings[indices[_i2]];
  }
  var uniqueEdgeIndices;
  if (edgeIndices) {
    uniqueEdgeIndices = new Uint32Array(edgeIndices.length);
    for (var _i3 = 0, _len3 = edgeIndices.length; _i3 < _len3; _i3++) {
      uniqueEdgeIndices[_i3] = remappings[edgeIndices[_i3]];
    }
  }
  return [uniquePositionsCompressed, uniqueIndices, uniqueEdgeIndices];
}
function compareVertex(a, b) {
  var res;
  for (var i = 0; i < 3; i++) {
    if (0 != (res = comparePositions[a * 3 + i] - comparePositions[b * 3 + i])) {
      return res;
    }
  }
  return 0;
}
var seqInit = null;
function setMaxNumberOfPositions(maxPositions) {
  if (seqInit !== null && seqInit.length >= maxPositions) {
    return;
  }
  seqInit = new Uint32Array(maxPositions);
  for (var i = 0; i < maxPositions; i++) {
    seqInit[i] = i;
  }
}

var MAX_RE_BUCKET_FAN_OUT = 8;
var bucketsForIndices = null;
function rebucketPositions(mesh, bitsPerBucket, checkResult) {
  if (checkResult === void 0) {
    checkResult = false;
  }
  var positionsCompressed = mesh.positionsCompressed || [];
  var indices = preSortIndices(mesh.indices || [], bitsPerBucket);
  var edgeIndices = []; //preSortEdgeIndices(mesh.edgeIndices || []);
  /**
   * Code adapted from https://stackoverflow.com/questions/22697936/binary-search-in-javascript
   */
  function edgeSearch(el0, el1) {
    if (el0 > el1) {
      var tmp = el0;
      el0 = el1;
      el1 = tmp;
    }
    function compare_fn(a, b) {
      if (a != el0) {
        return el0 - a;
      }
      if (b != el1) {
        return el1 - b;
      }
      return 0;
    }
    var m = 0;
    var n = (edgeIndices.length >> 1) - 1;
    while (m <= n) {
      var k = n + m >> 1;
      var cmp = compare_fn(edgeIndices[k * 2], edgeIndices[k * 2 + 1]);
      if (cmp > 0) {
        m = k + 1;
      } else if (cmp < 0) {
        n = k - 1;
      } else {
        return k;
        /**
         * Flat array of compressed integer vertex colors.
         *
         * Alternative to {@link @xeokit/scene!GeometryParams.colorsCompressed}.
         *
         * Ignored when {@link @xeokit/scene!GeometryParams.id} is defined.
         */
      }
    }

    return -m - 1;
  }
  // console.log (edgeIndices);
  // throw (e);
  // console.log (`${mesh.edgeIndices.length / 2} edge indices`);
  // console.log (`${edgeIndices.length / 2} edge indices sorted`);
  var alreadyOutputEdgeIndices = new Int32Array(edgeIndices.length / 2);
  alreadyOutputEdgeIndices.fill(0);
  var numPositions = positionsCompressed.length / 3;
  if (numPositions > (1 << bitsPerBucket) * MAX_RE_BUCKET_FAN_OUT) {
    return [mesh];
  }
  var bucketIndicesRemap = new Int32Array(numPositions);
  bucketIndicesRemap.fill(-1);
  var buckets = [];
  function addEmptyBucket() {
    bucketIndicesRemap.fill(-1);
    var newBucket = {
      positionsCompressed: [],
      indices: [],
      edgeIndices: [],
      maxNumPositions: (1 << bitsPerBucket) - bitsPerBucket,
      numPositions: 0,
      bucketNumber: buckets.length
    };
    buckets.push(newBucket);
    return newBucket;
  }
  var currentBucket = addEmptyBucket();
  for (var i = 0, len = indices.length; i < len; i += 3) {
    var additonalPositionsInBucket = 0;
    var ii0 = indices[i];
    var ii1 = indices[i + 1];
    var ii2 = indices[i + 2];
    if (bucketIndicesRemap[ii0] == -1) {
      additonalPositionsInBucket++;
    }
    if (bucketIndicesRemap[ii1] == -1) {
      additonalPositionsInBucket++;
    }
    if (bucketIndicesRemap[ii2] == -1) {
      additonalPositionsInBucket++;
    }
    if (additonalPositionsInBucket + currentBucket.numPositions > currentBucket.maxNumPositions) {
      currentBucket = addEmptyBucket();
    }
    if (currentBucket.bucketNumber > MAX_RE_BUCKET_FAN_OUT) {
      return [mesh];
    }
    if (bucketIndicesRemap[ii0] == -1) {
      bucketIndicesRemap[ii0] = currentBucket.numPositions++;
      currentBucket.positionsCompressed.push(positionsCompressed[ii0 * 3]);
      currentBucket.positionsCompressed.push(positionsCompressed[ii0 * 3 + 1]);
      currentBucket.positionsCompressed.push(positionsCompressed[ii0 * 3 + 2]);
    }
    if (bucketIndicesRemap[ii1] == -1) {
      bucketIndicesRemap[ii1] = currentBucket.numPositions++;
      currentBucket.positionsCompressed.push(positionsCompressed[ii1 * 3]);
      currentBucket.positionsCompressed.push(positionsCompressed[ii1 * 3 + 1]);
      currentBucket.positionsCompressed.push(positionsCompressed[ii1 * 3 + 2]);
    }
    if (bucketIndicesRemap[ii2] == -1) {
      bucketIndicesRemap[ii2] = currentBucket.numPositions++;
      currentBucket.positionsCompressed.push(positionsCompressed[ii2 * 3]);
      currentBucket.positionsCompressed.push(positionsCompressed[ii2 * 3 + 1]);
      currentBucket.positionsCompressed.push(positionsCompressed[ii2 * 3 + 2]);
    }
    currentBucket.indices.push(bucketIndicesRemap[ii0]);
    currentBucket.indices.push(bucketIndicesRemap[ii1]);
    currentBucket.indices.push(bucketIndicesRemap[ii2]);
    // Check possible edge1
    var edgeIndex = void 0;
    if ((edgeIndex = edgeSearch(ii0, ii1)) >= 0) {
      if (alreadyOutputEdgeIndices[edgeIndex] == 0) {
        alreadyOutputEdgeIndices[edgeIndex] = 1;
        currentBucket.edgeIndices.push(bucketIndicesRemap[edgeIndices[edgeIndex * 2]]);
        currentBucket.edgeIndices.push(bucketIndicesRemap[edgeIndices[edgeIndex * 2 + 1]]);
      }
    }
    if ((edgeIndex = edgeSearch(ii0, ii2)) >= 0) {
      if (alreadyOutputEdgeIndices[edgeIndex] == 0) {
        alreadyOutputEdgeIndices[edgeIndex] = 1;
        currentBucket.edgeIndices.push(bucketIndicesRemap[edgeIndices[edgeIndex * 2]]);
        currentBucket.edgeIndices.push(bucketIndicesRemap[edgeIndices[edgeIndex * 2 + 1]]);
      }
    }
    if ((edgeIndex = edgeSearch(ii1, ii2)) >= 0) {
      if (alreadyOutputEdgeIndices[edgeIndex] == 0) {
        alreadyOutputEdgeIndices[edgeIndex] = 1;
        currentBucket.edgeIndices.push(bucketIndicesRemap[edgeIndices[edgeIndex * 2]]);
        currentBucket.edgeIndices.push(bucketIndicesRemap[edgeIndices[edgeIndex * 2 + 1]]);
      }
    }
  }
  var prevBytesPerIndex = bitsPerBucket / 8 * 2;
  var newBytesPerIndex = bitsPerBucket / 8;
  var originalSize = positionsCompressed.length * 2 + (indices.length + edgeIndices.length) * prevBytesPerIndex;
  var newSize = 0;
  buckets.forEach(function (bucket) {
    newSize += bucket.positionsCompressed.length * 2 + (bucket.indices.length + bucket.edgeIndices.length) * newBytesPerIndex;
  });
  if (newSize > originalSize) {
    return [mesh];
  }
  // console.log ("added positions " + newPositions + ", buckets: " + buckets.length);
  if (checkResult) {
    doCheckResult(buckets, mesh);
  }
  // return [ mesh ];
  return buckets;
}
function compareBuckets(a, b) {
  var aa = a * 3;
  var bb = b * 3;
  var aa1, aa2, aa3, bb1, bb2, bb3;
  var minBucketA = Math.min(aa1 = bucketsForIndices[aa], aa2 = bucketsForIndices[aa + 1], aa3 = bucketsForIndices[aa + 2]);
  var minBucketB = Math.min(bb1 = bucketsForIndices[bb], bb2 = bucketsForIndices[bb + 1], bb3 = bucketsForIndices[bb + 2]);
  if (minBucketA != minBucketB) {
    return minBucketA - minBucketB;
  }
  var maxBucketA = Math.max(aa1, aa2, aa3);
  var maxBucketB = Math.max(bb1, bb2, bb3);
  if (maxBucketA != maxBucketB) {
    return maxBucketA - maxBucketB;
  }
  return 0;
}
function preSortIndices(indices, bitsPerBucket) {
  var seq = new Int32Array(indices.length / 3);
  for (var i = 0, len = seq.length; i < len; i++) {
    seq[i] = i;
  }
  bucketsForIndices = new Int32Array(indices.length);
  for (var _i = 0, _len = indices.length; _i < _len; _i++) {
    bucketsForIndices[_i] = indices[_i] >> bitsPerBucket;
  }
  seq.sort(compareBuckets);
  var sortedIndices = new Int32Array(indices.length);
  for (var _i2 = 0, _len2 = seq.length; _i2 < _len2; _i2++) {
    sortedIndices[_i2 * 3 + 0] = indices[seq[_i2] * 3 + 0];
    sortedIndices[_i2 * 3 + 1] = indices[seq[_i2] * 3 + 1];
    sortedIndices[_i2 * 3 + 2] = indices[seq[_i2] * 3 + 2];
  }
  return sortedIndices;
}
function doCheckResult(buckets, mesh) {
  var meshDict = {};
  buckets.forEach(function (bucket) {
    var indices = bucket.indices;
    var edgeIndices = bucket.edgeIndices;
    var positionsCompressed = bucket.positionsCompressed;
    for (var i = 0, len = indices.length; i < len; i += 3) {
      var key = positionsCompressed[indices[i] * 3] + "_" + positionsCompressed[indices[i] * 3 + 1] + "_" + positionsCompressed[indices[i] * 3 + 2] + "/" + positionsCompressed[indices[i + 1] * 3] + "_" + positionsCompressed[indices[i + 1] * 3 + 1] + "_" + positionsCompressed[indices[i + 1] * 3 + 2] + "/" + positionsCompressed[indices[i + 2] * 3] + "_" + positionsCompressed[indices[i + 2] * 3 + 1] + "_" + positionsCompressed[indices[i + 2] * 3 + 2];
      meshDict[key] = true;
    }
    for (var i = 0, len = edgeIndices.length; i < len; i += 2) {
      var key = positionsCompressed[edgeIndices[i] * 3] + "_" + positionsCompressed[edgeIndices[i] * 3 + 1] + "_" + positionsCompressed[edgeIndices[i] * 3 + 2] + "/" + positionsCompressed[edgeIndices[i + 1] * 3] + "_" + positionsCompressed[edgeIndices[i + 1] * 3 + 1] + "_" + positionsCompressed[edgeIndices[i + 1] * 3 + 2] + "/";
    }
  });
  {
    var indices = mesh.indices;
    var positionsCompressed = mesh.positionsCompressed;
    for (var i = 0, len = indices.length; i < len; i += 3) {
      var key = positionsCompressed[indices[i] * 3] + "_" + positionsCompressed[indices[i] * 3 + 1] + "_" + positionsCompressed[indices[i] * 3 + 2] + "/" + positionsCompressed[indices[i + 1] * 3] + "_" + positionsCompressed[indices[i + 1] * 3 + 1] + "_" + positionsCompressed[indices[i + 1] * 3 + 2] + "/" + positionsCompressed[indices[i + 2] * 3] + "_" + positionsCompressed[indices[i + 2] * 3 + 1] + "_" + positionsCompressed[indices[i + 2] * 3 + 2];
      if (!(key in meshDict)) {
        console.log("Not found " + key);
        throw "Ohhhh!";
      }
    }
    //  for (var i = 0, len = edgeIndices.length; i < len; i+=2)
    //  {
    //      var key = positionsCompressed[edgeIndices[i]*3] + "_" + positionsCompressed[edgeIndices[i]*3+1] + "_" + positionsCompressed[edgeIndices[i]*3+2] + "/" +
    //                positionsCompressed[edgeIndices[i+1]*3] + "_" + positionsCompressed[edgeIndices[i+1]*3+1] + "_" + positionsCompressed[edgeIndices[i+1]*3+2] + "/";
    //      if (!(key in edgesDict)) {
    //          var key2 = edgeIndices[i] + "_" + edgeIndices[i+1];
    //          console.log ("   - Not found " + key);
    //          console.log ("   - Not found " + key2);
    //         //  throw "Ohhhh2!";
    //      }
    //  }
  }
}

/**
 * Compresses a {@link @xeokit/scene!GeometryParams | GeometryParams} into a {@link @xeokit/scene!GeometryCompressedParams | GeometryCompressedParams}.
 *
 * See {@link @xeokit/scene} for usage examples.
 *
 * @param geometryParams Uncompressed geometry params.
 * @returns Compressed geometry params.
 */
function compressGeometryParams(geometryParams) {
  var positionsDecompressMatrix = createMat4();
  var aabb = collapseAABB3();
  expandAABB3Points3(aabb, geometryParams.positions);
  var positionsCompressed = quantizePositions3(geometryParams.positions, aabb, positionsDecompressMatrix);
  var edgeIndices = (geometryParams.primitive === SolidPrimitive || geometryParams.primitive === SurfacePrimitive || geometryParams.primitive === TrianglesPrimitive) && geometryParams.indices ? buildEdgeIndices(positionsCompressed, geometryParams.indices, positionsDecompressMatrix, 10) : null;
  var uniquePositionsCompressed;
  var uniqueIndices;
  var uniqueEdgeIndices;
  var _uniquifyPositions = uniquifyPositions({
    positionsCompressed: positionsCompressed,
    uvs: geometryParams.uvs,
    indices: geometryParams.indices,
    edgeIndices: edgeIndices
  });
  uniquePositionsCompressed = _uniquifyPositions[0];
  uniqueIndices = _uniquifyPositions[1];
  uniqueEdgeIndices = _uniquifyPositions[2];
  var numUniquePositions = uniquePositionsCompressed.length / 3;
  var geometryBuckets = rebucketPositions({
    positionsCompressed: uniquePositionsCompressed,
    indices: uniqueIndices,
    edgeIndices: uniqueEdgeIndices
  }, numUniquePositions > 1 << 16 ? 16 : 8);
  return {
    id: geometryParams.id,
    primitive: geometryParams.primitive === SolidPrimitive && geometryBuckets.length > 1 ? TrianglesPrimitive : geometryParams.primitive,
    aabb: aabb,
    positionsDecompressMatrix: positionsDecompressMatrix,
    uvsDecompressMatrix: undefined,
    geometryBuckets: geometryBuckets
  };
}

// XKT texture types
var COLOR_TEXTURE = 0;
var METALLIC_ROUGHNESS_TEXTURE = 1;
var NORMALS_TEXTURE = 2;
var EMISSIVE_TEXTURE = 3;
var OCCLUSION_TEXTURE = 4;
/**
 * xeokit Geometry and Materials Model.
 *
 * * A representation of a model's geometry and materials within a {@link @xeokit/scene!Scene}.
 * * Contains {@link @xeokit/scene!SceneObject | SceneObjects}, {@link @xeokit/scene!Mesh | Meshes}, {@link @xeokit/scene!Geometry | Geometries} and {@link @xeokit/scene!Texture | Textures}.
 * * Compresses textures using [Basis](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#basis)
 * * Compresses geometry using [bucketing](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#geometry-bucketing) and [quantization](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#geometry-quantization)
 * * Viewable in the Browser with {@link @xeokit/viewer!Viewer}
 * * Importable from various model file formats, using {@link @xeokit/gltf!loadGLTF}, {@link @xeokit/las!loadLAS}, {@link @xeokit/cityjson!loadCityJSON}, {@link @xeokit/xkt!loadXKT} (etc)
 * * Exportable to [XKT](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#xkt) format using {@link @xeokit/xkt!saveXKT}
 * * Programmatically buildable using builder methods
 *
 * See {@link "@xeokit/scene"} for usage.
 */
var _texturesList = /*#__PURE__*/_classPrivateFieldLooseKey("texturesList");
var _numObjects$2 = /*#__PURE__*/_classPrivateFieldLooseKey("numObjects");
var _meshUsedByObject = /*#__PURE__*/_classPrivateFieldLooseKey("meshUsedByObject");
var _removeUnusedTextures = /*#__PURE__*/_classPrivateFieldLooseKey("removeUnusedTextures");
var SceneModel = /*#__PURE__*/function (_Component) {
  _inheritsLoose(SceneModel, _Component);
  /**
   * @private
   */
  function SceneModel(scene, sceneModelParams) {
    var _this;
    _this = _Component.call(this, scene, {
      id: sceneModelParams.id
    }) || this;
    Object.defineProperty(_assertThisInitialized(_this), _removeUnusedTextures, {
      value: _removeUnusedTextures2
    });
    /**
     * The {@link @xeokit/scene!Scene} that contains this SceneModel.
     */
    _this.scene = void 0;
    /**
     * If we want to view this SceneModel with a {@link @xeokit/viewer!Viewer}, an
     * optional ID of a {@link @xeokit/viewer!ViewLayer | ViewLayer} to view it in.
     */
    _this.layerId = void 0;
    /**
     * Indicates if this SceneModel has already been built.
     *
     * * Set ````true```` by {@link @xeokit/scene!SceneModel.build | SceneModel.build}.
     * * Subscribe to updates using {@link @xeokit/scene!SceneModel.onBuilt | SceneModel.onBuilt}
     * and {@link @xeokit/scene!Scene.onModelCreated | Scene.onModelCreated}.
     * * Don't create anything more in this SceneModel once it's built.
     */
    _this.built = void 0;
    /**
     * The edge threshold for automatic [edge primitive generation](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#geometry-edge-generation).
     */
    _this.edgeThreshold = void 0;
    /**
     * {@link @xeokit/scene!Geometry | Geometries} within this SceneModel, each mapped to {@link @xeokit/scene!Geometry.id | Geometry.id}.
     *
     * * Created by {@link @xeokit/scene!SceneModel.createGeometry | SceneModel.createGeometry}.
     */
    _this.geometries = void 0;
    /**
     * {@link @xeokit/scene!Texture | Textures} within this SceneModel, each mapped to {@link @xeokit/scene!Texture.id | Texture.id}.
     *
     * * Created by {@link @xeokit/scene!SceneModel.createTexture | SceneModel.createTexture}.
     * * Compressed asynchronously in {@link @xeokit/scene!SceneModel.build | SceneModel.build}.
     */
    _this.textures = void 0;
    /**
     * {@link @xeokit/scene!TextureSet | TextureSets} within this SceneModel, each mapped to {@link @xeokit/scene!TextureSet.id | TextureSet.id}.
     *
     * * Created by {@link @xeokit/scene!SceneModel.createTextureSet | SceneModel.createTextureSet}.
     */
    _this.textureSets = void 0;
    /**
     * {@link @xeokit/scene!Mesh | Meshes} within this SceneModel, each mapped to {@link @xeokit/scene!Mesh.id | Mesh.id}.
     *
     * * Created by {@link @xeokit/scene!SceneModel.createMesh | SceneModel.createMesh}.
     */
    _this.meshes = void 0;
    /**
     * {@link @xeokit/scene!SceneObject | SceneObjects} within this SceneModel, each mapped to {@link @xeokit/scene!SceneObject.id | SceneObject.id}.
     *
     * * Created by {@link @xeokit/scene!SceneModel.createObject | SceneModel.createObject}.
     */
    _this.objects = void 0;
    /**
     * The axis-aligned 3D World-space boundary of this SceneModel.
     *
     * * Created by {@link @xeokit/scene!SceneModel.build | SceneModel.build}.
     */
    _this.aabb = void 0;
    /**
     * Emits an event when this {@link @xeokit/scene!SceneModel | SceneModel} has been built.
     *
     * * Triggered by {@link @xeokit/scene!SceneModel.build | SceneModel.build}.
     *
     * @event onBuilt
     */
    _this.onBuilt = void 0;
    /**
     *  Internal interface through which a SceneModel can load updated content into a renderer.
     *
     * @internal
     */
    _this.rendererModel = void 0;
    /**
     * Statistics on this SceneModel.
     */
    _this.stats = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _texturesList, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _numObjects$2, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _meshUsedByObject, {
      writable: true,
      value: void 0
    });
    _this.scene = scene;
    _this.onBuilt = new EventEmitter(new dist.EventDispatcher());
    _this.onDestroyed = new EventEmitter(new dist.EventDispatcher());
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _numObjects$2)[_numObjects$2] = 0;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _meshUsedByObject)[_meshUsedByObject] = {};
    _this.id = sceneModelParams.id || "default";
    _this.layerId = sceneModelParams.layerId;
    _this.edgeThreshold = 10;
    _this.geometries = {};
    _this.textures = {};
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _texturesList)[_texturesList] = [];
    _this.textureSets = {};
    _this.meshes = {};
    _this.objects = {};
    _this.aabb = createAABB3();
    _this.built = false;
    _this.rendererModel = null;
    _this.stats = {
      numGeometries: 0,
      numLines: 0,
      numMeshes: 0,
      numObjects: 0,
      numPoints: 0,
      numTextureSets: 0,
      numTextures: 0,
      numTriangles: 0,
      numVertices: 0,
      textureBytes: 0
    };
    _this.fromJSON(sceneModelParams);
    return _this;
  }
  /**
   * Adds components to this SceneModel.
   *
   * See {@link "@xeokit/scene"} for usage.
   *
   * @param sceneModelParams
   * @returns *void*
   * * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * If this SceneModel has already been built.
   * * If this SceneModel has already been destroyed.
   * * A duplicate component ({@link @xeokit/scene!SceneObject}, {@link @xeokit/scene!Mesh},
   * {@link @xeokit/scene!Geometry}, {@link @xeokit/scene!Texture} etc.) was already created within this SceneModel.
   */
  var _proto = SceneModel.prototype;
  _proto.fromJSON = function fromJSON(sceneModelParams) {
    if (this.destroyed) {
      return new SDKError("Failed to add components to SceneModel - SceneModel already destroyed");
    }
    if (this.built) {
      return new SDKError("Failed to add components to SceneModel - SceneModel already built");
    }
    if (sceneModelParams.geometries) {
      for (var i = 0, len = sceneModelParams.geometries.length; i < len; i++) {
        this.createGeometry(sceneModelParams.geometries[i]);
      }
    }
    if (sceneModelParams.textures) {
      for (var _i = 0, _len = sceneModelParams.textures.length; _i < _len; _i++) {
        this.createTexture(sceneModelParams.textures[_i]);
      }
    }
    if (sceneModelParams.textureSets) {
      for (var _i2 = 0, _len2 = sceneModelParams.textureSets.length; _i2 < _len2; _i2++) {
        this.createTextureSet(sceneModelParams.textureSets[_i2]);
      }
    }
    if (sceneModelParams.meshes) {
      for (var _i3 = 0, _len3 = sceneModelParams.meshes.length; _i3 < _len3; _i3++) {
        this.createMesh(sceneModelParams.meshes[_i3]);
      }
    }
    if (sceneModelParams.objects) {
      for (var _i4 = 0, _len4 = sceneModelParams.objects.length; _i4 < _len4; _i4++) {
        this.createObject(sceneModelParams.objects[_i4]);
      }
    }
  }
  /**
   * Creates a new {@link Transform} within this SceneModel.
   *
   * * Stores the new {@link Transform} in {@link @xeokit/scene!SceneModel.transforms | SceneModel.transforms}.
   *
   * ### Usage
   *
   * ````javascript
   * const spinningTransform = sceneModel.createTransform({
   *      id: "spinningTransform",
   *      rotation: [0, 10, 0]
   * });
   *
   * const spinningTransformAgain = sceneModel.transforms["spinningTransform"];
   * ````
   *
   * See {@link "@xeokit/scene"} for more usage info.
   *
   * @param transformParams Transform creation parameters.
   * @returns *{@link Transform}*
   * * On success
   * @returns *{@link @xeokit/core!SDKError}*
   * * If SceneModel has already been built or destroyed.
   */;
  _proto.createTransform = function createTransform(transformParams) {
    if (this.destroyed) {
      return new SDKError("Failed to create Transform in SceneModel - SceneModel already destroyed");
    }
    if (this.built) {
      return new SDKError("Failed to create Transform in SceneModel - SceneModel already built");
    }
    //...
  }
  /**
   * Creates a new {@link @xeokit/scene!Texture} within this SceneModel.
   *
   * * Stores the new {@link @xeokit/scene!Texture} in {@link @xeokit/scene!SceneModel.textures | SceneModel.textures}.
   * * Textures are compressed asynchronously by {@link @xeokit/scene!SceneModel.build | SceneModel.build}.
   *
   * ### Usage
   *
   * ````javascript
   * const texture = sceneModel.createTexture({
   *      id: "myColorTexture",
   *      src: // Path to JPEG, PNG, KTX2,
   *      image: // HTMLImageElement,
   *      buffers: // ArrayBuffer[] containing KTX2 MIP levels
   *      preloadColor: [1,0,0,1],
   *      flipY: false,
   *      encoding: LinearEncoding, // @xeokit/constants
   *      magFilter: LinearFilter,
   *      minFilter: LinearFilter,
   *      wrapR: ClampToEdgeWrapping,
   *      wrapS: ClampToEdgeWrapping,
   *      wrapT: ClampToEdgeWrapping,
   * });
   *
   * const textureAgain = sceneModel.textures["myColorTexture"];
   * ````
   *
   * See {@link "@xeokit/scene"} for more usage info.
   *
   * @param textureParams - Texture creation parameters.
   * @returns *{@link @xeokit/scene!Texture}*
   * * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * If SceneModel has already been built or destroyed.
   * * Invalid TextureParams were given.
   * * Texture with given ID already exists in this Scene.
   */;
  _proto.createTexture = function createTexture(textureParams) {
    if (this.destroyed) {
      return new SDKError("Failed to create Texture in SceneModel - SceneModel already destroyed");
    }
    if (this.built) {
      return new SDKError("Failed to create Texture in SceneModel - SceneModel already built");
    }
    if (!textureParams.imageData && !textureParams.src && !textureParams.buffers) {
      return new SDKError("Failed to create Texture in SceneModel - Parameter expected: textureParams.imageData, textureParams.src or textureParams.buffers");
    }
    if (this.textures[textureParams.id]) {
      return new SDKError("Failed to create Texture in SceneModel - Texture already exists with this ID: " + textureParams.id);
    }
    if (textureParams.src) {
      textureParams.src.split('.').pop();
      // if (fileExt !== "jpg" && fileExt !== "jpeg" && fileExt !== "png") {
      //     console.error(`Model does not support image files with extension '${fileExt}' - won't create texture '${textureParams.id}`);
      //     return;
      // }
    }

    if (textureParams.imageData) {
      this.stats.textureBytes += textureParams.imageData.width * textureParams.imageData.height * 4; // Guessing
    }

    var texture = new Texture(textureParams);
    this.textures[textureParams.id] = texture;
    _classPrivateFieldLooseBase(this, _texturesList)[_texturesList].push(texture);
    this.stats.numTextures++;
    return texture;
  }
  /**
   * Creates a new {@link @xeokit/scene!TextureSet} within this SceneModel.
   *
   * * Stores the new {@link @xeokit/scene!TextureSet} in {@link @xeokit/scene!SceneModel.textureSets | SceneModel.textureSets}.
   *
   * ### Usage
   *
   * ````javascript
   * const textureSet = sceneModel.createTextureSet({
   *      id: "myTextureSet",
   *      colorTextureId: "myColorTexture"
   * });
   *
   * const textureSetAgain = sceneModel.textureSets["myTextureSet"];
   * ````
   *
   * See {@link "@xeokit/scene"} for more usage info.
   *
   * @param textureSetParams TextureSet creation parameters.
   *
   * @returns *{@link @xeokit/scene!TextureSet}*
   * * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * If SceneModel has already been built or destroyed.
   * * Invalid TextureSetParams were given.
   * * TextureSet with given ID already exists in this SceneModel.
   * * One or more of the given Textures could not be found in this SceneModel.
   */;
  _proto.createTextureSet = function createTextureSet(textureSetParams) {
    if (this.destroyed) {
      return new SDKError("Failed to create TextureSet in SceneModel - SceneModel already destroyed");
    }
    if (this.built) {
      return new SDKError("Failed to create TextureSet in SceneModel - SceneModel already built");
    }
    if (this.textureSets[textureSetParams.id]) {
      return new SDKError("Failed to create TextureSet in SceneModel - TextureSet already exists with this ID: " + textureSetParams.id);
    }
    var colorTexture;
    if (textureSetParams.colorTextureId !== undefined && textureSetParams.colorTextureId !== null) {
      colorTexture = this.textures[textureSetParams.colorTextureId];
      if (!colorTexture) {
        return new SDKError("Failed to create TextureSet in SceneModel - Texture not found: " + textureSetParams.colorTextureId + " - ensure that you create it first with createTexture()");
      }
      colorTexture.channel = COLOR_TEXTURE;
    }
    var metallicRoughnessTexture;
    if (textureSetParams.metallicRoughnessTextureId !== undefined && textureSetParams.metallicRoughnessTextureId !== null) {
      metallicRoughnessTexture = this.textures[textureSetParams.metallicRoughnessTextureId];
      if (!metallicRoughnessTexture) {
        return new SDKError("Failed to create TextureSet in SceneModel - Texture not found: " + textureSetParams.metallicRoughnessTextureId + " - ensure that you create it first with createTexture()");
      }
      metallicRoughnessTexture.channel = METALLIC_ROUGHNESS_TEXTURE;
    }
    var normalsTexture;
    if (textureSetParams.normalsTextureId !== undefined && textureSetParams.normalsTextureId !== null) {
      normalsTexture = this.textures[textureSetParams.normalsTextureId];
      if (!normalsTexture) {
        return new SDKError("Failed to create TextureSet in SceneModel - Texture not found: " + textureSetParams.normalsTextureId + " - ensure that you create it first with createTexture()");
      }
      normalsTexture.channel = NORMALS_TEXTURE;
    }
    var emissiveTexture;
    if (textureSetParams.emissiveTextureId !== undefined && textureSetParams.emissiveTextureId !== null) {
      emissiveTexture = this.textures[textureSetParams.emissiveTextureId];
      if (!emissiveTexture) {
        return new SDKError("Failed to create TextureSet in SceneModel - Texture not found: " + textureSetParams.emissiveTextureId + " - ensure that you create it first with createTexture()");
      }
      emissiveTexture.channel = EMISSIVE_TEXTURE;
    }
    var occlusionTexture;
    if (textureSetParams.occlusionTextureId !== undefined && textureSetParams.occlusionTextureId !== null) {
      occlusionTexture = this.textures[textureSetParams.occlusionTextureId];
      if (!occlusionTexture) {
        return new SDKError("Failed to create TextureSet in SceneModel - Texture not found: " + textureSetParams.occlusionTextureId + " - ensure that you create it first with createTexture()");
      }
      occlusionTexture.channel = OCCLUSION_TEXTURE;
    }
    var textureSet = new TextureSet(textureSetParams, {
      emissiveTexture: emissiveTexture,
      occlusionTexture: occlusionTexture,
      metallicRoughnessTexture: metallicRoughnessTexture,
      colorTexture: colorTexture
    });
    this.textureSets[textureSetParams.id] = textureSet;
    this.stats.numTextureSets++;
    return textureSet;
  }
  /**
   * Creates a new {@link @xeokit/scene!Geometry} within this SceneModel, from non-compressed geometry parameters.
   *
   * * Stores the new {@link @xeokit/scene!Geometry} in {@link @xeokit/scene!SceneModel.geometries | SceneModel.geometries}.
   *
   * ### Usage
   *
   * ````javascript
   * const boxGeometry = sceneModel.createGeometry({
   *      id: "boxGeometry",
   *      primitive: TrianglesPrimitive, // @xeokit/constants
   *      positions: [
   *          1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, // v0-v1-v2-v3 front
   *          1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, // v0-v3-v4-v1 right
   *          1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, // v0-v1-v6-v1 top
   *          -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, // v1-v6-v7-v2 left
   *          -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1,// v7-v4-v3-v2 bottom
   *          1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1 // v4-v7-v6-v1 back
   *      ],
   *      indices: [
   *          0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15,
   *          16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23
   *      ]
   *  });
   *
   * if (boxGeometry instanceof SDKError) {
   *     console.log(boxGeometry.message);
   * } else {
   *      const boxGeometryAgain = sceneModel.geometries["boxGeometry"];
   * }
   * ````
   *
   * See {@link "@xeokit/scene"} for more usage info.
   *
   * @param geometryParams Non-compressed geometry parameters.
   * @returns *{@link @xeokit/scene!Geometry}*
   *  * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * If this SceneModel has already been destroyed.
   * * If this SceneModel has already been built.
   * * Invalid GeometryParams were given.
   * * Geometry of given ID already exists in this SceneModel.
   * * Unsupported primitive type given.
   * * Mandatory vertex positions were not given. Vertex positions are mandatory for all primitive types.
   * * Mandatory indices were not given for primitive type that is not {@link @xeokit/constants!PointsPrimitive}. Indices are mandatory for all primitive types except PointsPrimitive.
   * * Indices out of range of vertex positions.
   * * Indices out of range of vertex UVs.
   * * Mismatch between given quantities of vertex positions and UVs.
   */;
  _proto.createGeometry = function createGeometry(geometryParams) {
    if (this.destroyed) {
      return new SDKError("Failed to create Geometry in SceneModel - SceneModel already destroyed");
    }
    if (this.built) {
      return new SDKError("Failed to create Geometry in SceneModel - SceneModel already built");
    }
    if (!geometryParams) {
      return new SDKError("Failed to create Geometry in SceneModel - Parameters expected: geometryParams");
    }
    if (geometryParams.id === null || geometryParams.id === undefined) {
      return new SDKError("Failed to create Geometry in SceneModel - Parameter expected: geometryParams.id");
    }
    var geometryId = geometryParams.id;
    if (this.geometries[geometryId]) {
      return new SDKError("Failed to create Geometry in SceneModel - Geometry with this ID already created: " + geometryId);
    }
    var primitive = geometryParams.primitive;
    if (primitive !== PointsPrimitive && primitive !== LinesPrimitive && primitive !== TrianglesPrimitive && primitive !== SolidPrimitive && primitive !== SurfacePrimitive) {
      return new SDKError("Failed to create Geometry in SceneModel - Unsupported value for geometryParams.primitive: '" + primitive + "' - supported values are PointsPrimitive, LinesPrimitive, TrianglesPrimitive, SolidPrimitive and SurfacePrimitive");
    }
    if (!geometryParams.positions) {
      return new SDKError("Failed to create Geometry in SceneModel - Param expected: geometryParams.positions");
    }
    if (!geometryParams.indices && primitive !== PointsPrimitive) {
      return new SDKError("Failed to create Geometry in SceneModel - Param expected: geometryParams.indices (required for primitive type)");
    }
    if (geometryParams.uvs) {
      if (geometryParams.uvs.length / 2 !== geometryParams.positions.length / 3) {
        return new SDKError("Failed to create Geometry in SceneModel - mismatch between given quantities of vertex positions and UVs");
      }
    }
    if (geometryParams.indices) {
      var lastPositionsIdx = geometryParams.positions.length / 3;
      for (var i = 0, len = geometryParams.indices.length; i < len; i++) {
        var idx = geometryParams.indices[i];
        if (idx < 0 || idx >= lastPositionsIdx) {
          return new SDKError("Failed to create Geometry in SceneModel - indices out of range of vertex positions");
        }
        if (geometryParams.uvs) {
          var lastUVsIdx = geometryParams.uvs.length / 2;
          if (idx < 0 || idx >= lastUVsIdx) {
            return new SDKError("Failed to create Geometry in SceneModel - indices out of range of vertex UVs");
          }
        }
      }
    }
    var geometry = new Geometry(compressGeometryParams(geometryParams));
    this.geometries[geometryId] = geometry;
    this.stats.numGeometries++;
    if (geometryParams.indices) {
      if (geometry.primitive === TrianglesPrimitive) {
        this.stats.numTriangles += geometryParams.indices.length / 3;
      } else if (geometry.primitive === LinesPrimitive) {
        this.stats.numLines += geometryParams.indices.length / 2;
      }
    } else if (geometry.primitive === PointsPrimitive) {
      this.stats.numPoints += geometryParams.positions.length / 3;
    }
    this.stats.numVertices += geometryParams.positions.length / 3;
    return geometry;
  }
  /**
   * Creates a new {@link @xeokit/scene!Geometry} within this SceneModel, from pre-compressed geometry parameters.
   *
   * * Stores the new {@link @xeokit/scene!Geometry} in {@link @xeokit/scene!SceneModel.geometries | SceneModel.geometries}.
   * * Use {@link @xeokit/scene!compressGeometryParams} to pre-compress {@link @xeokit/scene!GeometryParams | GeometryParams}
   * into {@link @xeokit/scene!GeometryCompressedParams | GeometryCompressedParams}.
   *
   * ### Usage
   *
   * ````javascript
   * const boxGeometry = sceneModel.createGeometryCompressed({
   *      id: "boxGeometry",
   *      primitive: TrianglesPrimitive, // @xeokit/constants
   *      positionsDecompressMatrix: [
   *          0.00003052270125906143, 0, 0, 0,
   *          0, 0.00003052270125906143, 0, 0,
   *          0, 0, 0.00003052270125906143, 0,
   *          -1, -1, -1, 1
   *      ],
   *      geometryBuckets: [
   *          {
   *              positionsCompressed: [
   *                  65525, 65525, 65525, 0, 65525, 65525, 0, 0,
   *                  65525, 65525, 0, 65525, 65525, 0, 0, 65525,
   *                  65525, 0, 0, 65525, 0, 0, 0, 0
   *              ],
   *              indices: [
   *                  0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 5, 0, 5, 6,
   *                  0, 6, 1, 1, 6, 7, 1, 7, 2, 7, 4, 3, 7, 3, 2,
   *                  4, 7, 6, 4, 6, 5
   *              ]
   *          }
   *      ]
   * });
   *
   * if (boxGeometry instanceof SDKError) {
   *     console.log(boxGeometry.message);
   * } else {
   *      const boxGeometryAgain = sceneModel.geometries["boxGeometry"];
   * }
   * ````
   *
   * See {@link "@xeokit/scene"} for more usage info.
   *
   * @param geometryCompressedParams Pre-compressed geometry parameters.
   * @returns *{@link @xeokit/scene!Geometry}*
   * * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * If this SceneModel has already been destroyed.
   * * If this SceneModel has already been built.
   * * Invalid GeometryParams were given.
   * * Geometry of given ID already exists in this SceneModel.
   * * Unsupported primitive type given.
   * * Mandatory vertex positions were not given. Vertex positions are mandatory for all primitive types.
   * * Mandatory indices were not given for primitive type that is not {@link @xeokit/constants!PointsPrimitive}. Indices are mandatory for all primitive types except PointsPrimitive.
   * * Indices out of range of vertex positions.
   * * Indices out of range of vertex UVs.
   * * Mismatch between given quantities of vertex positions and UVs.
   */;
  _proto.createGeometryCompressed = function createGeometryCompressed(geometryCompressedParams) {
    if (this.destroyed) {
      return new SDKError("Failed to add compressed Geometry to SceneModel - SceneModel already destroyed");
    }
    if (this.built) {
      return new SDKError("Failed to add compressed Geometry to SceneModel - SceneModel already built");
    }
    if (!geometryCompressedParams) {
      return new SDKError("Failed to add compressed Geometry to SceneModel - Parameters expected: geometryCompressedParams");
    }
    var geometryId = geometryCompressedParams.id;
    if (this.geometries[geometryId]) {
      return new SDKError("Failed to add compressed Geometry to SceneModel - Geometry with this ID already created: " + geometryId);
    }
    var primitive = geometryCompressedParams.primitive;
    if (primitive !== PointsPrimitive && primitive !== LinesPrimitive && primitive !== TrianglesPrimitive && primitive !== SolidPrimitive && primitive !== SurfacePrimitive) {
      return new SDKError("Failed to add compressed Geometry to SceneModel - Unsupported value for geometryCompressedParams.primitive: '" + primitive + "' - supported values are PointsPrimitive, LinesPrimitive, TrianglesPrimitive, SolidPrimitive and SurfacePrimitive");
    }
    var geometry = new Geometry(geometryCompressedParams);
    this.geometries[geometryId] = geometry;
    this.stats.numGeometries++;
    return geometry;
  }
  /**
   * Creates a new {@link @xeokit/scene!Mesh} within this SceneModel.
   *
   * * Stores the new {@link @xeokit/scene!Mesh} in {@link @xeokit/scene!SceneModel.meshes | SceneModel.meshes}.
   * * A {@link @xeokit/scene!Mesh} can be owned by one {@link @xeokit/scene!SceneObject}, which can own multiple {@link @xeokit/scene!Mesh}es.
   *
   * ### Usage
   *
   * ````javascript
   * const redBoxMesh = sceneModel.createMesh({
   *      id: "redBoxMesh",
   *      geometryId: "boxGeometry",
   *      textureSetId: "myTextureSet",
   *      position: [-4, -6, -4],
   *      scale: [1, 3, 1],
   *      rotation: [0, 0, 0],
   *      color: [1, 0.3, 0.3]
   * });
   *
   * if (redBoxMesh instanceof SDKError) {
   *      console.log(redBoxMesh.message);
   * } else {
   *      const redBoxMeshAgain = sceneModel.meshes["redBoxMesh"];
   * }
   * ````
   *
   * See {@link "@xeokit/scene"} for more usage info.
   *
   * @param meshParams Pre-compressed mesh parameters.
   * @returns *{@link @xeokit/scene!Mesh}*
   *  * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * If this SceneModel has already been destroyed.
   * * If this SceneModel has already been built.
   * * Invalid MeshParams were given.
   * * Mesh of given ID already exists in this SceneModel.
   * * Specified Geometry could not be found in this SceneModel.
   * * Specified TextureSet could not be found in this SceneModel.
   */;
  _proto.createMesh = function createMesh(meshParams) {
    if (this.destroyed) {
      return new SDKError("Failed to create Mesh in SceneModel - SceneModel already destroyed");
    }
    if (this.built) {
      return new SDKError("Failed to create Mesh in SceneModel - SceneModel already built");
    }
    if (this.meshes[meshParams.id]) {
      return new SDKError("Failed to create Mesh in SceneModel - Mesh already exists with this ID: " + meshParams.id);
    }
    var geometry = this.geometries[meshParams.geometryId];
    if (!geometry) {
      return new SDKError("Failed to create Mesh in SceneModel - Geometry not found: " + meshParams.geometryId);
    }
    var textureSet = meshParams.textureSetId ? this.textureSets[meshParams.textureSetId] : undefined;
    if (meshParams.textureSetId && !textureSet) {
      return new SDKError("Failed to create Mesh in SceneModel - TextureSet not found: " + meshParams.textureSetId);
    }
    // geometry.numInstances++;
    // let matrix = meshParams.matrix;
    // if (!matrix) {
    //     const position = meshParams.position;
    //     const scale = meshParams.scale;
    //     const rotation = meshParams.rotation;
    //     if (position || scale || rotation) {
    //         matrix = identityMat4();
    //         const quaternion = eulerToQuat(rotation || [0, 0, 0], "XYZ", identityQuat());
    //         composeMat4(position || [0, 0, 0], quaternion, scale || [1, 1, 1], matrix)
    //     } else {
    //         matrix = identityMat4();
    //     }
    // }
    // const meshIndex = this.meshesList.length;
    var mesh = new Mesh({
      id: meshParams.id,
      geometry: geometry,
      textureSet: textureSet,
      matrix: meshParams.matrix,
      color: meshParams.color,
      opacity: meshParams.opacity,
      roughness: meshParams.roughness,
      metallic: meshParams.metallic
    });
    this.meshes[meshParams.id] = mesh;
    this.stats.numMeshes++;
    return mesh;
  }
  /**
   * Creates a new {@link @xeokit/scene!SceneObject}.
   *
   * * Stores the new {@link @xeokit/scene!SceneObject} in {@link @xeokit/scene!SceneModel.objects | SceneModel.objects} and {@link @xeokit/scene!Scene.objects | Scene.objects}.
   * * Fires an event via {@link @xeokit/scene!Scene.onObjectCreated | Scene.onObjectCreated}.
   * * Each {@link @xeokit/scene!Mesh} is allowed to belong to one SceneObject.
   * * SceneObject IDs must be unique within the SceneModel's {@link @xeokit/scene!Scene}.
   *
   * ### Usage
   *
   * ````javascript
   * const redBoxObject = sceneModel.createObject({
   *     id: "redBoxObject",
   *     meshIds: ["redBoxMesh"]
   * });
   *
   * if (redBoxObject instanceof SDKError) {
   *      console.log(redBoxObject.message);
   * } else {
   *      const redBoxObjectAgain = sceneModel.objects["redBoxObject"];
   *      const redBoxObjectOnceMore = scene.objects["redBoxObject"];
   * }
   * ````
   *
   * See {@link "@xeokit/scene"} for more usage info.
   *
   * @param objectParams SceneObject parameters.
   * @returns *{@link @xeokit/scene!SceneObject}*
   * * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * If this SceneModel has already been destroyed.
   * * If this SceneModel has already been built.
   * * Invalid ObjectParams were given.
   * * SceneObject of given ID already exists in this SceneModel's Scene. Note that SceneObject IDs must be unique within the Scene.
   * * No Meshes were specified.
   * * One or more of the specified Meshes already belong to another SceneObject in this SceneModel.
   * * Specified Meshes could not be found in this SceneModel.
   */;
  _proto.createObject = function createObject(objectParams) {
    if (this.destroyed) {
      return new SDKError("Failed to create SceneObject - SceneModel already destroyed");
    }
    if (this.built) {
      return new SDKError("Failed to create SceneObject SceneModel already built");
    }
    if (objectParams.meshIds.length === 0) {
      return new SDKError("Failed to create SceneObject - no meshes specified");
    }
    if (this.scene.objects[objectParams.id]) {
      return new SDKError("Failed to create SceneObject - SceneObject already exists in Scene: " + objectParams.id);
    }
    var meshIds = objectParams.meshIds;
    var meshes = [];
    for (var meshIdIdx = 0, meshIdLen = meshIds.length; meshIdIdx < meshIdLen; meshIdIdx++) {
      var meshId = meshIds[meshIdIdx];
      var mesh = this.meshes[meshId];
      if (!mesh) {
        return new SDKError("Failed to create SceneObject - Mesh not found: " + meshId);
      }
      if (_classPrivateFieldLooseBase(this, _meshUsedByObject)[_meshUsedByObject][meshId]) {
        return new SDKError("Failed to create SceneObject - Mesh " + meshId + " already belongs to another SceneObject");
      }
      meshes.push(mesh);
      _classPrivateFieldLooseBase(this, _meshUsedByObject)[_meshUsedByObject][mesh.id] = true;
    }
    var sceneObject = new SceneObject({
      id: objectParams.id,
      layerId: objectParams.layerId || this.layerId,
      model: this,
      meshes: meshes
    });
    for (var i = 0, len = meshes.length; i < len; i++) {
      var _mesh = meshes[i];
      _mesh.object = sceneObject;
    }
    _classPrivateFieldLooseBase(this, _numObjects$2)[_numObjects$2]++;
    this.objects[objectParams.id] = sceneObject;
    this.stats.numObjects++;
    return sceneObject;
  }
  /**
   * Finalizes this SceneModel, readying it for use.
   *
   * * Fires an event via {@link @xeokit/scene!SceneModel.onBuilt | SceneModel.onBuilt} and {@link @xeokit/scene!Scene.onModelCreated | SceneModel.onCreated}, to indicate to subscribers that
   * the SceneModel is complete and ready to use.
   * * Sets {@link @xeokit/scene!SceneModel.built | SceneModel.built} ````true````.
   * * You can only call this method once on a SceneModel.
   * * The SceneModel must have at least one {@link @xeokit/scene!SceneObject}.
   * * Once built, no more components can be created in a SceneModel.
   *
   * ### Usage
   *
   * ````javascript
   * sceneMode.onBuilt.subscribe(()=>{
   *     // Our SceneModel is built and ready to use
   * });
   *
   * myScene.onModelCreated.subscribe((sceneModel)=>{
   *     // Another way to subscribe to SceneModel readiness
   * });
   *
   * mySceneModel.build().then((result) => { // Asynchronous (texture compression etc).
   *      if (result instanceof SDKError) {
   *          console.log(result.message);
   *      }  else {
   *          // Now we can do things with our SceneModel
   *      }
   * }).catch(sdkError) {// SDKError
   *     console.log(sdkError.message);
   * };
   * ````
   *
   * See {@link "@xeokit/scene"} for more usage info.
   *
   * @throws *{@link @xeokit/core!SDKError}*
   * * If SceneModel has already been built or destroyed.
   * * If no SceneObjects were created in this SceneModel.
   */;
  _proto.build = function build() {
    var _this2 = this;
    return new Promise(function (resolve) {
      if (_this2.destroyed) {
        throw new SDKError("Failed to build SceneModel - SceneModel already destroyed");
      }
      if (_this2.built) {
        throw new SDKError("Failed to build SceneModel - SceneModel already built");
      }
      _classPrivateFieldLooseBase(_this2, _removeUnusedTextures)[_removeUnusedTextures]();
      // this.#compressTextures().then(() => {
      _this2.built = true;
      _this2.onBuilt.dispatch(_this2, null);
      resolve(_this2);
      // }).catch((e) => {
      //     throw e;
      // });
    });
  };
  return SceneModel;
}(Component);
function _removeUnusedTextures2() {
  // let texturesList = [];
  // const textures = {};
  // for (let i = 0, leni = this.texturesList.length; i < leni; i++) {
  //     const texture = this.texturesList[i];
  //     if (texture.channel !== null) {
  //         texture.textureIndex = texturesList.length;
  //         texturesList.push(texture);
  //         textures[texture.id] = texture;
  //     }
  // }
  // this.texturesList = texturesList;
  // this.textures = textures;
}

/**
 * A scene representation.
 *
 * A Scene is a container of {@link @xeokit/scene!SceneModel | SceneModels} and {@link @xeokit/scene!SceneObject | SceneObjects}.
 */
var _onModelBuilts = /*#__PURE__*/_classPrivateFieldLooseKey("onModelBuilts");
var _onModelDestroys = /*#__PURE__*/_classPrivateFieldLooseKey("onModelDestroys");
var _center = /*#__PURE__*/_classPrivateFieldLooseKey("center");
var _aabbDirty = /*#__PURE__*/_classPrivateFieldLooseKey("aabbDirty");
var _aabb = /*#__PURE__*/_classPrivateFieldLooseKey("aabb");
var _registerObjects = /*#__PURE__*/_classPrivateFieldLooseKey("registerObjects");
var _deregisterObjects = /*#__PURE__*/_classPrivateFieldLooseKey("deregisterObjects");
var Scene = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Scene, _Component);
  /**
   * Creates a new Scene.
   *
   * See {@link "@xeokit/scene"} for usage.
   */
  function Scene() {
    var _this;
    _this = _Component.call(this, null, {}) || this;
    Object.defineProperty(_assertThisInitialized(_this), _deregisterObjects, {
      value: _deregisterObjects2
    });
    Object.defineProperty(_assertThisInitialized(_this), _registerObjects, {
      value: _registerObjects2
    });
    /**
     * The {@link @xeokit/scene!SceneModel | SceneModels} belonging to this Scene, each keyed to
     * its {@link @xeokit/scene!SceneModel.id | SceneModel.id}.
     */
    _this.models = void 0;
    /**
     * The {@link @xeokit/scene!SceneObject | SceneObjects} in this Scene, mapped to {@link @xeokit/scene!SceneObject.id | SceneObject.id}.
     */
    _this.objects = void 0;
    /**
     * Emits an event each time a {@link @xeokit/scene!SceneModel} is created in this Scene.
     *
     * @event
     */
    _this.onModelCreated = void 0;
    /**
     * Emits an event each time a {@link @xeokit/scene!SceneModel} is destroyed in this Scene.
     *
     * @event
     */
    _this.onModelDestroyed = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _onModelBuilts, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _onModelDestroys, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _center, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _aabbDirty, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _aabb, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _aabb)[_aabb] = createAABB3();
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _aabbDirty)[_aabbDirty] = true;
    _this.models = {};
    _this.objects = {};
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _onModelBuilts)[_onModelBuilts] = {};
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _onModelDestroys)[_onModelDestroys] = {};
    _this.onModelCreated = new EventEmitter(new dist.EventDispatcher());
    _this.onModelDestroyed = new EventEmitter(new dist.EventDispatcher());
    return _this;
  }
  /**
   * Gets the collective World-space 3D center of all the {@link @xeokit/scene!SceneModel | SceneModels} in this Scene.
   */
  var _proto = Scene.prototype;
  /**
   * Creates a new {@link @xeokit/scene!SceneModel} in this Scene.
   *
   * Remember to call {@link @xeokit/scene!SceneModel.build | SceneModel.build} when you've finished building or
   * loading the SceneModel. That will
   * fire events via {@link @xeokit/scene!Scene.onModelCreated | Scene.onModelCreated} and {@link @xeokit/scene!SceneModel.onBuilt | SceneModel.onBuilt}, to
   * indicate to any subscribers that the SceneModel is built and ready for use.
   *
   * See {@link "@xeokit/scene"} for more details on usage.
   *
   * @param  sceneModelParams Creation parameters for the new {@link @xeokit/scene!SceneModel}.
   * @returns *{@link @xeokit/scene!SceneModel}*
   * * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * This Scene has already been destroyed.
   * * A SceneModel with the given ID already exists in this Scene.
   */
  _proto.createModel = function createModel(sceneModelParams) {
    var _this2 = this;
    if (this.destroyed) {
      return new SDKError("Scene already destroyed");
    }
    var id = sceneModelParams.id;
    if (this.models[id]) {
      return new SDKError("SceneModel already created in this Scene: " + id);
    }
    var sceneModel = new SceneModel(this, sceneModelParams);
    this.models[id] = sceneModel;
    sceneModel.onDestroyed.one(function () {
      delete _this2.models[sceneModel.id];
      _classPrivateFieldLooseBase(_this2, _deregisterObjects)[_deregisterObjects](sceneModel);
      _this2.onModelDestroyed.dispatch(_this2, sceneModel);
    });
    sceneModel.onBuilt.one(function () {
      _classPrivateFieldLooseBase(_this2, _registerObjects)[_registerObjects](sceneModel);
      _this2.onModelCreated.dispatch(_this2, sceneModel);
    });
    return sceneModel;
  }
  /**
   * @private
   */;
  _proto.setAABBDirty = function setAABBDirty() {
    if (!_classPrivateFieldLooseBase(this, _aabbDirty)[_aabbDirty]) {
      _classPrivateFieldLooseBase(this, _aabbDirty)[_aabbDirty] = true;
      //this.events.fire("aabb", true);
    }
  }
  /**
   * Destroys all contained {@link @xeokit/scene!SceneModel | SceneModels}.
   *
   * * Fires {@link @xeokit/scene!Scene.onModelDestroyed | Scene.onModelDestroyed} and
   * {@link @xeokit/scene!SceneModel.onDestroyed | SceneModel.onDestroyed} for each existing SceneModel in this Scene.
   *
   * See {@link "@xeokit/scene"} for usage.
   * @returns *void*
   * * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * This Scene has already been destroyed.
   */;
  _proto.clear = function clear() {
    if (this.destroyed) {
      return new SDKError("Scene already destroyed");
    }
    for (var id in this.models) {
      this.models[id].destroy();
    }
  }
  /**
   * Destroys this Scene and all contained {@link @xeokit/scene!SceneModel | SceneModels}.
   *
   * * Fires {@link @xeokit/scene!Scene.onModelDestroyed | Scene.onModelDestroyed} and {@link @xeokit/scene!SceneModel.onDestroyed | SceneModel.onDestroyed}
   * for each existing SceneModels in this Data.
   * * Unsubscribes all subscribers to {@link @xeokit/scene!Scene.onModelCreated | Scene.onModelCreated}, {@link @xeokit/scene!Scene.onModelDestroyed | Scene.onModelDestroyed}, {@link @xeokit/scene!SceneModel.onDestroyed | SceneModel.onDestroyed}
   *
   * See {@link "@xeokit/scene"} for usage.
   *
   * @returns *void*
   * * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * This Scene has already been destroyed.
   */;
  _proto.destroy = function destroy() {
    this.clear();
    this.onModelCreated.clear();
    this.onModelDestroyed.clear();
    _Component.prototype.destroy.call(this);
  };
  _createClass(Scene, [{
    key: "center",
    get: function get() {
      if (_classPrivateFieldLooseBase(this, _aabbDirty)[_aabbDirty]) {
        var aabb = this.aabb; // Lazy-build
        _classPrivateFieldLooseBase(this, _center)[_center][0] = (aabb[0] + aabb[3]) / 2;
        _classPrivateFieldLooseBase(this, _center)[_center][1] = (aabb[1] + aabb[4]) / 2;
        _classPrivateFieldLooseBase(this, _center)[_center][2] = (aabb[2] + aabb[5]) / 2;
      }
      return _classPrivateFieldLooseBase(this, _center)[_center];
    }
    /**
     * Gets the collective World-space 3D [axis-aligned boundary](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#aabb) of all the {@link @xeokit/scene!SceneModel | SceneModels} in this Scene.
     *
     * The boundary will be of the form ````[xMin, yMin, zMin, xMax, yMax, zMax]````.
     */
  }, {
    key: "aabb",
    get: function get() {
      if (_classPrivateFieldLooseBase(this, _aabbDirty)[_aabbDirty]) {
        var xmin = MAX_DOUBLE;
        var ymin = MAX_DOUBLE;
        var zmin = MAX_DOUBLE;
        var xmax = MIN_DOUBLE;
        var ymax = MIN_DOUBLE;
        var zmax = MIN_DOUBLE;
        var aabb;
        var objects = this.objects;
        var valid = false;
        for (var objectId in objects) {
          if (objects.hasOwnProperty(objectId)) {
            var object = objects[objectId];
            // if (object.collidable === false) {
            //     continue;
            // }
            aabb = object.aabb;
            if (aabb[0] < xmin) {
              xmin = aabb[0];
            }
            if (aabb[1] < ymin) {
              ymin = aabb[1];
            }
            if (aabb[2] < zmin) {
              zmin = aabb[2];
            }
            if (aabb[3] > xmax) {
              xmax = aabb[3];
            }
            if (aabb[4] > ymax) {
              ymax = aabb[4];
            }
            if (aabb[5] > zmax) {
              zmax = aabb[5];
            }
            valid = true;
          }
        }
        if (!valid) {
          xmin = -100;
          ymin = -100;
          zmin = -100;
          xmax = 100;
          ymax = 100;
          zmax = 100;
        }
        _classPrivateFieldLooseBase(this, _aabb)[_aabb][0] = xmin;
        _classPrivateFieldLooseBase(this, _aabb)[_aabb][1] = ymin;
        _classPrivateFieldLooseBase(this, _aabb)[_aabb][2] = zmin;
        _classPrivateFieldLooseBase(this, _aabb)[_aabb][3] = xmax;
        _classPrivateFieldLooseBase(this, _aabb)[_aabb][4] = ymax;
        _classPrivateFieldLooseBase(this, _aabb)[_aabb][5] = zmax;
        _classPrivateFieldLooseBase(this, _aabbDirty)[_aabbDirty] = false;
      }
      return _classPrivateFieldLooseBase(this, _aabb)[_aabb];
    }
  }]);
  return Scene;
}(Component);
function _registerObjects2(model) {
  var objects = model.objects;
  for (var id in objects) {
    var object = objects[id];
    this.objects[object.id] = object;
  }
  _classPrivateFieldLooseBase(this, _aabbDirty)[_aabbDirty] = true;
}
function _deregisterObjects2(model) {
  var objects = model.objects;
  for (var id in objects) {
    var object = objects[id];
    delete this.objects[object.id];
  }
  _classPrivateFieldLooseBase(this, _aabbDirty)[_aabbDirty] = true;
}

/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2FscratchModel.svg)](https://badge.fury.io/js/%40xeokit%2FscratchModel)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/scratchModel/badge)](https://www.jsdelivr.com/package/npm/@xeokit/scratchModel)
 *
 * <img style="padding:20px" src="media://images/xeokit_docmodel_greyscale_icon.png"/>
 *
 * # xeokit Scene Representation
 *
 * ---
 *
 * ### *The SDK's buildable, viewable, importable and exportable 3D scene representation*
 *
 * ---
 *
 * The xeokit SDK facilitates the management of model representations through a scene graph that incorporates the
 * model's objects, geometries, and materials. This scene graph functions seamlessly in both the browser and NodeJS
 * environments, enabling the generation of models, format conversion, and the provision of content for the SDK's
 * model viewer.
 *
 * To elaborate further:
 *
 * * The {@link @xeokit/scene!Scene} acts as a container for {@link @xeokit/scene!SceneModel | SceneModels}, which, in turn,
 * comprise {@link @xeokit/scene!SceneObject | SceneObjects}, {@link @xeokit/scene!Mesh | Meshes}, {@link @xeokit/scene!Geometry | Geometries}, {@link @xeokit/scene!GeometryBucket | GeometryBuckets}, and {@link @xeokit/scene!Texture | Textures}.
 * * Textures undergo compression to [KTX2](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#ktx2) via the Basis Universal codec.
 * * Geometry undergoes compression through bucketing and quantization.
 * * Use a {@link "@xeokit/viewer" | Viewer} to view SceneModels in the browser. A Viewer equipped with a {@link @xeokit/ktx2!KTX2TextureTranscoder | KTX2TextureTranscoder} can view a Scene that has KTX2-compressed textures.
 * * Import SceneModels from a variety of model file formats using importer functions like {@link "@xeokit/gltf" | loadGLTF}, {@link "@xeokit/las" | loadLAS}, {@link "@xeokit/cityjson" | loadCityJSON}, and {@link "@xeokit/xkt" | loadXKT}.
 * * Export SceneModels to the native [XKT](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#xkt) format through {@link "@xeokit/xkt" | saveXKT}.
 * * Create SceneModels programmatically using builder methods like {@link @xeokit/scene!Scene.createModel | Scene.createModel},
 * {@link @xeokit/scene!SceneModel.createObject | SceneModel.createObject}, {@link @xeokit/scene!SceneModel.createMesh | SceneModel.createMesh},
 * {@link @xeokit/scene!SceneModel.createGeometry | SceneModel.createGeometry}, and {@link @xeokit/scene!SceneModel.createTexture | SceneModel.createTexture}. Add geometry
 * primitives using mesh generator functions like {@link @xeokit/procgen!buildBoxGeometry | buildBoxGeometry}, {@link @xeokit/procgen!buildSphereGeometry | buildSphereGeometry}, {@link @xeokit/procgen!buildTorusGeometry | buildTorusGeometry}, {@link @xeokit/procgen!buildCylinderGeometry | buildCylinderGeometry}, {@link @xeokit/procgen!buildPlaneGeometry | buildPlaneGeometry} and {@link @xeokit/procgen!buildVectorTextGeometry | buildVectorTextGeometry}.
 *
 * <br>
 *
 * [![](https://mermaid.ink/img/pako:eNqNVU2PmzAQ_SvIp3aVjTaJk0AOPbQr7aVRpc2qlSoujplN3AJGttkmjfLfawwkNph0uQBvnufNh8c-IcoTQCtEUyLlIyM7QbI4T5gAqhjPg6_PcR6YxzCCDYUcTi1mcAFEwVq7ST98dAwpEOFCWcWSNsK3v7TSBTp71IxrS5Il1-_O8koC5B5sYAc8AyWYAyo4qFLABpQHtaA6uW9GxU6lSVpr9dGnWvDYt7zU_gcNOhzbti1ZmthAAlIJbjn2lasO1mmRXTFPhQJCttsBl1WKwUDxKU-5uP4KXu72OUjLta4DSV2IF4QydbQ4RDfncP1v-mUxrs0aCLIpnz9OP1c7u5lWQ-ukkjL63GbZY3BK01LqoelZIGNSsjfoGDqRtftmKK5CsIwp7caCuGTVmMpHoDwr9NaV6045y7cbxrbWn0v6Gwan8Mlh2eFd9L80ApA4yj6Y6dOFwv-0vjP44yi1yb8cC18BfnCR3hRxZXagrGHpV_4SVfs27CBGkxjd3d_r93h8FyPrgHKIBhlg15Lv8eth1lCfX41pS7xk02O5jWz5ZsQtrkVsKdbQOE6x5nY2tcfbizW_10YMtKBd-qle6ynE-xbaG6ldiUYoA5ERlugbz_Q6RmoPGcRopT8TeCVlqmIU52dNJaXim2NO0eqVpBJGqCwSfVY3l-QFhYQpLtbNNVq9RqggOVqd0AGtpouH8WSyxOFiOo9meDnDI3TU8GyMo-UixBGehOEyCqfnEfrLuXb7MA6nC4wX0wgvQzzH88j4-2mMSpRw_geACkF7?type=png)](https://mermaid.live/edit#pako:eNqNVU2PmzAQ_SvIp3aVjTaJk0AOPbQr7aVRpc2qlSoujplN3AJGttkmjfLfawwkNph0uQBvnufNh8c-IcoTQCtEUyLlIyM7QbI4T5gAqhjPg6_PcR6YxzCCDYUcTi1mcAFEwVq7ST98dAwpEOFCWcWSNsK3v7TSBTp71IxrS5Il1-_O8koC5B5sYAc8AyWYAyo4qFLABpQHtaA6uW9GxU6lSVpr9dGnWvDYt7zU_gcNOhzbti1ZmthAAlIJbjn2lasO1mmRXTFPhQJCttsBl1WKwUDxKU-5uP4KXu72OUjLta4DSV2IF4QydbQ4RDfncP1v-mUxrs0aCLIpnz9OP1c7u5lWQ-ukkjL63GbZY3BK01LqoelZIGNSsjfoGDqRtftmKK5CsIwp7caCuGTVmMpHoDwr9NaV6045y7cbxrbWn0v6Gwan8Mlh2eFd9L80ApA4yj6Y6dOFwv-0vjP44yi1yb8cC18BfnCR3hRxZXagrGHpV_4SVfs27CBGkxjd3d_r93h8FyPrgHKIBhlg15Lv8eth1lCfX41pS7xk02O5jWz5ZsQtrkVsKdbQOE6x5nY2tcfbizW_10YMtKBd-qle6ynE-xbaG6ldiUYoA5ERlugbz_Q6RmoPGcRopT8TeCVlqmIU52dNJaXim2NO0eqVpBJGqCwSfVY3l-QFhYQpLtbNNVq9RqggOVqd0AGtpouH8WSyxOFiOo9meDnDI3TU8GyMo-UixBGehOEyCqfnEfrLuXb7MA6nC4wX0wgvQzzH88j4-2mMSpRw_geACkF7)
 *
 * <br>
 *
 * ### Notes
 *
 * * TextureSets are collections of textures that are shared among Meshes and are organized into texture atlasses to optimize rendering efficiency on GPUs.
 * * Geometries are arranged automatically into {@link @xeokit/scene!GeometryBucket | GeometryBuckets} to reduce memory consumption. These buckets utilize geometry quantization and geometry bucketing techniques to minimize storage bit usage.
 * * Each Mesh can be assigned to only one SceneObject, whereas each Geometry and TextureSet can be allocated to an unlimited number of Meshes.
 * * The {@link getSceneObjectGeometry} function can be used to conveniently iterate the World-space geometry within each
 * {@link @xeokit/scene!SceneObject | SceneObject} - useful for building k-d trees, finding intersections etc.
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/scene
 * ````
 *
 * ## Usage
 *
 * * [Creating a SceneModel](#creating-a-scenemodel)
 * * [Reading the SceneModel](#reading-the-scenemodel)
 * * [Geometry Compression](#geometry-compression)
 * * [Texture Compression](#texture-compression)
 *
 * ### Creating a SceneModel
 *
 * In the example below, we'll create a {@link @xeokit/scene!SceneModel | SceneModel} that will model the simple table furniture model
 * shown in the image above. Our SceneModel will get five
 * {@link @xeokit/scene!SceneObject | SceneObjects}, five {@link @xeokit/scene!Mesh | Meshes},
 * a {@link @xeokit/scene!Geometry | Geometry} and a {@link @xeokit/scene!Texture | Texture}.
 *
 * When we've finished constructing our SceneModel, we'll call {@link @xeokit/scene!SceneModel.build | SceneModel.build}, which
 * (asynchronously) compresses our Texture.
 *
 * At that point, we can use the SceneModel. For example, we could export it to xeokit's native [XKT](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#xkt)
 * file format using {@link "@xeokit/xkt" | saveXKT}, or view it in the Browser using a {@link "@xeokit/viewer" | Viewer}.
 *
 * ````javascript
 * import {Scene} from "@xeokit/scene";
 * import {TrianglesPrimitive, LinearEncoding, LinearFilter, ClampToEdgeWrapping} from "@xeokit/constants";
 *
 * // Scene is the container of SceneModels
 *
 * const theScene = new Scene();
 *
 * const sceneModel = theScene.createModel({
 *   id: "theModel"
 * });
 *
 * if (sceneModel instanceof SDKError) {
 *
 *      // Most SDK methods return an SDKError when
 *      // something goes wrong.
 *
 *      // We'll use some SDKErrors in this example
 *      // to demonstrate where we can use them.
 *
 *      console.log(sceneModel.message);
 *
 * } else {
 *
 *      const geometry = sceneModel.createGeometry({
 *          id: "boxGeometry",
 *          primitive: TrianglesPrimitive,
 *          positions: [ // Floats
 *              1, 1, 1, -1, 1, 1,
 *              -1, -1, 1, 1, -1, 1, 1,
 *              -1, -1, 1, 1, -1, -1, 1, -1, -1,
 *              -1, -1
 *          ],
 *          indices: [
 *              0, 1, 2, 0, 2, 3, 4, 5, 6, 4,
 *              6, 7, 8, 9, 10, 8, 10, 11, 12,
 *              13, 14, 12, 14, 15, 16, 17, 18,
 *              16, 18, 19, 20, 21, 22, 20, 22, 23
 *          ]
 *      });
 *
 *      if (geometry instanceof SDKError) {
 *          console.log(geometry.message);
 *      }
 *
 *      const texture = sceneModel.createTexture({
 *          id: "colorTexture",
 *          src: "./assets/sample_etc1s.ktx2",
 *          preloadColor: [1, 0, 0, 1],
 *          flipY: false,
 *          encoding: LinearEncoding,
 *          magFilter: LinearFilter,
 *          minFilter: LinearFilter,
 *          wrapR: ClampToEdgeWrapping,
 *          wrapS: ClampToEdgeWrapping,
 *          wrapT: ClampToEdgeWrapping,
 *      });
 *
 *      if (texture instanceof SDKError) {
 *          console.log(texture.message);
 *      }
 *
 *      const theTextureSet = sceneModel.createTextureSet({
 *          id: "theTextureSet",
 *          colorTextureId: "colorTexture"
 *      });
 *
 *      if (theTextureSet instanceof SDKError) {
 *          console.log(theTextureSet.message);
 *      }
 *
 *      const redLegMesh = sceneModel.createMesh({
 *          id: "redLegMesh",
 *          geometryId: "boxGeometry",
 *          position: [-4, -6, -4],
 *          scale: [1, 3, 1],
 *          rotation: [0, 0, 0],
 *          color: [1, 0.3, 0.3],
 *          textureSetId: "theTextureSet"
 *      });
 *
 *      if (redLegMesh instanceof SDKError) {
 *          console.log(redLegMesh.message);
 *      }
 *
 *      const greenLegMesh = sceneModel.createMesh({
 *          id: "greenLegMesh",
 *          geometryId: "boxGeometry",
 *          position: [4, -6, -4],
 *          scale: [1, 3, 1],
 *          rotation: [0, 0, 0],
 *          color: [0.3, 1.0, 0.3],
 *          textureSetId: "theTextureSet"
 *      });
 *
 *      const blueLegMesh = sceneModel.createMesh({
 *          id: "blueLegMesh",
 *          geometryId: "boxGeometry",
 *          position: [4, -6, 4],
 *          scale: [1, 3, 1],
 *          rotation: [0, 0, 0],
 *          color: [0.3, 0.3, 1.0],
 *          textureSetId: "theTextureSet"
 *      });
 *
 *      const yellowLegMesh = sceneModel.createMesh({
 *          id: "yellowLegMesh",
 *          geometryId: "boxGeometry",
 *          position: [-4, -6, 4],
 *          scale: [1, 3, 1],
 *          rotation: [0, 0, 0],
 *          color: [1.0, 1.0, 0.0],
 *          textureSetId: "theTextureSet"
 *      });
 *
 *      const tableTopMesh = sceneModel.createMesh({
 *          id: "tableTopMesh",
 *          geometryId: "boxGeometry",
 *          position: [0, -3, 0],
 *          scale: [6, 0.5, 6],
 *          rotation: [0, 0, 0],
 *          color: [1.0, 0.3, 1.0],
 *          textureSetId: "theTextureSet"
 *      });
 *
 *      // Create five SceneObjects, each using a Mesh.
 *      // A Mesh belongs to exactly one SceneObject.
 *
 *      const redLegSceneObject = sceneModel.createObject({
 *          id: "redLegObject",
 *          meshIds: ["redLegMesh"]
 *      });
 *
 *      if (redLegSceneObject instanceof SDKError) {
 *          console.log(redLegSceneObject.message);
 *      }
 *
 *      const greenLegSceneObject = sceneModel.createObject({
 *          id: "greenLegObject",
 *          meshIds: ["greenLegMesh"]
 *      });
 *
 *      const blueLegSceneObject = sceneModel.createObject({
 *          id: "blueLegObject",
 *          meshIds: ["blueLegMesh"]
 *      });
 *
 *      const yellowLegSceneObject = sceneModel.createObject({
 *          id: "yellowLegObject",
 *          meshIds: ["yellowLegMesh"]
 *      });
 *
 *      const tableTopSceneObject = sceneModel.createObject({
 *          id: "tableTopObject",
 *          meshIds: ["tableTopMesh"]
 *      });
 *
 *      // Expect an event when we build the SceneModel
 *
 *      sceneModel.onBuilt.subscribe((theSceneModel)=>{ });
 *
 *      // Expect an event when we destroy the SceneModel
 *
 *      sceneModel.onDestroyed.subscribe((theSceneModel)=>{ });
 *
 *      // Now build the SceneModel
 *
 *      sceneModel.build().then(()=> {
 *           // SceneModel is ready for use
 *
 *      }).catch((sdkError) => {
 *          console.log(sdkError.message);
 *       });
 * }
 * ````
 *
 * ### Reading the SceneModel
 *
 * Now that we've built our SceneModel, we can read all of its components. Note that the {@link @xeokit/scene!Texture} and {@link @xeokit/scene!Geometry}
 * we just created will now be compressed.
 *
 * ````javascript
 * const theSceneModel = theScene.models["theModel"];
 * const theTexture = theSceneModel.textures["theColorTexture"];
 * const theTextureSet = theSceneModel.textureSets["theTextureSet"];
 * const boxGeometry = theSceneModel.geometries["boxGeometry"];
 * const theTableTopMesh = theSceneModel.meshes["tableTopMesh"];
 * const theTableTopObject = theSceneModel.objects["tableTopObject"];
 * const theTableTopObjectAgain = theScene.objects["tableTopObject"];
 * ````
 *
 * ### Geometry Compression
 *
 * The geometry from our query example requires a closer look. Internally, the {@link @xeokit/scene!SceneModel.createGeometry}
 * method uses the {@link @xeokit/scene!compressGeometryParams} function to compress the geometry and generate edge indices for
 * rendering it as a wireframe.
 *
 * We provide that function as part of the API in case users want to pre-compress the geometry themselves
 * and then use {@link @xeokit/scene!SceneModel.createGeometryCompressed | SceneModel.createGeometryCompressed}
 * to create the compressed geometry directly.
 *
 * The {@link @xeokit/scene!compressGeometryParams} function performs these steps to compress the geometry:
 *
 * * Simplifies geometry by combining duplicate positions and adjusting indices
 * * Generates edge indices for triangle meshes
 * * Ignores normals (our shaders auto-generate them)
 * * Quantizes positions and UVs as 16-bit unsigned integers
 * * Splits geometry into {@link @xeokit/scene!GeometryBucketParams | buckets } to enable indices to use the minimum bits for storage
 *
 * Our compressed geometry then looks like this:
 *
 * ````javascript
 * const bucket0 = boxGeometry.buckets[0];
 * const bucket0Positions = bucket0.positions;
 * const bucketindices = bucket0.indices;
 * const bucketEdgeIndices = bucket0.edgeIndices;
 * // ...
 * ````
 *
 * The bucketing technique was developed for xeokit by Toni Marti, with support from Tribia AG. Read [the slides](media://pdfs/GPU_RAM_Savings_Toni_Marti_Apr22.pdf) from Toni's presentation at WebGL Meetup 2022.
 *
 * In the example below, we'll now use {@link @xeokit/scene!compressGeometryParams} to compress
 * a {@link @xeokit/scene!GeometryParams | GeometryParams} into a
 * {@link @xeokit/scene!GeometryCompressedParams | GeometryCompressedParams}.
 *
 * In this example, our geometry is very simple, and our GeometryCompressedParams only gets a single
 * {@link @xeokit/scene!GeometryBucketParams | GeometryBucketParams }. Note that if the
 * {@link @xeokit/scene!GeometryParams.positions | GeometryParams.positions} array was large enough to require
 * some indices to use more than 16 bits for storage, then that's when the function's bucketing mechanism would
 * kick in, to split the geometry into smaller buckets, each with smaller indices that index a subset of the positions.
 *
 * ````javascript
 * import {compressGeometryParams} from "@xeokit/compression";
 * import {TrianglesPrimitive} from "@xeokit/constants";
 *
 * const geometryCompressedParams = compressGeometryParams({
 *      id: "boxGeometry",
 *      primitive: TrianglesPrimitive,
 *      positions: [ // Floats
 *          1, 1, 1, -1, 1, 1,
 *          -1, -1, 1, 1, -1, 1, 1,
 *          -1, -1, 1, 1, -1, -1, 1, -1, -1,
 *          -1, -1
 *      ],
 *      indices: [
 *          0, 1, 2, 0, 2, 3, 4, 5, 6, 4,
 *          6, 7, 8, 9, 10, 8, 10, 11, 12,
 *          13, 14, 12, 14, 15, 16, 17, 18,
 *          16, 18, 19, 20, 21, 22, 20, 22, 23
 *      ]
 *  });
 * ````
 *
 * The value of our new {@link @xeokit/scene!GeometryCompressedParams | GeometryCompressedParams} is shown below.
 *
 * We can see that:
 *
 * * We get one bucket, because we have only a small number of indices
 * * Vertex positions are now quantized to 16-bit integers
 * * Duplicate positions are removed and indices adjusted
 * * Edge indices generated for our TrianglesPrimitive
 * * A ````positionsDecompressMatrix```` to de-quantize the positions within the Viewer
 *
 * ````javascript
 * {
 *      id: "boxGeometry",
 *      primitive: TrianglesPrimitive,
 *      positionsDecompressMatrix: [
 *          0.00003052270125906143, 0, 0, 0,
 *          0, 0.00003052270125906143, 0, 0,
 *          0, 0, 0.00003052270125906143, 0,
 *          -1, -1, -1, 1
 *      ],
 *      geometryBuckets: [
 *          {
 *              positionsCompressed: [
 *                  65525, 65525, 65525, 0, 65525, 65525,
 *                  0, 0, 65525, 65525, 0, 65525, 65525,
 *                  0, 0, 65525, 65525, 0, 0, 65525, 0, 0,
 *                  0, 0
 *              ],
 *              indices: [
 *                  0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 5, 0, 5, 6,
 *                  0, 6, 1, 1, 6, 7, 1, 7, 2, 7, 4, 3, 7, 3, 2,
 *                  4, 7, 6, 4, 6, 5
 *              ],
 *              edgeIndices: [
 *                  3, 4, 0, 4, 5, 0, 5, 6,
 *                  0, 6, 1, 1, 6, 7, 1, 7,
 *                  3, 2, 4, 7, 6, 4, 6
 *              ]
 *          }
 *      ]
 * }
 * ````
 *
 * ### Texture Compression
 *
 * The {@link @xeokit/scene!Texture} from our query example also requires a closer look. Internally, the {@link @xeokit/scene!SceneModel.build}
 * method uses [Basis](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#basis) to compress the Texture to [KTX2](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#ktx2). We can now read that transcoded data
 * back from {@link @xeokit/scene!Texture.buffers | Texture.buffers}:
 *
 * ````javascript
 * const theTexture = theSceneModel.textures["theColorTexture"];
 *
 * const buffers = thetexture.buffers; // ArrayBuffer[]
 * ````
 *
 * @module @xeokit/scene
 */

var index$b = {
  __proto__: null,
  Scene: Scene,
  SceneModel: SceneModel,
  SceneObject: SceneObject,
  Texture: Texture,
  TextureSet: TextureSet,
  Geometry: Geometry,
  GeometryBucket: GeometryBucket,
  Mesh: Mesh,
  compressGeometryParams: compressGeometryParams,
  getSceneObjectGeometry: getSceneObjectGeometry
};

var _typeNames$1;
/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2Fdatatypes.svg)](https://badge.fury.io/js/%40xeokit%2Fdatatypes)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/basictypes/badge)](https://www.jsdelivr.com/package/npm/@xeokit/basictypes)
 *
 * <img style="padding:10px; width:300px" src="media://images/xeokit_components_icon.png"/>
 *
 * # xeokit Basic Semantic Data Types
 *
 * * Defines numeric constants for a basic set of entity and relationship types.
 * * Use with {@link "@xeokit/data"} to assign basic types to {@link @xeokit/data!DataObject | DataObjects}
 * and {@link @xeokit/data!Relationship | Relationships} and treat them as elements of a basic entity-relationship graph.
 * * Use with {@link "@xeokit/treeview"}, to configure the appearance and behaviour of
 * {@link @xeokit/treeview!TreeView | TreeViews} for navigating basic element hierachies.
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/basictypes
 * ````
 *
 * @module @xeokit/basictypes
 */
/**
 * A generic entity.
 */
var BasicEntity = 1000;
/**
 * A generic aggregation relationship between two generic entities.
 */
var BasicAggregation$1 = 1001;
/**
 * Map of names for all basic entity types.
 */
var typeNames$2 = (_typeNames$1 = {}, _typeNames$1[BasicEntity] = "BasicEntity", _typeNames$1[BasicAggregation$1] = "BasicAggregation", _typeNames$1);
/**
 * Map of type codes for all basic entity type names.
 */
var typeCodes$2 = {
  "BasicEntity": BasicEntity,
  "BasicAggregation": BasicAggregation$1
};

var index$a = {
  __proto__: null,
  BasicEntity: BasicEntity,
  BasicAggregation: BasicAggregation$1,
  typeNames: typeNames$2,
  typeCodes: typeCodes$2
};

var _typeNames;
/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2Fdatatypes.svg)](https://badge.fury.io/js/%40xeokit%2Fdatatypes)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/basictypes/badge)](https://www.jsdelivr.com/package/npm/@xeokit/basictypes)
 *
 * <img style="padding:0px; padding-top:20px; padding-bottom:30px; height:130px;" src="media://images/cityJSONLogo.svg"/>
 *
 * # xeokit CityJSON 1.1.3 Data Types
 *
 * * Defines numeric constants for the set of [CityJSON](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#cityjson) 1.1.3 entity and relationship types.
 * * Use with {@link "@xeokit/data"} to assign CityJSON types to {@link @xeokit/data!DataObject | DataObjects}
 * and {@link @xeokit/data!Relationship | Relationships} and treat them as elements of a basic entity-relationship graph.
 * * Use with {@link "@xeokit/treeview"}, to configure the appearance and behaviour of
 * {@link @xeokit/treeview!TreeView | TreeViews} for navigating CityJSON objects.
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/cityjsontypes1x1x3
 * ````
 *
 * @module @xeokit/cityjsontypes_1_1_3
 */
/**
 * A generic aggregation relationship between two generic entities.
 */
var BasicAggregation = 2001;
/**
 * This CityObject type represents a bridge, which can have attributes such as the length, height, and type of bridge.
 */
var Bridge = 2000;
/**
 * This CityJSON object represents a physical or functional subdivision of a Bridge.
 */
var BridgePart = 2001;
/**
 * This CityJSON type represents a permanent part of a Bridge (inside and/or outside) which does not have the significance of a
 * BridgePart. In contrast to BridgeConstructiveElements, a BridgeInstallation is not essential from a structural point of view.
 * Examples are stairs, antennas or railways.
 */
var BridgeInstallation = 2002;
/**
 * This CityJSON type represents an element of a bridge which is essential from a structural point of view. Examples are pylons,
 * anchorages, slabs, beams.
 */
var BridgeConstructiveElement = 2003;
/**
 * This CityJSON type represents  a space within a Bridge or BridgePart intended for human occupancy (e.g. a place of work or
 * recreation) and/or containment (storage) of animals or things. A BridgeRoom is bounded physically and/or virtually (e.g. by
 * ClosureSurfaces or GenericSurfaces).
 */
var BridgeRoom = 2004;
/**
 * This CityJSON type represents equipment for occupant use, usually not fixed to the bridge. [cf. ISO 6707-1]
 */
var BridgeFurniture = 2005;
/**
 *  This CityObject type represents a building, which can contain one or more "BuildingPart" objects. The Building object can
 *  have attributes such as the building height, number of floors, and the year of construction.
 */
var Building = 2006;
/**
 * This CityObject type represents a part of a building, such as a wing or a tower. Building parts can have attributes such
 * as the building part height and the material used in its construction.
 */
var BuildingPart = 2007;
/**
 * This CityJSON type represents a permanent part of a Building (inside and/or outside) which has not the significance of a
 * BuildingPart. Examples are stairs, antennas, balconies or small roofs.
 */
var BuildingInstallation = 2008;
/**
 * This CityJSON type represents an element of a Building which is essential from a structural point of view. Examples are walls,
 * slabs, staircases, beams.
 */
var BuildingConstructiveElement = 2009;
/**
 * This CityJSON type represents equipment for occupant use, usually not fixed to the building. [cf. ISO 6707-1]
 */
var BuildingFurniture = 2010;
/**
 * This CityJSON type represents  a horizontal section of a Building. BuildingStorey are not always defined according to the
 * building structure, but can also be defined according to logical considerations.
 */
var BuildingStorey = 2011;
/**
 * This CityJSON type represents a space within a Building or BuildingPart intended for human occupancy (e.g. a place of work or recreation)
 * and/or containment of animals or things. A BuildingRoom is bounded physically and/or virtually (e.g. by ClosureSurfaces or GenericSurfaces).
 */
var BuildingRoom = 2012;
/**
 * This CityJSON type represents a logical subdivision of a Building. BuildingUnits are formed according to some homogeneous
 * property like function, ownership, management, or accessibility. They may be separately sold, rented out, inherited, managed, etc.
 */
var BuildingUnit = 2013;
/**
 * This CityObject type represents outdoor furniture, such as benches, trash cans, and street lamps. CityFurniture objects can
 * have attributes such as the type of furniture and its location.
 */
var CityFurniture = 2014;
/**
 * This CityObject type represents a group of other CityObjects. CityObjectGroup objects can have attributes such as the name
 * of the group and the CityObjects it contains.
 */
var CityObjectGroup = 2015;
/**
 * This CityObject type represents the land use of a particular area, such as residential, commercial, or industrial. LandUse
 * objects can have attributes such as the name of the land use and the area it covers.
 */
var LandUse = 2016;
/**
 * this CityObject type represents an unclassified, generic element of construction.
 */
var OtherConstruction = 2017;
/**
 * This CityObject type represents vegetation, such as trees, bushes, and grass. PlantCover objects can have attributes such
 * as the type of vegetation and its location.
 */
var PlantCover = 2018;
/**
 * This CityObject type represents individual vegetation objects, e.g. trees or bushes.
 */
var SolitaryVegetationObject = 2019;
/**
 * This CityJSON type represents a terrain component as a triangulated irregular network.
 */
var TINRelief = 2020;
var TransportationSquare = 2021;
/**
 * This CityObject type represents a railway, which can have attributes such as the type of railway and the tracks' location.
 */
var Railway = 2022;
/**
 * This CityObject type represents a road, which can have attributes such as the road type and the road's location.
 */
var Road = 2023;
/**
 * This CityObject type  is used to represent any type of underground or underwater structure designed for passage or transportation,
 * such as a subway or water tunnel. It is defined by its geometry and other attributes.
 */
var Tunnel = 2024;
/**
 * This CityObject type represents a physical or functional subdivision of a Tunnel. It would be considered a Tunnel, if it were
 * not part of a collection of other TunnelParts.
 */
var TunnelPart = 2025;
/**
 * This CityObject type represents  a permanent part of a Tunnel (inside and/or outside) which does not have the significance of a
 * TunnelPart. In contrast to TunnelConstructiveElement, a TunnelInstallation is not essential from a structural point of view. Examples
 * are stairs, antennas or railings.
 */
var TunnelInstallation = 2026;
/**
 * This CityObject type represents an element of a Tunnel which is essential from a structural point of view. Examples are walls, slabs, beams.
 */
var TunnelConstructiveElement = 2027;
/**
 * This CityObject type represents a hollow space within a Tunnel.
 */
var TunnelHollowSpace = 2028;
/**
 * This CityObject type represents equipment for occupant use, usually not fixed to the tunnel. [cf. ISO 6707-1]
 */
var TunnelFurniture = 2029;
/**
 * This CityObject type represents a body of water, such as a river, lake, or ocean. It is defined by its geometry and other attributes,
 * and can be used to model and analyze hydrological features.
 */
var WaterBody = 2030;
/**
 * This CityObject type  is used to represent a natural or man-made channel that carries water, such as a river, canal, or stormwater drain.
 * It is defined by its geometry and other attributes, and can be used to model and analyze hydrological features.
 */
var Waterway = 2031;
/**
 * Map of names for all supported CityObject types.
 */
var typeNames$1 = (_typeNames = {}, _typeNames[Bridge] = "Bridge", _typeNames[BridgePart] = "BridgePart", _typeNames[BridgeInstallation] = "BridgeInstallation", _typeNames[BridgeConstructiveElement] = "BridgeConstructiveElement", _typeNames[BridgeRoom] = "BridgeRoom", _typeNames[BridgeFurniture] = "BridgeFurniture", _typeNames[Building] = "Building", _typeNames[BuildingPart] = "BuildingPart", _typeNames[BuildingInstallation] = "BuildingInstallation", _typeNames[BuildingConstructiveElement] = "BuildingConstructiveElement", _typeNames[BuildingFurniture] = "BuildingFurniture", _typeNames[BuildingStorey] = "BuildingStorey", _typeNames[BuildingRoom] = "BuildingRoom", _typeNames[BuildingUnit] = "BuildingUnit", _typeNames[CityFurniture] = "CityFurniture", _typeNames[CityObjectGroup] = "CityObjectGroup", _typeNames[LandUse] = "LandUse", _typeNames[OtherConstruction] = "OtherConstruction", _typeNames[PlantCover] = "PlantCover", _typeNames[SolitaryVegetationObject] = "SolitaryVegetationObject", _typeNames[TINRelief] = "TINRelief", _typeNames[TransportationSquare] = "TransportationSquare", _typeNames[Railway] = "Railway", _typeNames[Road] = "Road", _typeNames[Tunnel] = "Tunnel", _typeNames[TunnelPart] = "TunnelPart", _typeNames[TunnelInstallation] = "TunnelInstallation", _typeNames[TunnelConstructiveElement] = "TunnelInstallation", _typeNames[TunnelHollowSpace] = "TunnelHollowSpace", _typeNames[TunnelFurniture] = "TunnelFurniture", _typeNames[WaterBody] = "WaterBody", _typeNames[Waterway] = "Waterway", _typeNames);
/**
 * Map of type codes for all CityObject type names.
 */
var typeCodes$1 = {
  "Bridge": Bridge,
  "BridgePart": BridgePart,
  "BridgeInstallation": BridgeInstallation,
  "BridgeConstructiveElement": BridgeConstructiveElement,
  "BridgeRoom": BridgeRoom,
  "BridgeFurniture": BridgeFurniture,
  "Building": Building,
  "BuildingPart": BuildingPart,
  "BuildingInstallation": BuildingInstallation,
  "BuildingConstructiveElement": BuildingConstructiveElement,
  "BuildingFurniture": BuildingFurniture,
  "BuildingStorey": BuildingStorey,
  "BuildingRoom": BuildingRoom,
  "BuildingUnit": BuildingUnit,
  "CityFurniture": CityFurniture,
  "CityObjectGroup": CityObjectGroup,
  "LandUse": LandUse,
  "OtherConstruction": OtherConstruction,
  "PlantCover": PlantCover,
  "SolitaryVegetationObject": SolitaryVegetationObject,
  "TINRelief": TINRelief,
  "TransportationSquare": TransportationSquare,
  "Railway": Railway,
  "Road": Road,
  "Tunnel": Tunnel,
  "TunnelPart": TunnelPart,
  "TunnelInstallation": TunnelInstallation,
  "TunnelConstructiveElement": TunnelInstallation,
  "TunnelHollowSpace": TunnelHollowSpace,
  "TunnelFurniture": TunnelFurniture,
  "WaterBody": WaterBody,
  "Waterway": Waterway
};

var index$9 = {
  __proto__: null,
  BasicAggregation: BasicAggregation,
  Bridge: Bridge,
  BridgePart: BridgePart,
  BridgeInstallation: BridgeInstallation,
  BridgeConstructiveElement: BridgeConstructiveElement,
  BridgeRoom: BridgeRoom,
  BridgeFurniture: BridgeFurniture,
  Building: Building,
  BuildingPart: BuildingPart,
  BuildingInstallation: BuildingInstallation,
  BuildingConstructiveElement: BuildingConstructiveElement,
  BuildingFurniture: BuildingFurniture,
  BuildingStorey: BuildingStorey,
  BuildingRoom: BuildingRoom,
  BuildingUnit: BuildingUnit,
  CityFurniture: CityFurniture,
  CityObjectGroup: CityObjectGroup,
  LandUse: LandUse,
  OtherConstruction: OtherConstruction,
  PlantCover: PlantCover,
  SolitaryVegetationObject: SolitaryVegetationObject,
  TINRelief: TINRelief,
  TransportationSquare: TransportationSquare,
  Railway: Railway,
  Road: Road,
  Tunnel: Tunnel,
  TunnelPart: TunnelPart,
  TunnelInstallation: TunnelInstallation,
  TunnelConstructiveElement: TunnelConstructiveElement,
  TunnelHollowSpace: TunnelHollowSpace,
  TunnelFurniture: TunnelFurniture,
  WaterBody: WaterBody,
  Waterway: Waterway,
  typeNames: typeNames$1,
  typeCodes: typeCodes$1
};

/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2Fdatatypes.svg)](https://badge.fury.io/js/%40xeokit%2Fdatatypes)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/basictypes/badge)](https://www.jsdelivr.com/package/npm/@xeokit/basictypes)
 *
 * <img style="padding-top:20px; padding-bottom: 10px;" src="media://images/ifc_logo.png"/>
 *
 * # xeokit IFC Data Types
 *
 * * Defines numeric constants for [IFC](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#ifc) entity and relationship types.
 * * Use with {@link "@xeokit/data"} to assign IFC types to {@link @xeokit/data!DataObject | DataObjects} and
 * {@link @xeokit/data!Relationship | Relationships} and treat them as IFC elements.
 * * Use with {@link "@xeokit/treeview"} to configure the appearance and behaviour of
 * {@link @xeokit/treeview!TreeView | TreeViews} for navigating IFC element hierachies.
 * * Supports IFC versions 2x3 and 4.
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/basictypes
 * ````
 *
 * @module @xeokit/ifcTypes
 */
/**
 * A request is the act or instance of asking for something, such as a request for information, bid submission, or performance of work.
 */
var IfcActionRequest = 1000;
/**
 * The IfcActor defines all actors or human agents involved in a project during its full life cycle. It facilitates the use of person and organization definitions in the resource part of the IFC object model. This includes name, address, telecommunication addresses, and roles.
 */
var IfcActor = 1001;
/**
 * This entity indicates a role which is performed by an actor, either a person, an organization or a person related to an organization.
 */
var IfcActorRole = 1002;
/**
 * An actuator is a mechanical device for moving or controlling a mechanism or system. An actuator takes energy, usually created by air, electricity, or liquid, and converts that into some kind of motion.
 */
var IfcActuator = 1003;
/**
 * The distribution control element type IfcActuatorType defines commonly shared information for occurrences of actuators. The set of shared information may include:
 */
var IfcActuatorType = 1004;
/**
 * This abstract entity represents various kinds of postal and telecom addresses.
 */
var IfcAddress = 1005;
/**
 * An advanced B-rep is a boundary representation model in which all faces, edges and vertices are explicitly represented. It is a solid with explicit topology and elementary or free-form geometry. The faces of the B-rep are of type IfcAdvancedFace. An advanced B-rep has to meet the same topological constraints as the manifold solid B-rep.
 */
var IfcAdvancedBrep = 1006;
/**
 * The IfcAdvancedBrepWithVoids is a specialization of an advanced B-rep which contains one or more voids in its interior. The voids are represented as closed shells which are defined so that the shell normal point into the void.
 */
var IfcAdvancedBrepWithVoids = 1007;
/**
 * An advanced face is a specialization of a face surface that has to meet requirements on using particular topological and geometric representation items for the definition of the faces, edges and vertices.
 */
var IfcAdvancedFace = 1008;
/**
 * An air terminal is a terminating or origination point for the transfer of air between distribution system(s) and one or more spaces. It can also be used for the transfer of air between adjacent spaces.
 */
var IfcAirTerminal = 1009;
/**
 * An air terminal box typically participates in an HVAC duct distribution system and is used to control or modulate the amount of air delivered to its downstream ductwork. An air terminal box type is often referred to as an "air flow regulator".
 */
var IfcAirTerminalBox = 1010;
/**
 * The flow controller type IfcAirTerminalBoxType defines commonly shared information for occurrences of air terminal boxes. The set of shared information may include:
 */
var IfcAirTerminalBoxType = 1011;
/**
 * The flow terminal type IfcAirTerminalType defines commonly shared information for occurrences of air terminals. The set of shared information may include:
 */
var IfcAirTerminalType = 1012;
/**
 * An air-to-air heat recovery device employs a counter-flow heat exchanger between inbound and outbound air flow. It is typically used to transfer heat from warmer air in one chamber to cooler air in the second chamber (i.e., typically used to recover heat from the conditioned air being exhausted and the outside air being supplied to a building), resulting in energy savings from reduced heating (or cooling) requirements.
 */
var IfcAirToAirHeatRecovery = 1013;
/**
 * The energy conversion device type IfcAirToAirHeatRecoveryType defines commonly shared information for occurrences of air to air heat recoverys. The set of shared information may include:
 */
var IfcAirToAirHeatRecoveryType = 1014;
/**
 * An alarm is a device that signals the existence of a condition or situation that is outside the boundaries of normal expectation or that activates such a device.
 */
var IfcAlarm = 1015;
/**
 * The distribution control element type IfcAlarmType defines commonly shared information for occurrences of alarms. The set of shared information may include:
 */
var IfcAlarmType = 1016;
/**
 * An annotation is an information element within the geometric (and spatial) context of a project, that adds a note or meaning to the objects which constitutes the project model. Annotations include additional points, curves, text, dimensioning, hatching and other forms of graphical notes. It also includes virtual or symbolic representations of additional model components, not representing products or spatial structures, such as event elements, survey points, contour lines or similar.
 */
var IfcAnnotation = 1017;
/**
 * The IfcAnnotationFillArea defines an area by a definite OuterBoundary, that might include InnerBoundaries. The areas defined by the InnerBoundaries are excluded from applying the fill area style. The InnerBoundaries shall not intersect with the OuterBoundary nor being outside of the OuterBoundary.
 */
var IfcAnnotationFillArea = 1018;
/**
 * IfcApplication holds the information about an IFC compliant application developed by an application developer. The IfcApplication utilizes a short identifying name as provided by the application developer.
 */
var IfcApplication = 1019;
/**
 * This entity captures a value driven by a formula, with additional qualifications including unit basis, valid date range, and categorization.
 */
var IfcAppliedValue = 1020;
/**
 * An IfcApproval represents information about approval processes such as for a plan, a design, a proposal, or a change order in a construction or facilities management project. IfcApproval is referenced by IfcRelAssociatesApproval in IfcControlExtension schema, and thereby can be related to all subtypes of IfcRoot. An approval may also be given to resource objects using IfcResourceApprovalRelationship
 */
var IfcApproval = 1021;
/**
 * An IfcApprovalRelationship associates approvals (one relating approval and one or more related approvals), each having different status or level as the approval process or the approved objects evolve.
 */
var IfcApprovalRelationship = 1022;
/**
 * The closed profile IfcArbitraryClosedProfileDef defines an arbitrary two-dimensional profile for the use within the swept surface geometry, the swept area solid or a sectioned spine. It is given by an outer boundary from which the surface or solid can be constructed.
 */
var IfcArbitraryClosedProfileDef = 1023;
/**
 * The open profile IfcArbitraryOpenProfileDef defines an arbitrary two-dimensional open profile for the use within the swept surface geometry. It is given by an open boundary from which the surface can be constructed.
 */
var IfcArbitraryOpenProfileDef = 1024;
/**
 * The IfcArbitraryProfileDefWithVoids defines an arbitrary closed two-dimensional profile with holes. It is given by an outer boundary and inner boundaries. A kdtree3 usage of IfcArbitraryProfileDefWithVoids is as the cross section for the creation of swept surfaces or swept solids.
 */
var IfcArbitraryProfileDefWithVoids = 1025;
/**
 * An asset is a uniquely identifiable grouping of elements acting as a single entity that has a financial value or that can be operated on as a single unit.
 */
var IfcAsset = 1026;
/**
 * IfcAsymmetricIShapeProfileDef defines a section profile that provides the defining parameters of a singly symmetric I-shaped section. Its parameters and orientation relative to the position coordinate system are according to the following illustration. The centre of the position coordinate system is in the profile's centre of the bounding box.
 */
var IfcAsymmetricIShapeProfileDef = 1027;
/**
 * An audio-visual appliance is a device that displays, captures, transmits, or receives audio or video.
 */
var IfcAudioVisualAppliance = 1028;
/**
 * The flow terminal type IfcAudioVisualApplianceType defines commonly shared information for occurrences of audio visual appliances. The set of shared information may include:
 */
var IfcAudioVisualApplianceType = 1029;
/**
 * The IfcAxis1Placement provides location and direction of a single axis.
 */
var IfcAxis1Placement = 1030;
/**
 * The IfcAxis2Placement2D provides location and orientation to place items in a two-dimensional space. The attribute RefDirection defines the x axis, the y axis is derived. If the attribute RefDirection is not given, the placement defaults to P[1] (x-axis) as [1.,0.] and P[2] (y-axis) as [0.,1.].
 */
var IfcAxis2Placement2D = 1031;
/**
 * The IfcAxis2Placement3D provides location and orientations to place items in a three-dimensional space. The attribute Axis defines the Z direction, RefDirection the X direction. The Y direction is derived.
 */
var IfcAxis2Placement3D = 1032;
/**
 * An IfcBeam is a horizontal, or nearly horizontal, structural member that is capable of withstanding load primarily by resisting bending. It represents such a member from an architectural point of view. It is not required to be load bearing.
 */
var IfcBeam = 1033;
/**
 * The standard beam, IfcBeamStandardCase, defines a beam with certain constraints for the provision of material usage, parameters and with certain constraints for the geometric representation. The IfcBeamStandardCase handles all cases of beams, that:
 */
var IfcBeamStandardCase = 1034;
/**
 * The element type IfcBeamType defines commonly shared information for occurrences of beams. The set of shared information may include:
 */
var IfcBeamType = 1035;
/**
 * An IfcBlobTexture provides a 2-dimensional distribution of the lighting parameters of a surface onto which it is mapped. The texture itself is given as a single binary blob, representing the content of a pixel format file. The file format of the pixel file is given by the RasterFormat attribute and allowable formats are guided by where rule SupportedRasterFormat.
 */
var IfcBlobTexture = 1036;
/**
 * The IfcBlock is a Construction Solid Geometry (CSG) 3D primitive. It is defined by a position and a positve distance along the three orthogonal axes. The inherited Position attribute has the IfcAxisPlacement3D type and provides:
 */
var IfcBlock = 1037;
/**
 * A boiler is a closed, pressure-rated vessel in which water or other fluid is heated using an energy source such as natural gas, heating oil, or electricity. The fluid in the vessel is then circulated out of the boiler for use in various processes or heating applications.
 */
var IfcBoiler = 1038;
/**
 * The energy conversion device type IfcBoilerType defines commonly shared information for occurrences of boilers. The set of shared information may include:
 */
var IfcBoilerType = 1039;
/**
 * A clipping result is defined as a special subtype of the general IfcBooleanResult. It constrains the operands and the operator of the Boolean result.
 */
var IfcBooleanClippingResult = 1040;
/**
 * The IfcBooleanResult is the result of applying a Boolean operation to two operands being solids.
 */
var IfcBooleanResult = 1041;
/**
 * The abstract entity IfcBoundaryCondition is the supertype of all boundary conditions that can be applied to structural connection definitions, either directly for the connection (e.g. the joint) or for the relation between a structural member and the connection.
 */
var IfcBoundaryCondition = 1042;
/**
 * An IfcBoundaryCurve defines a curve acting as the boundary of a surface.
 */
var IfcBoundaryCurve = 1043;
/**
 * Describes linearly elastic support conditions or connection conditions.
 */
var IfcBoundaryEdgeCondition = 1044;
/**
 * Describes linearly elastic support conditions or connection conditions.
 */
var IfcBoundaryFaceCondition = 1045;
/**
 * Describes linearly elastic support conditions or connection conditions.
 */
var IfcBoundaryNodeCondition = 1046;
/**
 * Describes linearly elastic support conditions or connection conditions, including linearly elastic warping restraints.
 */
var IfcBoundaryNodeConditionWarping = 1047;
/**
 * An IfcBoundedCurve is a curve of finite length.
 */
var IfcBoundedCurve = 1048;
/**
 * An IfcBoundedSurface is a surface of finite area.
 */
var IfcBoundedSurface = 1049;
/**
 * The IfcBoundingBox defines an orthogonal box oriented parallel to the axes of the object coordinate system in which it is defined. It is defined by a Corner being a three-dimensional Cartesian point and three length measures defining the X, Y and Z parameters of the box in the direction of the positive axes.
 */
var IfcBoundingBox = 1050;
/**
 * The IfcBoxedHalfSpace is used (as its supertype IfcHalfSpaceSolid) only within Boolean operations. It divides the domain into exactly two subsets, where the domain in question is that of the attribute Enclosure.
 */
var IfcBoxedHalfSpace = 1051;
/**
 * The IfcBSplineCurve is a spline curve parameterized by spline functions.
 */
var IfcBSplineCurve = 1052;
/**
 * The IfcBSplineCurveWithKnots is a spline curve parameterized by spline functions for which the knot values are explicitly given.
 */
var IfcBSplineCurveWithKnots = 1053;
/**
 * The IfcBSplineSurface is a general form of rational or polynomial parametric surface.
 */
var IfcBSplineSurface = 1054;
/**
 * The IfcBSplineSurfaceWithKnots is a general form of rational or polynomial parametric surface in which the knot values are explicitly given.
 */
var IfcBSplineSurfaceWithKnots = 1055;
/**
 * A building represents a structure that provides shelter for its occupants or contents and stands in one place. The building is also used to provide a basic element within the spatial structure hierarchy for the components of a building project (together with site, storey, and space).
 */
var IfcBuilding = 1056;
/**
 * IfcBuildingElementPart represents major components as subordinate parts of a building element. Typical usage examples include precast concrete sandwich walls, where the layers may have different geometry representations. In this case the layered material representation does not sufficiently describe the element. Each layer is represented by an own instance of the IfcBuildingElementPart with its own geometry description.
 */
var IfcBuildingElementPart = 1057;
/**
 * The building element part type defines lists of commonly shared property set definitions and representation maps of parts of a building element.
 */
var IfcBuildingElementPartType = 1058;
/**
 * The IfcBuildingElementProxy is a proxy definition that provides the same functionality as subtypes of IfcBuildingElement, but without having a predefined meaning of the special type of building element, it represents.
 */
var IfcBuildingElementProxy = 1059;
/**
 * IfcBuildingElementProxyType defines a list of commonly shared property set definitions of a building element proxy and an optional set of product representations. It is used to define an element specification (i.e. the specific product information, that is kdtree3 to all occurrences of that product type).
 */
var IfcBuildingElementProxyType = 1060;
/**
 * The building storey has an elevation and typically represents a (nearly) horizontal aggregation of spaces that are vertically bound.
 */
var IfcBuildingStorey = 1061;
/**
 * A building system is a group by which building elements are grouped according to a kdtree3 function within the facility.
 */
var IfcBuildingSystem = 1062;
/**
 * A burner is a device that converts fuel into heat through combustion. It includes gas, oil, and wood burners.
 */
var IfcBurner = 1063;
/**
 * The energy conversion device type IfcBurnerType defines commonly shared information for occurrences of burners. The set of shared information may include:
 */
var IfcBurnerType = 1064;
/**
 * A cable carrier fitting is a fitting that is placed at junction or transition in a cable carrier system.
 */
var IfcCableCarrierFitting = 1065;
/**
 * The flow fitting type IfcCableCarrierFittingType defines commonly shared information for occurrences of cable carrier fittings. The set of shared information may include:
 */
var IfcCableCarrierFittingType = 1066;
/**
 * A cable carrier segment is a flow segment that is specifically used to carry and support cabling.
 */
var IfcCableCarrierSegment = 1067;
/**
 * The flow segment type IfcCableCarrierSegmentType defines commonly shared information for occurrences of cable carrier segments. The set of shared information may include:
 */
var IfcCableCarrierSegmentType = 1068;
/**
 * A cable fitting is a fitting that is placed at a junction, transition or termination in a cable system.
 */
var IfcCableFitting = 1069;
/**
 * The flow fitting type IfcCableFittingType defines commonly shared information for occurrences of cable fittings. The set of shared information may include:
 */
var IfcCableFittingType = 1070;
/**
 * A cable segment is a flow segment used to carry electrical power, data, or telecommunications signals.
 */
var IfcCableSegment = 1071;
/**
 * The flow segment type IfcCableSegmentType defines commonly shared information for occurrences of cable segments. The set of shared information may include:
 */
var IfcCableSegmentType = 1072;
/**
 * An IfcCartesianPoint defines a point by coordinates in an orthogonal, right-handed Cartesian coordinate system. For the purpose of this specification only two and three dimensional Cartesian points are used.
 */
var IfcCartesianPoint = 1073;
/**
 * The IfcCartesianPointList is the abstract supertype of list of points.
 */
var IfcCartesianPointList = 1074;
/**
 * The IfcCartesianPointList2D defines an ordered collection of two-dimentional Cartesian points. Each Cartesian point is provided as an two-dimensional point by a fixed list of two coordinates. The attribute CoordList is a two-dimensional list, where
 */
var IfcCartesianPointList2D = 1075;
/**
 * The IfcCartesianPointList3D defines an ordered collection of three-dimentional Cartesian points. Each Cartesian point is provided as an three-dimensional point by a fixed list of three coordinates. The attribute CoordList is a two-dimensional list, where
 */
var IfcCartesianPointList3D = 1076;
/**
 * An IfcCartesianTransformationOperator defines an abstract supertype of different kinds of geometric transformations.
 */
var IfcCartesianTransformationOperator = 1077;
/**
 * An IfcCartesianTransformationOperator2D defines a geometric transformation in two-dimensional space.
 */
var IfcCartesianTransformationOperator2D = 1078;
/**
 * A Cartesian transformation operator 2d non uniform defines a geometric transformation in two-dimensional space composed of translation, rotation, mirroring and non uniform scaling. Non uniform scaling is given by two different scaling factors:
 */
var IfcCartesianTransformationOperator2DnonUniform = 1079;
/**
 * An IfcCartesianTransformationOperator defines a geometric transformation in three-dimensional space.
 */
var IfcCartesianTransformationOperator3D = 1080;
/**
 * A Cartesian transformation operator 3d non uniform defines a geometric transformation in three-dimensional space composed of translation, rotation, mirroring and non uniform scaling. Non uniform scaling is given by three different scaling factors:
 */
var IfcCartesianTransformationOperator3DnonUniform = 1081;
/**
 * The profile IfcCenterLineProfileDef defines an arbitrary two-dimensional open, not self intersecting profile for the use within the swept solid geometry. It is given by an area defined by applying a constant thickness to a centerline, generating an area from which the solid can be constructed.
 */
var IfcCenterLineProfileDef = 1082;
/**
 * A chiller is a device used to remove heat from a liquid via a vapor-compression or absorption refrigeration cycle to cool a fluid, typically water or a mixture of water and glycol. The chilled fluid is then used to cool and dehumidify air in a building.
 */
var IfcChiller = 1083;
/**
 * The energy conversion device type IfcChillerType defines commonly shared information for occurrences of chillers. The set of shared information may include:
 */
var IfcChillerType = 1084;
/**
 * Chimneys are typically vertical, or as near as vertical, parts of the construction of a building and part of the building fabric. Often constructed by pre-cast or insitu concrete, today seldom by bricks.
 */
var IfcChimney = 1085;
/**
 * The building element type IfcChimneyType defines commonly shared information for occurrences of chimneys. The set of shared information may include:
 */
var IfcChimneyType = 1086;
/**
 * An IfcCircle is a curve consisting of a set of points having equal distance from the center.
 */
var IfcCircle = 1087;
/**
 * IfcCircleHollowProfileDef defines a section profile that provides the defining parameters of a circular hollow section (tube) to be used by the swept area solid. Its parameters and orientation relative to the position coordinate system are according to the following illustration.The centre of the position coordinate system is in the profile's centre of the bounding box (for symmetric profiles identical with the centre of gravity).
 */
var IfcCircleHollowProfileDef = 1088;
/**
 * IfcCircleProfileDef defines a circle as the profile definition used by the swept surface geometry or by the swept area solid. It is given by its Radius attribute and placed within the 2D position coordinate system, established by the Position attribute.
 */
var IfcCircleProfileDef = 1089;
/**
 * An IfcCivilElement is a generalization of all elements within a civil engineering works that cannot be represented as BuildingElements, DistributionElements or GeographicElements. Depending on the context of the construction project, included building work, such as buildings or factories, are represented as a collection of IfcBuildingElement's, distribution systems, such as piping or drainage, are represented as a collection of IfcDistributionElement's, and other geographic elements, such as trees, light posts, traffic signs etc. are represented as IfcGeographicElement's.
 */
var IfcCivilElement = 1090;
/**
 * An IfcCivilElementType is used to define an element specification of an element used within civil engineering works. Civil element types include for different types of element that may be used to represent information for construction works external to a building. IfcCivilElementType's may include:
 */
var IfcCivilElementType = 1091;
/**
 * An IfcClassification is used for the arrangement of objects into a class or category according to a kdtree3 purpose or their possession of kdtree3 characteristics. A classification in the sense of IfcClassification is taxonomy, or taxonomic scheme, arranged in a hierarchical structure. A category of objects relates to other categories in a generalization-specialization relationship. Therefore the classification items in an classification are organized in a tree structure.
 */
var IfcClassification = 1092;
/**
 * An IfcClassificationReference is a reference into a classification system or source (see IfcClassification) for a specific classification key (or notation).
 */
var IfcClassificationReference = 1093;
/**
 *
 */
var IfcClosedShell = 1094;
/**
 * A coil is a device used to provide heat transfer between non-mixing media. A kdtree3 example is a cooling coil, which utilizes a finned coil in which circulates chilled water, antifreeze, or refrigerant that is used to remove heat from air moving across the surface of the coil. A coil may be used either for heating or cooling purposes by placing a series of tubes (the coil) carrying a heating or cooling fluid into an airstream. The coil may be constructed from tubes bundled in a serpentine form or from finned tubes that give a extended heat transfer surface.
 */
var IfcCoil = 1095;
/**
 * The energy conversion device type IfcCoilType defines commonly shared information for occurrences of coils. The set of shared information may include:
 */
var IfcCoilType = 1096;
/**
 *
 */
var IfcColourRgb = 1097;
/**
 * The IfcColourRgbList defines an ordered collection of RGB colour values. Each colour value is a fixed list of three colour components (red, green, blue). The attribute ColourList is a two-dimensional list, where:
 */
var IfcColourRgbList = 1098;
/**
 *
 */
var IfcColourSpecification = 1099;
/**
 * <An IfcColumn is a vertical structural member which often is aligned with a structural grid intersection. It represents a vertical, or nearly vertical, structural member that transmits, through compression, the weight of the structure above to other structural elements below. It represents such a member from an architectural point of view. It is not required to be load bearing.
 */
var IfcColumn = 1100;
/**
 * The standard column, IfcColumnStandardCase, defines a column with certain constraints for the provision of material usage, parameters and with certain constraints for the geometric representation. The IfcColumnStandardCase handles all cases of columns, that:
 */
var IfcColumnStandardCase = 1101;
/**
 * The element type IfcColumnType defines commonly shared information for occurrences of columns. The set of shared information may include:
 */
var IfcColumnType = 1102;
/**
 * A communications appliance transmits and receives electronic or digital information as data or sound.
 */
var IfcCommunicationsAppliance = 1103;
/**
 * The flow terminal type IfcCommunicationsApplianceType defines commonly shared information for occurrences of communications appliances. The set of shared information may include:
 */
var IfcCommunicationsApplianceType = 1104;
/**
 * IfcComplexProperty is used to define complex properties to be handled completely within a property set. The included set of properties may be a mixed or consistent collection of IfcProperty subtypes. This enables the definition of a set of properties to be included as a single 'property' entry in an IfcPropertySet. The definition of such an IfcComplexProperty can be reused in many different IfcPropertySet's.
 */
var IfcComplexProperty = 1105;
/**
 * The IfcComplexPropertyTemplate defines the template for all complex properties, either the IfcComplexProperty's, or the IfcPhysicalComplexQuantity's. The individual complex property templates are interpreted according to their Name attribute and and optional UsageName attribute.
 */
var IfcComplexPropertyTemplate = 1106;
/**
 * An IfcCompositeCurve is a continuous curve composed of curve segments.
 */
var IfcCompositeCurve = 1107;
/**
 * The IfcCompositeCurveOnSurface is a collection of segments, based on p-curves. i.e. a curve which lies on the basis of a surface and is defined in the parameter space of that surface. The p-curve segment is a special type of a composite curve segment and shall only be used to bound a surface.
 */
var IfcCompositeCurveOnSurface = 1108;
/**
 * An IfcCompositeCurveSegment is a bounded curve constructed for the sole purpose to be a segment within an IfcCompositeCurve.
 */
var IfcCompositeCurveSegment = 1109;
/**
 * The IfcCompositeProfileDef defines the profile by composition of other profiles. The composition is given by a set of at least two other profile definitions. Any profile definition (except for another composite profile) can be used to construct the composite.
 */
var IfcCompositeProfileDef = 1110;
/**
 * A compressor is a device that compresses a fluid typically used in a refrigeration circuit.
 */
var IfcCompressor = 1111;
/**
 * The flow moving device type IfcCompressorType defines commonly shared information for occurrences of compressors. The set of shared information may include:
 */
var IfcCompressorType = 1112;
/**
 * A condenser is a device that is used to dissipate heat, typically by condensing a substance such as a refrigerant from its gaseous to its liquid state.
 */
var IfcCondenser = 1113;
/**
 * The energy conversion device type IfcCondenserType defines commonly shared information for occurrences of condensers. The set of shared information may include:
 */
var IfcCondenserType = 1114;
/**
 * An IfcConic is a parameterized planar curve.
 */
var IfcConic = 1115;
/**
 *
 */
var IfcConnectedFaceSet = 1116;
/**
 * IfcConnectionCurveGeometry is used to describe the geometric constraints that facilitate the physical connection of two objects at a curve or at an edge with curve geometry associated. It is envisioned as a control that applies to the element connection relationships.
 */
var IfcConnectionCurveGeometry = 1117;
/**
 * IfcConnectionGeometry is used to describe the geometric and topological constraints that facilitate the physical connection of two objects. It is envisioned as a control that applies to the element connection relationships.
 */
var IfcConnectionGeometry = 1118;
/**
 * IfcConnectionPointEccentricity is used to describe the geometric constraints that facilitate the physical connection of two objects at a point or vertex point with associated point coordinates. There is a physical distance, or eccentricity, etween the connection points of both object. The eccentricity can be either given by:
 */
var IfcConnectionPointEccentricity = 1119;
/**
 * IfcConnectionPointGeometry is used to describe the geometric constraints that facilitate the physical connection of two objects at a point (here IfcCartesianPoint) or at an vertex with point coordinates associated. It is envisioned as a control that applies to the element connection relationships.
 */
var IfcConnectionPointGeometry = 1120;
/**
 * IfcConnectionSurfaceGeometry is used to describe the geometric constraints that facilitate the physical connection of two objects at a surface or at a face with surface geometry associated. It is envisioned as a control that applies to the element connection relationships.
 */
var IfcConnectionSurfaceGeometry = 1121;
/**
 * IfcConnectionVolumeGeometry is used to describe the geometric constraints that facilitate the physical connection (or overlap) of two objects at a volume defined by a solid or closed shell. It is envisioned as a control that applies to the element connection or interference relationships.
 */
var IfcConnectionVolumeGeometry = 1122;
/**
 * An IfcConstraint is used to define a constraint or limiting value or boundary condition that may be applied to an object or to the value of a property.
 */
var IfcConstraint = 1123;
/**
 * IfcConstructionEquipmentResource is usage of construction equipment to assist in the performance of construction. Construction Equipment resources are wholly or partially consumed or occupied in the performance of construction.
 */
var IfcConstructionEquipmentResource = 1124;
/**
 * The resource type IfcConstructionEquipmentType defines commonly shared information for occurrences of construction equipment resources. The set of shared information may include:
 */
var IfcConstructionEquipmentResourceType = 1125;
/**
 * IfcConstructionMaterialResource identifies a material resource type in a construction project.
 */
var IfcConstructionMaterialResource = 1126;
/**
 * The resource type IfcConstructionMaterialType defines commonly shared information for occurrences of construction material resources. The set of shared information may include:
 */
var IfcConstructionMaterialResourceType = 1127;
/**
 * IfcConstructionProductResource defines the role of a product that is consumed (wholly or partially), or occupied in the performance of construction.
 */
var IfcConstructionProductResource = 1128;
/**
 * The resource type IfcConstructionProductType defines commonly shared information for occurrences of construction product resources. The set of shared information may include:
 */
var IfcConstructionProductResourceType = 1129;
/**
 * IfcConstructionResource is an abstract generalization of the different resources used in construction projects, mainly labour, material, equipment and product resources, plus subcontracted resources and aggregations such as a crew resource.
 */
var IfcConstructionResource = 1130;
/**
 * IfcConstructionResourceType is an abstract generalization of the different resource types used in construction projects, mainly labor, material, equipment and product resource types, plus subcontracted resource types and aggregations such as a crew resource type.
 */
var IfcConstructionResourceType = 1131;
/**
 * IfcContext is the generalization of a project context in which objects, type objects, property sets, and properties are defined. The IfcProject as subtype of IfcContext provides the context for all information on a construction project, it may include one or several IfcProjectLibrary's as subtype of IfcContext to register the included libraries for the project. A library of products that is referenced is declared within the IfcProjectLibrary as the context of that library.
 */
var IfcContext = 1132;
/**
 *
 */
var IfcContextDependentUnit = 1133;
/**
 * IfcControl is the abstract generalization of all concepts that control or constrain the utilization of products, processes, or resources in general. It can be seen as a regulation, cost schedule, request or order, or other requirements applied to a product, process or resource whose requirements and provisions must be fulfilled.
 */
var IfcControl = 1134;
/**
 * A controller is a device that monitors inputs and controls outputs within a building automation system.
 */
var IfcController = 1135;
/**
 * The distribution control element type IfcControllerType defines commonly shared information for occurrences of controllers. The set of shared information may include:
 */
var IfcControllerType = 1136;
/**
 * An IfcConversionBasedUnit is used to define a unit that has a conversion rate to a base unit. To identify some commonly used conversion based units, the standard designations (case insensitive) for the Name attribute are indicated in Table 696.
 */
var IfcConversionBasedUnit = 1137;
/**
 * IfcConversionBasedUnitWithOffset is a unit which is converted from another unit by applying a conversion factor and an offset.
 */
var IfcConversionBasedUnitWithOffset = 1138;
/**
 * A cooled beam (or chilled beam) is a device typically used to cool air by circulating a fluid such as chilled water through exposed finned tubes above a space. Typically mounted overhead near or within a ceiling, the cooled beam uses convection to cool the space below it by acting as a heat sink for the naturally rising warm air of the space. Once cooled, the air naturally drops back to the floor where the cycle begins again.
 */
var IfcCooledBeam = 1139;
/**
 * The energy conversion device type IfcCooledBeamType defines commonly shared information for occurrences of cooled beams. The set of shared information may include:
 */
var IfcCooledBeamType = 1140;
/**
 * A cooling tower is a device which rejects heat to ambient air by circulating a fluid such as water through it to reduce its temperature by partial evaporation.
 */
var IfcCoolingTower = 1141;
/**
 * The energy conversion device type IfcCoolingTowerType defines commonly shared information for occurrences of cooling towers. The set of shared information may include:
 */
var IfcCoolingTowerType = 1142;
/**
 * The coordinate operation is an abstract supertype to handle any operation (transformation or conversion) between two coordinate reference systems. It is meant to provide expandability for future versions, since currently only the conversion of a local engineering coordinate system into a map coordinate reference system is dealt with by the subtype IfcMapConversion.
 */
var IfcCoordinateOperation = 1143;
/**
 * The IfcCoordinateReferenceSystem is a definition of a coordinate reference system by means of qualified identifiers only. The interpretation of the identifier is expected to be well-known to the receiving software.
 */
var IfcCoordinateReferenceSystem = 1144;
/**
 * An IfcCostItem describes a cost or financial value together with descriptive information that describes its context in a form that enables it to be used within a cost schedule. An IfcCostItem can be used to represent the cost of goods and services, the execution of works by a process, lifecycle cost and more.
 */
var IfcCostItem = 1145;
/**
 * An IfcCostSchedule brings together instances of IfcCostItem either for the purpose of identifying purely cost information as in an estimate for constructions costs or for including cost information within another presentation form such as a work order.
 */
var IfcCostSchedule = 1146;
/**
 * IfcCostValue is an amount of money or a value that affects an amount of money.
 */
var IfcCostValue = 1147;
/**
 * A covering is an element which covers some part of another element and is fully dependent on that other element. The IfcCovering defines the occurrence of a covering type, that (if given) is expressed by the IfcCoveringType.
 */
var IfcCovering = 1148;
/**
 * The element type IfcCoveringType defines commonly shared information for occurrences of coverings. The set of shared information may include:
 */
var IfcCoveringType = 1149;
/**
 * IfcCrewResource represents a collection of internal resources used in construction processes.
 */
var IfcCrewResource = 1150;
/**
 * The resource type IfcCrewResourceType defines commonly shared information for occurrences of crew resources. The set of shared information may include:
 */
var IfcCrewResourceType = 1151;
/**
 * IfcCsgPrimitive3D is an abstract supertype of all three dimensional primitives used as either tree root item, or as Boolean results within a CSG solid model. All 3D CSG primitives are defined within a three-dimensional placement coordinate system.
 */
var IfcCsgPrimitive3D = 1152;
/**
 * An IfcCsgSolid is the representation of a 3D shape using constructive solid geometry model. It is represented by a single 3D CSG primitive, or as a result of a Boolean operation. The operants of a Boolean operation can be Boolean operations themselves forming a CSG tree. The following volumes can be parts of the CSG tree:
 */
var IfcCsgSolid = 1153;
/**
 * IfcCShapeProfileDef defines a section profile that provides the defining parameters of a C-shaped section to be used by the swept area solid. This section is typically produced by cold forming steel. Its parameters and orientation relative to the position coordinate system are according to the following illustration. The centre of the position coordinate system is in the profile's centre of the bounding box.
 */
var IfcCShapeProfileDef = 1154;
/**
 * IfcCurrencyRelationship defines the rate of exchange that applies between two designated currencies at a particular time and as published by a particular source.
 */
var IfcCurrencyRelationship = 1155;
/**
 * A curtain wall is an exterior wall of a building which is an assembly of components, hung from the edge of the floor/roof structure rather than bearing on a floor. Curtain wall is represented as a building element assembly and implemented as a subtype of IfcBuildingElement that uses an IfcRelAggregates relationship.
 */
var IfcCurtainWall = 1156;
/**
 * The building element type IfcCurtainWallType defines commonly shared information for occurrences of curtain walls. The set of shared information may include:
 */
var IfcCurtainWallType = 1157;
/**
 * An IfcCurve is a curve in two-dimensional or three-dimensional space. It includes definitions for bounded and unbounded curves.
 */
var IfcCurve = 1158;
/**
 * The IfcCurveBoundedPlane is a parametric planar surface with curved boundaries defined by one or more boundary curves. The bounded plane is defined to be the portion of the basis surface in the direction of N x T from any point on the boundary, where N is the surface normal and T the boundary curve tangent vector at this point. The region so defined shall be arcwise connected.
 */
var IfcCurveBoundedPlane = 1159;
/**
 * The IfcCurveBoundedSurface is a parametric surface with boundaries defined by p-curves, that is, a curve which lies on the basis of a surface and is defined in the parameter space of that surface. The p-curve is a special type of a composite curve segment and shall only be used to bound a surface.
 */
var IfcCurveBoundedSurface = 1160;
/**
 * An IfcCurveStyle provides the style table for presentation information assigned to geometric curves. The style is defined by a color, a font and a width. The IfcCurveStyle defines curve patterns as model patterns, that is, the distance between visible and invisible segments of curve patterns are given in model space dimensions (that have to be scaled using the target plot scale).
 */
var IfcCurveStyle = 1161;
/**
 *
 */
var IfcCurveStyleFont = 1162;
/**
 * The IfcCurveStyleFontAndScaling allows for the reuse of the same curve style definition in several sizes. The definition of the CurveFontScale is the scaling of a base curve style pattern to be used as a new or derived curve style pattern.
 */
var IfcCurveStyleFontAndScaling = 1163;
/**
 *
 */
var IfcCurveStyleFontPattern = 1164;
/**
 * The cylindrical surface is a surface unbounded in the direction of z. Bounded cylindrical surfaces are defined by using a subtype of IfcBoundedSurface with BasisSurface being a cylindrical surface.
 */
var IfcCylindricalSurface = 1165;
/**
 * A damper typically participates in an HVAC duct distribution system and is used to control or modulate the flow of air.
 */
var IfcDamper = 1166;
/**
 * The flow controller type IfcDamperType defines commonly shared information for occurrences of dampers. The set of shared information may include:
 */
var IfcDamperType = 1167;
/**
 * IfcDerivedProfileDef defines the profile by transformation from the parent profile. The transformation is given by a two dimensional transformation operator. Transformation includes translation, rotation, mirror and scaling. The latter can be uniform or non uniform. The derived profiles may be used to define swept surfaces, swept area solids or sectioned spines.
 */
var IfcDerivedProfileDef = 1168;
/**
 *
 */
var IfcDerivedUnit = 1169;
/**
 *
 */
var IfcDerivedUnitElement = 1170;
/**
 *
 */
var IfcDimensionalExponents = 1171;
/**
 * The IfcDirection provides a direction in two or three dimensional space depending on the number of DirectionRatio's provided. The IfcDirection does not imply a vector length, and the direction ratios does not have to be normalized.
 */
var IfcDirection = 1172;
/**
 * A discrete accessory is a representation of different kinds of accessories included in or added to elements.
 */
var IfcDiscreteAccessory = 1173;
/**
 * The element component type IfcDiscreteAccessoryType defines commonly shared information for occurrences of discrete accessorys. The set of shared information may include:
 */
var IfcDiscreteAccessoryType = 1174;
/**
 * A distribution chamber element defines a place at which distribution systems and their constituent elements may be inspected or through which they may travel.
 */
var IfcDistributionChamberElement = 1175;
/**
 * The distribution flow element type IfcDistributionChamberElementType defines commonly shared information for occurrences of distribution chamber elements. The set of shared information may include:
 */
var IfcDistributionChamberElementType = 1176;
/**
 * A distribution circuit is a partition of a distribution system that is conditionally switched such as an electrical circuit.
 */
var IfcDistributionCircuit = 1177;
/**
 * The distribution element IfcDistributionControlElement defines occurrence elements of a building automation control system that are used to impart control over elements of a distribution system.
 */
var IfcDistributionControlElement = 1178;
/**
 * The element type IfcDistributionControlElementType defines a list of commonly shared property set definitions of an element and an optional set of product representations. It is used to define an element specification (the specific product information that is kdtree3 to all occurrences of that product type).
 */
var IfcDistributionControlElementType = 1179;
/**
 * This IfcDistributionElement is a generalization of all elements that participate in a distribution system. Typical examples of IfcDistributionElement's are (among others):
 */
var IfcDistributionElement = 1180;
/**
 * The IfcDistributionElementType defines a list of commonly shared property set definitions of an element and an optional set of product representations. It is used to define an element specification (i.e. the specific product information, that is kdtree3 to all occurrences of that product type).
 */
var IfcDistributionElementType = 1181;
/**
 * The distribution element IfcDistributionFlowElement defines occurrence elements of a distribution system that facilitate the distribution of energy or matter, such as air, water or power.
 */
var IfcDistributionFlowElement = 1182;
/**
 * The element type IfcDistributionFlowElementType defines a list of commonly shared property set definitions of an element and an optional set of product representations. It is used to define an element specification (the specific product information that is kdtree3 to all occurrences of that product type).
 */
var IfcDistributionFlowElementType = 1183;
/**
 * A distribution port is an inlet or outlet of a product through which a particular substance may flow.
 */
var IfcDistributionPort = 1184;
/**
 * A distribution system is a network designed to receive, store, maintain, distribute, or control the flow of a distribution media. A kdtree3 example is a heating hot water system that consists of a pump, a tank, and an interconnected piping system for distributing hot water to terminals.
 */
var IfcDistributionSystem = 1185;
/**
 * IfcDocumentInformation captures "metadata" of an external document. The actual content of the document is not defined in this specification; instead, it can be found following the Location attribute.
 */
var IfcDocumentInformation = 1186;
/**
 * An IfcDocumentInformationRelationship is a relationship entity that enables a document to have the ability to reference other documents. It is used to describe relationships in which one document may reference one or more other sub documents or where a document is used as a replacement for another document (but where both the original and the replacing document need to be retained).
 */
var IfcDocumentInformationRelationship = 1187;
/**
 * An IfcDocumentReference is a reference to the location of a document. The reference is given by a system interpretable Location attribute (a URL string) where the document can be found, and an optional inherited internal reference Identification, which refers to a system interpretable position within the document. The optional inherited Name attribute is meant to have meaning for human readers. Optional document metadata can also be captured through reference to IfcDocumentInformation.
 */
var IfcDocumentReference = 1188;
/**
 * The door is a built element that is predominately used to provide controlled access for people, goods, animals and vehicles. It includes constructions with hinged, pivoted, sliding, and additionally revolving and folding operations. REMOVE: A door consists of a lining and one or several panels.
 */
var IfcDoor = 1189;
/**
 * The door lining is the frame which enables the door leaf to be fixed in position. The door lining is used to hang the door leaf. The parameters of the door lining define the geometrically relevant parameter of the lining.
 */
var IfcDoorLiningProperties = 1190;
/**
 * A door panel is normally a door leaf that opens to allow people or goods to pass. The parameters of the door panel define the geometrically relevant parameter of the panel,
 */
var IfcDoorPanelProperties = 1191;
/**
 * The standard door, IfcDoorStandardCase, defines a door with certain constraints for the provision of operation types, opening directions, frame and lining parameters, and with certain constraints for the geometric representation. The IfcDoorStandardCase handles all cases of doors, that:
 */
var IfcDoorStandardCase = 1192;
/**
 * Definition: The door style, IfcDoorStyle, defines a particular style of doors, which may be included into the spatial context of the building model through instances of IfcDoor. A door style defines the overall parameter of the door style and refers to the particular parameter of the lining and one (or several) panels through the IfcDoorLiningProperties and the IfcDoorPanelProperties.
 */
var IfcDoorStyle = 1193;
/**
 * The element type IfcDoorType defines commonly shared information for occurrences of doors. The set of shared information may include:
 */
var IfcDoorType = 1194;
/**
 * The draughting pre defined colour is a pre defined colour for the purpose to identify a colour by name. Allowable names are:
 */
var IfcDraughtingPreDefinedColour = 1195;
/**
 * The draughting predefined curve font type defines a selection of widely used curve fonts for draughting purposes by name.
 */
var IfcDraughtingPreDefinedCurveFont = 1196;
/**
 * A duct fitting is a junction or transition in a ducted flow distribution system or used to connect duct segments, resulting in changes in flow characteristics to the fluid such as direction and flow rate.
 */
var IfcDuctFitting = 1197;
/**
 * The flow fitting type IfcDuctFittingType defines commonly shared information for occurrences of duct fittings. The set of shared information may include:
 */
var IfcDuctFittingType = 1198;
/**
 * A duct segment is used to typically join two sections of duct network.
 */
var IfcDuctSegment = 1199;
/**
 * The flow segment type IfcDuctSegmentType defines commonly shared information for occurrences of duct segments. The set of shared information may include:
 */
var IfcDuctSegmentType = 1200;
/**
 * A duct silencer is a device that is typically installed inside a duct distribution system for the purpose of reducing the noise levels from air movement, fan noise, etc. in the adjacent space or downstream of the duct silencer device.
 */
var IfcDuctSilencer = 1201;
/**
 * The flow treatment device type IfcDuctSilencerType defines commonly shared information for occurrences of duct silencers. The set of shared information may include:
 */
var IfcDuctSilencerType = 1202;
/**
 * An IfcEdge defines two vertices being connected topologically. The geometric representation of the connection between the two vertices defaults to a straight line if no curve geometry is assigned using the subtype IfcEdgeCurve. The IfcEdge can therefore be used to exchange straight edges without an associated geometry provided by IfcLine or IfcPolyline thought IfcEdgeCurve.EdgeGeometry.
 */
var IfcEdge = 1203;
/**
 * An IfcEdgeCurve defines two vertices being connected topologically including the geometric representation of the connection.
 */
var IfcEdgeCurve = 1204;
/**
 *
 */
var IfcEdgeLoop = 1205;
/**
 * An electric appliance is a device intended for consumer usage that is powered by electricity.
 */
var IfcElectricAppliance = 1206;
/**
 * The flow terminal type IfcElectricApplianceType defines commonly shared information for occurrences of electric appliances. The set of shared information may include:
 */
var IfcElectricApplianceType = 1207;
/**
 * A distribution board is a flow controller in which instances of electrical devices are brought together at a single place for a particular purpose.
 */
var IfcElectricDistributionBoard = 1208;
/**
 * The flow controller type IfcElectricDistributionBoardType defines commonly shared information for occurrences of electric distribution boards. The set of shared information may include:
 */
var IfcElectricDistributionBoardType = 1209;
/**
 * An electric flow storage device is a device in which electrical energy is stored and from which energy may be progressively released.
 */
var IfcElectricFlowStorageDevice = 1210;
/**
 * The flow storage device type IfcElectricFlowStorageDeviceType defines commonly shared information for occurrences of electric flow storage devices. The set of shared information may include:
 */
var IfcElectricFlowStorageDeviceType = 1211;
/**
 * An electric generator is an engine that is a machine for converting mechanical energy into electrical energy.
 */
var IfcElectricGenerator = 1212;
/**
 * The energy conversion device type IfcElectricGeneratorType defines commonly shared information for occurrences of electric generators. The set of shared information may include:
 */
var IfcElectricGeneratorType = 1213;
/**
 * An electric motor is an engine that is a machine for converting electrical energy into mechanical energy.
 */
var IfcElectricMotor = 1214;
/**
 * The energy conversion device type IfcElectricMotorType defines commonly shared information for occurrences of electric motors. The set of shared information may include:
 */
var IfcElectricMotorType = 1215;
/**
 * An electric time control is a device that applies control to the provision or flow of electrical energy over time.
 */
var IfcElectricTimeControl = 1216;
/**
 * The flow controller type IfcElectricTimeControlType defines commonly shared information for occurrences of electric time controls. The set of shared information may include:
 */
var IfcElectricTimeControlType = 1217;
/**
 * An element is a generalization of all components that make up an AEC product.
 */
var IfcElement = 1218;
/**
 * An IfcElementarySurface in the kdtree3 supertype of analytical surfaces.
 */
var IfcElementarySurface = 1219;
/**
 * The IfcElementAssembly represents complex element assemblies aggregated from several elements, such as discrete elements, building elements, or other elements.
 */
var IfcElementAssembly = 1220;
/**
 * The IfcElementAssemblyType defines a list of commonly shared property set definitions of an element and an optional set of product representations. It is used to define an element specification (i.e. the specific product information, that is kdtree3 to all occurrences of that product type).
 */
var IfcElementAssemblyType = 1221;
/**
 * An element component is a representation for minor items included in, added to or connecting to or between elements, which usually are not of interest from the overall building structure viewpoint. However, these small parts may have vital and load carrying functions within the construction. These items do not provide any actual space boundaries. Typical examples of _IfcElementComponent_s include different kinds of fasteners and various accessories.
 */
var IfcElementComponent = 1222;
/**
 * The element type IfcElementComponentType defines commonly shared information for occurrences of element components. The set of shared information may include:
 */
var IfcElementComponentType = 1223;
/**
 * An IfcElementQuantity defines a set of derived measures of an element's physical property. Elements could be spatial structure elements (like buildings, storeys, or spaces) or building elements (like walls, slabs, finishes). The IfcElementQuantity gets assigned to the element by using the IfcRelDefinesByProperties relationship.
 */
var IfcElementQuantity = 1224;
/**
 * IfcElementType defines a list of commonly shared property set definitions of an element and an optional set of product representations. It is used to define an element specification (i.e. the specific product information, that is kdtree3 to all occurrences of that product type).
 */
var IfcElementType = 1225;
/**
 * An IfcEllipse is a curve consisting of a set of points whose distances to two fixed points add to the same constant.
 */
var IfcEllipse = 1226;
/**
 * IfcEllipseProfileDef defines an ellipse as the profile definition used by the swept surface geometry or the swept area solid. It is given by its semi axis attributes and placed within the 2D position coordinate system, established by the Position attribute.
 */
var IfcEllipseProfileDef = 1227;
/**
 * The distribution flow element IfcEnergyConversionDevice defines the occurrence of a device used to perform energy conversion or heat transfer and typically participates in a flow distribution system. Its type is defined by IfcEnergyConversionDeviceType or its subtypes.
 */
var IfcEnergyConversionDevice = 1228;
/**
 * The element type IfcEnergyConversionType defines a list of commonly shared property set definitions of an energy conversion device and an optional set of product representations. It is used to define an energy conversion device specification (the specific product information, that is kdtree3 to all occurrences of that product type).
 */
var IfcEnergyConversionDeviceType = 1229;
/**
 * An engine is a device that converts fuel into mechanical energy through combustion.
 */
var IfcEngine = 1230;
/**
 * The energy conversion device type IfcEngineType defines commonly shared information for occurrences of engines. The set of shared information may include:
 */
var IfcEngineType = 1231;
/**
 * An evaporative cooler is a device that cools air by saturating it with water vapor.
 */
var IfcEvaporativeCooler = 1232;
/**
 * The energy conversion device type IfcEvaporativeCoolerType defines commonly shared information for occurrences of evaporative coolers. The set of shared information may include:
 */
var IfcEvaporativeCoolerType = 1233;
/**
 * An evaporator is a device in which a liquid refrigerent is vaporized and absorbs heat from the surrounding fluid.
 */
var IfcEvaporator = 1234;
/**
 * The energy conversion device type IfcEvaporatorType defines commonly shared information for occurrences of evaporators. The set of shared information may include:
 */
var IfcEvaporatorType = 1235;
/**
 * An IfcEvent is something that happens that triggers an action or response.
 */
var IfcEvent = 1236;
/**
 * IfcEventTime captures the time-related information about an event including the different types of event dates (i.e. actual, scheduled, early, and late).
 */
var IfcEventTime = 1237;
/**
 * An IfcEventType defines a particular type of event that may be specified.
 */
var IfcEventType = 1238;
/**
 * The IfcExtendedProperties is an abstract supertype of all extensible property collections that are applicable to certain characterized entities. Instantiable subtypes of IfcExtendedProperties assign the property collection to a particular characterized entity.
 */
var IfcExtendedProperties = 1239;
/**
 * An IfcExternalInformation is the identification of an information source that is not explicitly represented in the current model or in the project database (as an implementation of the current model). The IfcExternalInformation identifies the external source (classification, document, or library), but not the particular items such as a dictionary entry, a classification notation, or a document reference within the external source
 */
var IfcExternalInformation = 1240;
/**
 *
 */
var IfcExternallyDefinedHatchStyle = 1241;
/**
 * IfcExternallyDefinedSurfaceStyle is a definition of a surface style through referencing an external source, such as a material library for rendering information.
 */
var IfcExternallyDefinedSurfaceStyle = 1242;
/**
 *
 */
var IfcExternallyDefinedTextFont = 1243;
/**
 * An IfcExternalReference is the identification of information that is not explicitly represented in the current model or in the project database (as an implementation of the current model). Such information may be contained in classifications, documents or libraries. The IfcExternalReference identifies a particular item, such as a dictionary entry, a classification notation, or a document reference within the external source.
 */
var IfcExternalReference = 1244;
/**
 * IfcExternalReferenceRelationship is a relationship entity that enables objects from the IfcResourceObjectSelect to have the ability to be tagged by external references.
 */
var IfcExternalReferenceRelationship = 1245;
/**
 * The external spatial element defines external regions at the building site. Those regions can be defined:
 */
var IfcExternalSpatialElement = 1246;
/**
 * The external spatial structure element is an abstract entity provided for different kind of external spaces, regions, and volumes.
 */
var IfcExternalSpatialStructureElement = 1247;
/**
 * The IfcExtrudedAreaSolid is defined by sweeping a cross section provided by a profile definition. The direction of the extrusion is given by the ExtrudedDirection attribute and the length of the extrusion is given by the Depth attribute. If the planar area has inner boundaries (holes defined), then those holes shall be swept into holes of the solid.
 */
var IfcExtrudedAreaSolid = 1248;
/**
 * IfcExtrudedAreaSolidTapered is defined by sweeping a cross section along a linear spine. The cross section may change along the sweep from the shape of the start cross section into the shape of the end cross section. The resulting solid is bounded by three or more faces: A start face, an end face (each defined by start and end planes and sections), and one or more lateral faces. Each lateral face is a ruled surface defined by a pair of corresponding edges of the start and end section.
 */
var IfcExtrudedAreaSolidTapered = 1249;
/**
 * An IfcFace is topological entity used to define surface, bounded by loops, of a shell.
 */
var IfcFace = 1250;
/**
 * The IfcFaceBasedSurfaceModel represents the a shape by connected face sets. The connected faces have a dimensionality 2 and are placed in a coordinate space of dimensionality 3.
 */
var IfcFaceBasedSurfaceModel = 1251;
/**
 *
 */
var IfcFaceBound = 1252;
/**
 *
 */
var IfcFaceOuterBound = 1253;
/**
 * The IfcFaceSurface defines the underlying geometry of the associated surface to the face.
 */
var IfcFaceSurface = 1254;
/**
 * The IfcFacetedBrep is a manifold solid brep with the restriction that all faces are planar and bounded polygons.
 */
var IfcFacetedBrep = 1255;
/**
 * The IfcFacetedBrepWithVoids is a specialization of a faceted B-rep which contains one or more voids in its interior. The voids are represented as closed shells which are defined so that the shell normal point into the void.
 */
var IfcFacetedBrepWithVoids = 1256;
/**
 * Defines forces at which a support or connection fails.
 */
var IfcFailureConnectionCondition = 1257;
/**
 * A fan is a device which imparts mechanical work on a gas. A typical usage of a fan is to induce airflow in a building services air distribution system.
 */
var IfcFan = 1258;
/**
 * The flow moving device type IfcFanType defines commonly shared information for occurrences of fans. The set of shared information may include:
 */
var IfcFanType = 1259;
/**
 * Representations of fixing parts which are used as fasteners to connect or join elements with other elements. Excluded are mechanical fasteners which are modeled by a separate entity (IfcMechanicalFastener).
 */
var IfcFastener = 1260;
/**
 * The element component type IfcFastenerType defines commonly shared information for occurrences of fasteners. The set of shared information may include:
 */
var IfcFastenerType = 1261;
/**
 * A feature element is a generalization of all existence dependent elements which modify the shape and appearance of the associated master element. The IfcFeatureElement offers the ability to handle shape modifiers as semantic objects within the IFC object model.
 */
var IfcFeatureElement = 1262;
/**
 * A feature element addition is a specialization of the general feature element, that represents an existence dependent element which modifies the shape and appearance of the associated master element. The IfcFeatureElementAddition offers the ability to handle shape modifiers as semantic objects within the IFC object model that add to the shape of the master element.
 */
var IfcFeatureElementAddition = 1263;
/**
 * The IfcFeatureElementSubtraction is specialization of the general feature element, that represents an existence dependent elements which modifies the shape and appearance of the associated master element. The IfcFeatureElementSubtraction offers the ability to handle shape modifiers as semantic objects within the IFC object model that subtract from the shape of the master element.
 */
var IfcFeatureElementSubtraction = 1264;
/**
 * An IfcFillAreaStyle provides the style table for presentation information assigned to annotation fill areas or surfaces for hatching and tiling. The _IfcFillAreaStyle_defines hatches as model hatches, that is, the distance between hatch lines, or the curve patterns of hatch lines are given in model space dimensions (that have to be scaled using the target plot scale). The IfcFillAreaStyle allows for the following combinations of defining the style of hatching and tiling:
 */
var IfcFillAreaStyle = 1265;
/**
 * The IfcFillAreaStyleHatching is used to define simple, vector-based hatching patterns, based on styled straight lines. The curve font, color and thickness is given by the HatchLineAppearance, the angle by the HatchLineAngle and the distance to the next hatch line by StartOfNextHatchLine, being either an offset distance or a vector.
 */
var IfcFillAreaStyleHatching = 1266;
/**
 * The IfcFillAreaStyleTiles defines the filling of an IfcAnnotationFillArea by recurring patterns of styled two dimensional geometry, called a tile. The recurrence pattern is determined by two vectors, that multiply the tile in regular form.
 */
var IfcFillAreaStyleTiles = 1267;
/**
 * A filter is an apparatus used to remove particulate or gaseous matter from fluids and gases.
 */
var IfcFilter = 1268;
/**
 * The flow treatment device type IfcFilterType defines commonly shared information for occurrences of filters. The set of shared information may include:
 */
var IfcFilterType = 1269;
/**
 * A fire suppression terminal has the purpose of delivering a fluid (gas or liquid) that will suppress a fire.
 */
var IfcFireSuppressionTerminal = 1270;
/**
 * The flow terminal type IfcFireSuppressionTerminalType defines commonly shared information for occurrences of fire suppression terminals. The set of shared information may include:
 */
var IfcFireSuppressionTerminalType = 1271;
/**
 * An IfcFixedReferenceSweptAreaSolid is a type of swept area solid which is the result of sweeping an area along a Directrix. The swept area is provided by a subtype of IfcProfileDef. The profile is placed by an implicit cartesian transformation operator at the start point of the sweep, where the profile normal agrees to the tangent of the directrix at this point, and the profile''s x-axis agrees to the FixedReference direction. The orientation of the curve during the sweeping operation is controlled by the FixedReference direction.
 */
var IfcFixedReferenceSweptAreaSolid = 1272;
/**
 * The distribution flow element IfcFlowController defines the occurrence of elements of a distribution system that are used to regulate flow through a distribution system. Examples include dampers, valves, switches, and relays. Its type is defined by IfcFlowControllerType or subtypes.
 */
var IfcFlowController = 1273;
/**
 * The element type IfcFlowControllerType defines a list of commonly shared property set definitions of a flow controller and an optional set of product representations. It is used to define a flow controller specification (i.e. the specific product information, that is kdtree3 to all occurrences of that product type).
 */
var IfcFlowControllerType = 1274;
/**
 * The distribution flow element IfcFlowFitting defines the occurrence of a junction or transition in a flow distribution system, such as an elbow or tee. Its type is defined by IfcFlowFittingType or its subtypes.
 */
var IfcFlowFitting = 1275;
/**
 * The element type IfcFlowFittingType defines a list of commonly shared property set definitions of a flow fitting and an optional set of product representations. It is used to define a flow fitting specification (i.e. the specific product information, that is kdtree3 to all occurrences of that product type).
 */
var IfcFlowFittingType = 1276;
/**
 * A flow instrument reads and displays the value of a particular property of a system at a point, or displays the difference in the value of a property between two points.
 */
var IfcFlowInstrument = 1277;
/**
 * The distribution control element type IfcFlowInstrumentType defines commonly shared information for occurrences of flow instruments. The set of shared information may include:
 */
var IfcFlowInstrumentType = 1278;
/**
 * A flow meter is a device that is used to measure the flow rate in a system.
 */
var IfcFlowMeter = 1279;
/**
 * The flow controller type IfcFlowMeterType defines commonly shared information for occurrences of flow meters. The set of shared information may include:
 */
var IfcFlowMeterType = 1280;
/**
 * The distribution flow element IfcFlowMovingDevice defines the occurrence of an apparatus used to distribute, circulate or perform conveyance of fluids, including liquids and gases (such as a pump or fan), and typically participates in a flow distribution system. Its type is defined by IfcFlowMovingDeviceType or its subtypes.
 */
var IfcFlowMovingDevice = 1281;
/**
 * The element type IfcFlowMovingDeviceType defines a list of commonly shared property set definitions of a flow moving device and an optional set of product representations. It is used to define a flow moving device specification (i.e. the specific product information, that is kdtree3 to all occurrences of that product type).
 */
var IfcFlowMovingDeviceType = 1282;
/**
 * The distribution flow element IfcFlowSegment defines the occurrence of a segment of a flow distribution system.
 */
var IfcFlowSegment = 1283;
/**
 * The element type IfcFlowSegmentType defines a list of commonly shared property set definitions of a flow segment and an optional set of product representations. It is used to define a flow segment specification (the specific product information, that is kdtree3 to all occurrences of that product type).
 */
var IfcFlowSegmentType = 1284;
/**
 * The distribution flow element IfcFlowStorageDevice defines the occurrence of a device that participates in a distribution system and is used for temporary storage (such as a tank). Its type is defined by IfcFlowStorageDeviceType or its subtypes.
 */
var IfcFlowStorageDevice = 1285;
/**
 * The element type IfcFlowStorageDeviceType defines a list of commonly shared property set definitions of a flow storage device and an optional set of product representations. It is used to define a flow storage device specification (the specific product information that is kdtree3 to all occurrences of that product type).
 */
var IfcFlowStorageDeviceType = 1286;
/**
 * The distribution flow element IfcFlowTerminal defines the occurrence of a permanently attached element that acts as a terminus or beginning of a distribution system (such as an air outlet, drain, water closet, or sink). A terminal is typically a point at which a system interfaces with an external environment. Its type is defined by IfcFlowTerminalType or its subtypes.
 */
var IfcFlowTerminal = 1287;
/**
 * The element type IfcFlowTerminalType defines a list of commonly shared property set definitions of a flow terminal and an optional set of product representations. It is used to define a flow terminal specification (the specific product information that is kdtree3 to all occurrences of that product type).
 */
var IfcFlowTerminalType = 1288;
/**
 * The distribution flow element IfcFlowTreatmentDevice defines the occurrence of a device typically used to remove unwanted matter from a fluid, either liquid or gas, and typically participates in a flow distribution system. Its type is defined by IfcFlowTreatmentDeviceType or its subtypes.
 */
var IfcFlowTreatmentDevice = 1289;
/**
 * The element type IfcFlowTreatmentDeviceType defines a list of commonly shared property set definitions of a flow treatment device and an optional set of product representations. It is used to define a flow treatment device specification (the specific product information that is kdtree3 to all occurrences of that product type).
 */
var IfcFlowTreatmentDeviceType = 1290;
/**
 * A footing is a part of the foundation of a structure that spreads and transmits the load to the soil. A footing is also characterized as shallow foundation, where the loads are transfered to the ground near the surface.
 */
var IfcFooting = 1291;
/**
 * The building element type IfcFootingType defines commonly shared information for occurrences of footings. The set of shared information may include:
 */
var IfcFootingType = 1292;
/**
 * A furnishing element is a generalization of all furniture related objects. Furnishing objects are characterized as being
 */
var IfcFurnishingElement = 1293;
/**
 * IfcFurnishingElementType defines a list of commonly shared property set definitions of an element and an optional set of product representations. It is used to define an element specification (the specific product information, that is kdtree3 to all occurrences of that product type).
 */
var IfcFurnishingElementType = 1294;
/**
 * Furniture defines complete furnishings such as a table, desk, chair, or cabinet, which may or may not be permanently attached to a building structure.
 */
var IfcFurniture = 1295;
/**
 * The furnishing element type IfcFurnitureType defines commonly shared information for occurrences of furnitures. The set of shared information may include:
 */
var IfcFurnitureType = 1296;
/**
 * An IfcGeographicElement is a generalization of all elements within a geographical landscape. It includes occurrences of typical geographical elements, often referred to as features, such as trees or terrain. Common type information behind several occurrences of IfcGeographicElement is provided by the IfcGeographicElementType.
 */
var IfcGeographicElement = 1297;
/**
 * An IfcGeographicElementType is used to define an element specification of a geographic element (i.e. the specific product information, that is kdtree3 to all occurrences of that product type). Geographic element types include for different types of element that may be used to represent information within a geographical landscape external to a building. Within the world of geographic information they are referred to generally as ''features''. IfcGeographicElementType''s include:
 */
var IfcGeographicElementType = 1298;
/**
 * The IfcGeometricCurveSet is used for the exchange of shape representation consisting of an collection of (2D or 3D) points and curves only.
 */
var IfcGeometricCurveSet = 1299;
/**
 * The IfcGeometricRepresentationContext defines the context that applies to several shape representations of products within a project. It defines the type of the context in which the shape representation is defined, and the numeric precision applicable to the geometric representation items defined in this context. In addition it can be used to offset the project coordinate system from a global point of origin, using the WorldCoordinateSystem attribute. The main representation context may also provide the true north direction, see Figure 426.
 */
var IfcGeometricRepresentationContext = 1300;
/**
 * An IfcGeometricRepresentationItem is the kdtree3 supertype of all geometric items used within a representation. It is positioned within a geometric coordinate system, directly or indirectly through intervening items.
 */
var IfcGeometricRepresentationItem = 1301;
/**
 * IfcGeometricRepresentationSubContext defines the context that applies to several shape representations of a product being a sub context, sharing the WorldCoordinateSystem, CoordinateSpaceDimension, Precision and TrueNorth attributes with the parent IfcGeometricRepresentationContext.
 */
var IfcGeometricRepresentationSubContext = 1302;
/**
 * The IfcGeometricSet is used for the exchange of shape representation consisting of (2D or 3D) points, curves, and surfaces, which do not have a topological structure (such as connected face sets or shells), are not tessellated and are not solid models (such as swept solids, CSG or Brep).
 */
var IfcGeometricSet = 1303;
/**
 * IfcGrid ia a planar design grid defined in 3D space used as an aid in locating structural and design elements. The position of the grid (ObjectPlacement) is defined by a 3D coordinate system (and thereby the design grid can be used in plan, section or in any position relative to the world coordinate system). The position can be relative to the object placement of other products or grids. The XY plane of the 3D coordinate system is used to place the grid axes, which are 2D curves (for example, line, circle, arc, polyline).
 */
var IfcGrid = 1304;
/**
 * An individual axis, IfcGridAxis, is defined in the context of a design grid. The axis definition is based on a curve of dimensionality 2. The grid axis is positioned within the XY plane of the position coordinate system defined by the IfcGrid.
 */
var IfcGridAxis = 1305;
/**
 * IfcGridPlacement provides a specialization of IfcObjectPlacement in which the placement and axis direction of the object coordinate system is defined by a reference to the design grid as defined in IfcGrid.
 */
var IfcGridPlacement = 1306;
/**
 * IfcGroup is an generalization of any arbitrary group. A group is a logical collection of objects. It does not have its own position, nor can it hold its own shape representation. Therefore a group is an aggregation under some non-geometrical / topological grouping aspects.
 */
var IfcGroup = 1307;
/**
 * A half space solid divides the domain into two by a base surface. Normally, the base surface is a plane and devides the infinitive space into two and indicates the side of the half-space by agreeing or disagreeing to the normal of the plane.
 */
var IfcHalfSpaceSolid = 1308;
/**
 * A heat exchanger is a device used to provide heat transfer between non-mixing media such as plate and shell and tube heat exchangers.
 */
var IfcHeatExchanger = 1309;
/**
 * The energy conversion device type IfcHeatExchangerType defines commonly shared information for occurrences of heat exchangers. The set of shared information may include:
 */
var IfcHeatExchangerType = 1310;
/**
 * A humidifier is a device that adds moisture into the air.
 */
var IfcHumidifier = 1311;
/**
 * The energy conversion device type IfcHumidifierType defines commonly shared information for occurrences of humidifiers. The set of shared information may include:
 */
var IfcHumidifierType = 1312;
/**
 * An IfcImageTexture provides a 2-dimensional texture that can be applied to a surface of an geometric item and that provides lighting parameters of a surface onto which it is mapped. The texture is provided as an image file at an external location for which an URL is provided.
 */
var IfcImageTexture = 1313;
/**
 * The IfcIndexedColourMap provides the assignment of colour information to individual faces. It is used for colouring faces of tessellated face sets. The IfcIndexedColourMap defines an index into an indexed list of colour information. The Colours are a two-dimensional list of colours provided by three RGB values. The ColourIndex attribute corresponds to the CoordIndex of the IfcTessellatedFaceSet defining the corresponding index list of faces. The Opacity attribute provides the alpha channel for all faces of the tessellated face set.
 */
var IfcIndexedColourMap = 1314;
/**
 * The IfcIndexedPolyCurve is a bounded curve with only linear and circular arc segments defined by a Cartesian point list and an optional list of segments, providing indices into the Cartesian point list. In the case that the list of Segments is not provided, all points in the IfcCartesianPointList are connected by straight line segments in the order they appear in the IfcCartesianPointList.
 */
var IfcIndexedPolyCurve = 1315;
/**
 * The IfcIndexedPolygonalFace is a compact representation of a planar face being part of a face set. The vertices of the polygonal planar face are provided by 3 or more Cartesian points, defined by indices that point into an IfcCartesianPointList3D, either direcly, or via the PnIndex, if provided at IfcPolygonalFaceSet.
 */
var IfcIndexedPolygonalFace = 1316;
/**
 * The IfcIndexedPolygonalFaceWithVoids is a compact representation of a planar face with inner loops, being part of a face set.
 */
var IfcIndexedPolygonalFaceWithVoids = 1317;
/**
 * The IfcIndexedTextureMap provides the mapping of the 2-dimensional texture coordinates to the surface onto which it is mapped. It is used for mapping the texture to faces of tessellated face sets.
 */
var IfcIndexedTextureMap = 1318;
/**
 * The IfcIndexedTriangleTextureMap provides the mapping of the 2-dimensional texture coordinates to the surface onto which it is mapped. It is used for mapping the texture to triangles of the IfcTriangulatedFaceSet.
 */
var IfcIndexedTriangleTextureMap = 1319;
/**
 * An interceptor is a device designed and installed in order to separate and retain deleterious, hazardous or undesirable matter while permitting normal sewage or liquids to discharge into a collection system by gravity.
 */
var IfcInterceptor = 1320;
/**
 * The flow treatment device type IfcInterceptorType defines commonly shared information for occurrences of interceptors. The set of shared information may include:
 */
var IfcInterceptorType = 1321;
/**
 * An IfcIntersectionCurve is a 3-dimensional curve that has two additional representations provided by two pcurves defined within two distinct and intersecting surfaces.
 */
var IfcIntersectionCurve = 1322;
/**
 * An inventory is a list of items within an enterprise.
 */
var IfcInventory = 1323;
/**
 * In an irregular time series, unpredictable bursts of data arrive at unspecified points in time, or most time stamps cannot be characterized by a repeating pattern.
 */
var IfcIrregularTimeSeries = 1324;
/**
 * The IfcIrregularTimeSeriesValue describes a value (or set of values) at a particular time point.
 */
var IfcIrregularTimeSeriesValue = 1325;
/**
 * IfcIShapeProfileDef defines a section profile that provides the defining parameters of an 'I' or 'H' section. The I-shape profile has values for its overall depth, width and its web and flange thicknesses. Additionally a fillet radius, flange edge radius, and flange slope may be given. This profile definition represents an I-section which is symmetrical about its major and minor axes; top and bottom flanges are equal and centred on the web.
 */
var IfcIShapeProfileDef = 1326;
/**
 * A junction box is an enclosure within which cables are connected.
 */
var IfcJunctionBox = 1327;
/**
 * The flow fitting type IfcJunctionBoxType defines commonly shared information for occurrences of junction boxs. The set of shared information may include:
 */
var IfcJunctionBoxType = 1328;
/**
 * An IfcLaborResource is used in construction with particular skills or crafts required to perform certain types of construction or management related work.
 */
var IfcLaborResource = 1329;
/**
 * The resource type IfcLaborResourceType defines commonly shared information for occurrences of labour resources. The set of shared information may include:
 */
var IfcLaborResourceType = 1330;
/**
 * IfcLagTime describes the time parameters that may exist within a sequence relationship between two processes.
 */
var IfcLagTime = 1331;
/**
 * A lamp is an artificial light source such as a light bulb or tube.
 */
var IfcLamp = 1332;
/**
 * The flow terminal type IfcLampType defines commonly shared information for occurrences of lamps. The set of shared information may include:
 */
var IfcLampType = 1333;
/**
 * An IfcLibraryInformation describes a library where a library is a structured store of information, normally organized in a manner which allows information lookup through an index or reference value. IfcLibraryInformation provides the library Name and optional Description, Version, VersionDate and Publisher attributes. A Location may be added for electronic access to the library.
 */
var IfcLibraryInformation = 1334;
/**
 * An IfcLibraryReference is a reference into a library of information by Location (provided as a URI). It also provides an optional inherited Identification key to allow more specific references to library sections or tables. The inherited Name attribute allows for a human interpretable identification of the library item. Also, general information on the library from which the reference is taken, is given by the ReferencedLibrary relation which identifies the relevant occurrence of IfcLibraryInformation.
 */
var IfcLibraryReference = 1335;
/**
 * IfcLightDistributionData defines the luminous intensity of a light source given at a particular main plane angle. It is based on some standardized light distribution curves; the MainPlaneAngle is either the
 */
var IfcLightDistributionData = 1336;
/**
 * A light fixture is a container that is designed for the purpose of housing one or more lamps and optionally devices that control, restrict or vary their emission.
 */
var IfcLightFixture = 1337;
/**
 * The flow terminal type IfcLightFixtureType defines commonly shared information for occurrences of light fixtures. The set of shared information may include:
 */
var IfcLightFixtureType = 1338;
/**
 * IfcLightIntensityDistribution defines the the luminous intensity of a light source that changes according to the direction of the ray. It is based on some standardized light distribution curves, which are defined by the LightDistributionCurve attribute.
 */
var IfcLightIntensityDistribution = 1339;
/**
 *
 */
var IfcLightSource = 1340;
/**
 *
 */
var IfcLightSourceAmbient = 1341;
/**
 *
 */
var IfcLightSourceDirectional = 1342;
/**
 * IfcLightSourceGoniometric defines a light source for which exact lighting data is available. It specifies the type of a light emitter, defines the position and orientation of a light distribution curve and the data concerning lamp and photometric information.
 */
var IfcLightSourceGoniometric = 1343;
/**
 *
 */
var IfcLightSourcePositional = 1344;
/**
 *
 */
var IfcLightSourceSpot = 1345;
/**
 * The IfcLine is an unbounded line parameterized by an IfcCartesianPoint and an IfcVector. The magnitude of the IfcVector affects the parameterization of the line, but it does not bound the line.
 */
var IfcLine = 1346;
/**
 * An IfcLocalPlacement defines the relative placement of a product in relation to the placement of another product or the absolute placement of a product within the geometric representation context of the project.
 */
var IfcLocalPlacement = 1347;
/**
 *
 */
var IfcLoop = 1348;
/**
 * IfcLShapeProfileDef defines a section profile that provides the defining parameters of an L-shaped section (equilateral L profiles are also covered by this entity) to be used by the swept area solid. Its parameters and orientation relative to the position coordinate system are according to the following illustration. The shorter leg has the same direction as the positive Position.P[1]-axis, the longer or equal leg the same as the positive Position.P[2]-axis. The centre of the position coordinate system is in the profiles centre of the bounding box.
 */
var IfcLShapeProfileDef = 1349;
/**
 * The IfcManifoldSolidBrep is a solid represented as a collection of connected surfaces that delimit the solid from the surrounding non-solid.
 */
var IfcManifoldSolidBrep = 1350;
/**
 * The map conversion deals with transforming the local engineering coordinate system, often called world coordinate system, into the coordinate reference system of the underlying map.
 */
var IfcMapConversion = 1351;
/**
 * The IfcMappedItem is the inserted instance of a source definition (to be compared with a block / shared cell / macro definition). The instance is inserted by applying a Cartesian transformation operator as the MappingTarget.
 */
var IfcMappedItem = 1352;
/**
 * IfcMaterial is a homogeneous or inhomogeneous substance that can be used to form elements (physical products or their components).
 */
var IfcMaterial = 1353;
/**
 * IfcMaterialClassificationRelationship is a relationship assigning classifications to materials.
 */
var IfcMaterialClassificationRelationship = 1354;
/**
 * IfcMaterialConstituent is a single and identifiable part of an element which is constructed of a number of part (one or more) each having an individual material. The association of the material constituent to the part is provided by a keyword as value of the Name attribute. In order to identify and distinguish the part of the shape representation to which the material constituent applies the IfcProductDefinitionShape of the element has to include instances of IfcShapeAspect, using the same keyword for their Name attribute.
 */
var IfcMaterialConstituent = 1355;
/**
 * IfcMaterialConstituentSet is a collection of individual material constituents, each assigning a material to a part of an element. The parts are only identified by a keyword (as opposed to an IfcMaterialLayerSet or IfcMaterialProfileSet where each part has an individual shape parameter (layer thickness or layer profile).
 */
var IfcMaterialConstituentSet = 1356;
/**
 * IfcMaterialDefinition is a general supertype for all material related information items in IFC that have kdtree3 material related properties that may include association of material with some shape parameters or assignments to identified parts of a component.
 */
var IfcMaterialDefinition = 1357;
/**
 * IfcMaterialDefinitionRepresentation defines presentation information relating to IfcMaterial. It allows for multiple presentations of the same material for different geometric representation contexts.
 */
var IfcMaterialDefinitionRepresentation = 1358;
/**
 * IfcMaterialLayer is a single and identifiable part of an element which is constructed of a number of layers (one or more). Each IfcMaterialLayer has a constant thickness and is located relative to the referencing IfcMaterialLayerSet along the material layer set base (MlsBase).
 */
var IfcMaterialLayer = 1359;
/**
 * The IfcMaterialLayerSet is a designation by which materials of an element constructed of a number of material layers is known and through which the relative positioning of individual layers can be expressed.
 */
var IfcMaterialLayerSet = 1360;
/**
 * The IfcMaterialLayerSetUsage determines the usage of IfcMaterialLayerSet in terms of its location and orientation relative to the associated element geometry. The location of material layer set shall be compatible with the building element geometry (that is, material layers shall fit inside the element geometry). The rules to ensure the compatibility depend on the type of the building element.
 */
var IfcMaterialLayerSetUsage = 1361;
/**
 * IfcMaterialLayerWithOffsets is a specialization of IfcMaterialLayer enabling definition of offset values along edges (within the material layer set usage in parent layer set).
 */
var IfcMaterialLayerWithOffsets = 1362;
/**
 * IfcMaterialList is a list of the different materials that are used in an element.
 */
var IfcMaterialList = 1363;
/**
 * IfcMaterialProfile is a single and identifiable cross section of an element which is constructed of a number of profiles (one or more).
 */
var IfcMaterialProfile = 1364;
/**
 * The IfcMaterialProfileSet is a designation by which individual material(s) of a prismatic element (for example, beam or column) constructed of a single or multiple material profiles is known.
 */
var IfcMaterialProfileSet = 1365;
/**
 * IfcMaterialProfileSetUsage determines the usage of IfcMaterialProfileSet in terms of its location relative to the associated element geometry. The location of a material profile set shall be compatible with the building element geometry (that is, material profiles shall fit inside the element geometry). The rules to ensure the compatibility depend on the type of the building element. For building elements with shape representations which are based on extruded solids, this is accomplished by referring to the identical profile definition in the shape model as in the material profile set.
 */
var IfcMaterialProfileSetUsage = 1366;
/**
 * IfcMaterialProfileSetUsageTapering specifies dual material profile sets in association with tapered prismatic (beam- or column-like) elements.
 */
var IfcMaterialProfileSetUsageTapering = 1367;
/**
 * IfcMaterialProfileWithOffsets is a specialization of IfcMaterialProfile with additional longitudinal offsets .
 */
var IfcMaterialProfileWithOffsets = 1368;
/**
 * The IfcMaterialProperties assigns a set of material properties to associated material definitions. The set may be identified by a Name and a Description. The IfcProperty (instantiable subtypes) is used to express the individual material properties by name, description, value and unit.
 */
var IfcMaterialProperties = 1369;
/**
 * IfcMaterialRelationship defines a relationship between part and whole in material definitions (as in composite materials). The parts, expressed by the set of RelatedMaterials, are material constituents of which a single material aggregate is composed.
 */
var IfcMaterialRelationship = 1370;
/**
 * IfcMaterialUsageDefinition is a general supertype for all material related information items in IFC that have occurrence specific assignment parameters to assign a set of materials with shape parameters to a reference geometry item of that component.
 */
var IfcMaterialUsageDefinition = 1371;
/**
 *
 */
var IfcMeasureWithUnit = 1372;
/**
 * A mechanical fasteners connecting building elements or parts mechanically. A single instance of this class may represent one or many of actual mechanical fasteners, for example an array of bolts or a row of nails.
 */
var IfcMechanicalFastener = 1373;
/**
 * The element component type IfcMechanicalFastenerType defines commonly shared information for occurrences of mechanical fasteners. The set of shared information may include:
 */
var IfcMechanicalFastenerType = 1374;
/**
 * A medical device is attached to a medical piping system and operates upon medical gases to perform a specific function. Medical gases include medical air, medical vacuum, oxygen, carbon dioxide, nitrogen, and nitrous oxide.
 */
var IfcMedicalDevice = 1375;
/**
 * The flow terminal type IfcMedicalDeviceType defines commonly shared information for occurrences of medical devices. The set of shared information may include:
 */
var IfcMedicalDeviceType = 1376;
/**
 * An IfcMember is a structural member designed to carry loads between or beyond points of support. It is not required to be load bearing. The orientation of the member (being horizontal, vertical or sloped) is not relevant to its definition (in contrary to IfcBeam and IfcColumn). An IfcMember represents a linear structural element from an architectural or structural modeling point of view and shall be used if it cannot be expressed more specifically as either an IfcBeam or an IfcColumn.
 */
var IfcMember = 1377;
/**
 * The standard member, IfcMemberStandardCase, defines a member with certain constraints for the provision of material usage, parameters and with certain constraints for the geometric representation. The IfcMemberStandardCase handles all cases of members, that:
 */
var IfcMemberStandardCase = 1378;
/**
 * The element type IfcMemberType defines commonly shared information for occurrences of members. Members are predominately linear building elements, often forming part of a structural system. The orientation of the member (being horizontal, vertical or sloped) is not relevant to its definition (in contrary to beam and column). The set of shared information may include:
 */
var IfcMemberType = 1379;
/**
 * An IfcMetric is used to capture quantitative resultant metrics that can be applied to objectives.
 */
var IfcMetric = 1380;
/**
 * The IfcMirroredProfileDef defines the profile by mirroring the parent profile about the y axis of the parent profile coordinate system. That is, left and right of the parent profile are swapped.
 */
var IfcMirroredProfileDef = 1381;
/**
 * IfcMonetaryUnit is a unit to define currency for money.
 */
var IfcMonetaryUnit = 1382;
/**
 * A motor connection provides the means for connecting a motor as the driving device to the driven device.
 */
var IfcMotorConnection = 1383;
/**
 * The energy conversion device type IfcMotorConnectionType defines commonly shared information for occurrences of motor connections. The set of shared information may include:
 */
var IfcMotorConnectionType = 1384;
/**
 *
 */
var IfcNamedUnit = 1385;
/**
 * An IfcObject is the generalization of any semantically treated thing or process. Objects are things as they appear - i.e. occurrences.
 */
var IfcObject = 1386;
/**
 * An IfcObjectDefinition is the generalization of any semantically treated thing or process, either being a type or an occurrences. Object defintions can be named, using the inherited Name attribute, which should be a user recognizable label for the object occurrance. Further explanations to the object can be given using the inherited Description attribute. A context is a specific kind of object definition as it provides the project or library context in which object types and object occurrences are defined.
 */
var IfcObjectDefinition = 1387;
/**
 * An IfcObjective captures qualitative information for an objective-based constraint.
 */
var IfcObjective = 1388;
/**
 * IfcObjectPlacement is an abstract supertype for the special types defining the object coordinate system. The IfcObjectPlacement has to be provided for each product that has a shape representation.
 */
var IfcObjectPlacement = 1389;
/**
 * An occupant is a type of actor that defines the form of occupancy of a property.
 */
var IfcOccupant = 1390;
/**
 * An IfcOffsetCurve2D is a curve defined by an offset in 2D space from its BasisCurve.
 */
var IfcOffsetCurve2D = 1391;
/**
 * An IfcOffsetCurve3D is a curve defined by an offset in 3D space from its BasisCurve.
 */
var IfcOffsetCurve3D = 1392;
/**
 * The opening element stands for opening, recess or chase, all reflecting voids. It represents a void within any element that has physical manifestation. Openings can be inserted into walls, slabs, beams, columns, or other elements.
 */
var IfcOpeningElement = 1393;
/**
 * The standard opening, IfcOpeningStandardCase, defines an opening with certain constraints for the dimension parameters, position within the voided element, and with certain constraints for the geometric representation. The IfcOpeningStandardCase handles all cases of openings, that:
 */
var IfcOpeningStandardCase = 1394;
/**
 *
 */
var IfcOpenShell = 1395;
/**
 * A named and structured grouping with a corporate identity.
 */
var IfcOrganization = 1396;
/**
 * The IfcOrganizationRelationship establishes an association between one relating organization and one or more related organizations.
 */
var IfcOrganizationRelationship = 1397;
/**
 * The IfcOrientedEdge represents an IfcEdge with an Orientation flag applied. It allows to reuse the same IfcEdge when traversed exactly twice, once forwards and once backwards.
 */
var IfcOrientedEdge = 1398;
/**
 * The IfcOuterBoundaryCurve defines the outer boundary of a bounded surface.
 */
var IfcOuterBoundaryCurve = 1399;
/**
 * An outlet is a device installed at a point to receive one or more inserted plugs for electrical power or communications.
 */
var IfcOutlet = 1400;
/**
 * The flow terminal type IfcOutletType defines commonly shared information for occurrences of outlets. The set of shared information may include:
 */
var IfcOutletType = 1401;
/**
 * IfcOwnerHistory defines all history and identification related information. In order to provide fast access it is directly attached to all independent objects, relationships and properties.
 */
var IfcOwnerHistory = 1402;
/**
 * The parameterized profile definition defines a 2D position coordinate system to which the parameters of the different profiles relate to. All profiles are defined centric to the origin of the position coordinate system, or more specific, the origin [0.,0.] shall be in the center of the bounding box of the profile.
 */
var IfcParameterizedProfileDef = 1403;
/**
 *
 */
var IfcPath = 1404;
/**
 * The IfcPcurve is a curve defined within the parameter space of its reference surface.
 */
var IfcPcurve = 1405;
/**
 * IfcPerformanceHistory is used to document the actual performance of an occurrence instance over time. It includes machine-measured data from building automation systems and human-specified data such as task and resource usage. The data may represent actual conditions, predictions, or simulations.
 */
var IfcPerformanceHistory = 1406;
/**
 * This entity is a description of a panel within a door or window (as fillers for opening) which allows for air flow. It is given by its properties (IfcPermeableCoveringProperties). A permeable covering is a casement, such as a component, fixed or opening, consisting essentially of a frame and the infilling. The infilling is normally a grill, a louver or a screen. The way of operation is defined in the operation type.
 */
var IfcPermeableCoveringProperties = 1407;
/**
 * A permit is a permission to perform work in places and on artifacts where regulatory, security or other access restrictions apply.
 */
var IfcPermit = 1408;
/**
 * This entity represents an individual human being.
 */
var IfcPerson = 1409;
/**
 * This entity represents a person acting on behalf of an organization.
 */
var IfcPersonAndOrganization = 1410;
/**
 * The complex physical quantity, IfcPhysicalComplexQuantity, is an entity that holds a set of single quantity measure value (as defined at the subtypes of IfcPhysicalSimpleQuantity), that all apply to a given component or aspect of the element.
 */
var IfcPhysicalComplexQuantity = 1411;
/**
 * The physical quantity, IfcPhysicalQuantity, is an abstract entity that holds a complex or simple quantity measure together with a semantic definition of the usage for the single or several measure value.
 */
var IfcPhysicalQuantity = 1412;
/**
 * The physical quantity, IfcPhysicalSimpleQuantity, is an entity that holds a single quantity measure value (as defined at the subtypes of IfcPhysicalSimpleQuantity) together with a semantic definition of the usage for the measure value.
 */
var IfcPhysicalSimpleQuantity = 1413;
/**
 * A pile is a slender timber, concrete, or steel structural element, driven, jetted, or otherwise embedded on end in the ground for the purpose of supporting a load. A pile is also characterized as deep foundation, where the loads are transfered to deeper subsurface layers.
 */
var IfcPile = 1414;
/**
 * The building element type IfcPileType defines commonly shared information for occurrences of piles. The set of shared information may include:
 */
var IfcPileType = 1415;
/**
 * A pipe fitting is a junction or transition in a piping flow distribution system used to connect pipe segments, resulting in changes in flow characteristics to the fluid such as direction or flow rate.
 */
var IfcPipeFitting = 1416;
/**
 * The flow fitting type IfcPipeFittingType defines commonly shared information for occurrences of pipe fittings. The set of shared information may include:
 */
var IfcPipeFittingType = 1417;
/**
 * A pipe segment is used to typically join two sections of a piping network.
 */
var IfcPipeSegment = 1418;
/**
 * The flow segment type IfcPipeSegmentType defines commonly shared information for occurrences of pipe segments. The set of shared information may include:
 */
var IfcPipeSegmentType = 1419;
/**
 * An IfcPixelTexture provides a 2D image-based texture map as an explicit array of pixel values (list of Pixel binary attributes). In contrary to the IfcImageTexture the IfcPixelTexture holds a 2 dimensional list of pixel color (and opacity) directly, instead of referencing to an URL.
 */
var IfcPixelTexture = 1420;
/**
 * An IfcPlacement is an abstract supertype of placement subtypes that define the location of an item, or an entire shape representation, and provide its orientation. All placement subtypes define right-handed Cartesian coordinate systems and do not allow mirroring.
 */
var IfcPlacement = 1421;
/**
 * A planar box specifies an arbitrary rectangular box and its location in a two dimensional Cartesian coordinate system. If the planar box is used within a three-dimensional coordinate system, it defines the rectangular box within the XY plane.
 */
var IfcPlanarBox = 1422;
/**
 * The planar extent defines the extent along the two axes of the two-dimensional coordinate system, independently of its position. If the planar extent is used within a three-dimensional coordinate system, it defines the extent along the x and y axes.
 */
var IfcPlanarExtent = 1423;
/**
 * The planar surface is an unbounded surface in the direction of x and y. Bounded planar surfaces are defined by using a subtype of IfcBoundedSurface with BasisSurface being a plane.
 */
var IfcPlane = 1424;
/**
 * An IfcPlate is a planar and often flat part with constant thickness. A plate may carry loads between or beyond points of support, or provide stiffening. The location of the plate (being horizontal, vertical or sloped) is not relevant to its definition (in contrary to IfcWall and IfcSlab (as floor slab)).
 */
var IfcPlate = 1425;
/**
 * The standard plate, IfcPlateStandardCase, defines a plate with certain constraints for the provision of material usage, parameters and with certain constraints for the geometric representation. The IfcPlateStandardCase handles all cases of plates, that:
 */
var IfcPlateStandardCase = 1426;
/**
 * The element type IfcPlateType defines commonly shared information for occurrences of plates. The set of shared information may include:
 */
var IfcPlateType = 1427;
/**
 * The IfcPoint is the abstract generalisation of all point representations within a Cartesian coordinate system.
 */
var IfcPoint = 1428;
/**
 * The IfcPointOnCurve is a point defined by a parameter value of its defining curve.
 */
var IfcPointOnCurve = 1429;
/**
 * The IfcPointOnSurface is a point defined by two parameter value of its defining surface.
 */
var IfcPointOnSurface = 1430;
/**
 * The polygonal bounded half space is a special subtype of a half space solid, where the material of the half space used in Boolean expressions is bounded by a polygonal boundary. The base surface of the half space is positioned by its normal relative to the object coordinate system (as defined at the supertype IfcHalfSpaceSolid), and its polygonal (with or without arc segments) boundary is defined in the XY plane of the position coordinate system established by the Position attribute, the subtraction body is extruded perpendicular to the XY plane of the position coordinate system, that is, into the direction of the positive Z axis defined by the Position attribute.
 */
var IfcPolygonalBoundedHalfSpace = 1431;
/**
 * The IfcPolygonalFaceSet is a tessellated face set with all faces being bound by polygons. The planar faces are constructed by implicit polylines defined by three or more Cartesian points. Each planar face is defined by an instance of IfcIndexedPolygonalFace, or in case of faces with inner loops by IfcIndexedPolygonalFaceWithVoids.
 */
var IfcPolygonalFaceSet = 1432;
/**
 * The IfcPolyline is a bounded curve with only linear segments defined by a list of Cartesian points. If the first and the last Cartesian point in the list are identical, then the polyline is a closed curve, otherwise it is an open curve.
 */
var IfcPolyline = 1433;
/**
 *
 */
var IfcPolyLoop = 1434;
/**
 * A port provides the means for an element to connect to other elements.
 */
var IfcPort = 1435;
/**
 * This entity represents an address for delivery of paper based mail and other postal deliveries.
 */
var IfcPostalAddress = 1436;
/**
 * The pre defined colour determines those qualified names which can be used to identify a colour that is in scope of the current data exchange specification (in contrary to colour specification which defines the colour directly by its colour components).
 */
var IfcPreDefinedColour = 1437;
/**
 *
 */
var IfcPreDefinedCurveFont = 1438;
/**
 * A pre defined item is a qualified name given to a style or font which is determined within the data exchange specification by convention on using the Name attribute value (in contrary to externally defined items, which are agreed by an external source).
 */
var IfcPreDefinedItem = 1439;
/**
 * The IfcPreDefinedProperties is an abstract supertype of all predefined property collections that have explicit attributes, each representing a property. Instantiable subtypes are assigned to specific characterised entities.
 */
var IfcPreDefinedProperties = 1440;
/**
 * IfcPreDefinedPropertySet is a generalization of all statically defined property sets that are assigned to an object or type object. The statically or pre-defined property sets are entities with a fixed list of attributes having particular defined data types.
 */
var IfcPreDefinedPropertySet = 1441;
/**
 * The pre defined text font determines those qualified names which can be used for fonts that are in scope of the current data exchange specification (in contrary to externally defined text fonts). There are two choices:
 */
var IfcPreDefinedTextFont = 1442;
/**
 * The IfcPresentationItem is the abstract supertype of all entities used for presentation appearance definitions.
 */
var IfcPresentationItem = 1443;
/**
 * The presentation layer assignment provides the layer name (and optionally a description and an identifier) for a collection of geometric representation items. The IfcPresentationLayerAssignment corresponds to the term "CAD Layer" and is used mainly for grouping and visibility control.
 */
var IfcPresentationLayerAssignment = 1444;
/**
 * An IfcPresentationLayerAssignmentWithStyle extends the presentation layer assignment with capabilities to define visibility control, access control and kdtree3 style information.
 */
var IfcPresentationLayerWithStyle = 1445;
/**
 * The IfcPresentationStyle is an abstract generalization of style table for presentation information assigned to geometric representation items. It includes styles for curves, areas, surfaces, and text. Style information may include colour, hatching, rendering, and text fonts.
 */
var IfcPresentationStyle = 1446;
/**
 * Assignment of style information to a styled item.
 */
var IfcPresentationStyleAssignment = 1447;
/**
 * An IfcProcedure is a logical set of actions to be taken in response to an event or to cause an event to occur.
 */
var IfcProcedure = 1448;
/**
 * An IfcProcedureType defines a particular type of procedure that may be specified.
 */
var IfcProcedureType = 1449;
/**
 * IfcProcess is defined as one individual activity or event, that is ordered in time, that has sequence relationships with other processes, which transforms input in output, and may connect to other other processes through input output relationships. An IfcProcess can be an activity (or task), or an event. It takes usually place in building construction with the intent of designing, costing, acquiring, constructing, or maintaining products or other and similar tasks or procedures. Figure 131 illustrates process relationships.
 */
var IfcProcess = 1450;
/**
 * The IfcProduct is an abstract representation of any object that relates to a geometric or spatial context. An IfcProduct occurs at a specific location in space if it has a geometric representation assigned. It can be placed relatively to other products, but ultimately relative to the project coordinate system. The ObjectPlacement attribute establishes the coordinate system in which all points and directions used by the geometric representation items under Representation are founded. The Representation is provided by an IfcProductDefinitionShape being either a geometric shape representation, or a topology representation (with or without underlying geometry of the topological items).
 */
var IfcProduct = 1451;
/**
 * The IfcProductDefinitionShape defines all shape relevant information about an IfcProduct. It allows for multiple geometric shape representations of the same product. The shape relevant information includes:
 */
var IfcProductDefinitionShape = 1452;
/**
 * IfcProductRepresentation defines a representation of a product, including its (geometric or topological) representation. A product can have zero, one or many geometric representations, and a single geometric representation can be shared among various products using mapped representations.
 */
var IfcProductRepresentation = 1453;
/**
 * IfcProfileDef is the supertype of all definitions of standard and arbitrary profiles within IFC. It is used to define a standard set of commonly used section profiles by their parameters or by their explicit curve geometry.
 */
var IfcProfileDef = 1454;
/**
 * This is a collection of properties applicable to section profile definitions.
 */
var IfcProfileProperties = 1455;
/**
 * IfcProject indicates the undertaking of some design, engineering, construction, or maintenance activities leading towards a product. The project establishes the context for information to be exchanged or shared, and it may represent a construction project but does not have to. The IfcProject's main purpose in an exchange structure is to provide the root instance and the context for all other information items included.
 */
var IfcProject = 1456;
/**
 * IfcProjectedCRS is a coordinate reference system of the map to which the map translation of the local engineering coordinate system of the construction or facility engineering project relates. The MapProjection and MapZone attributes uniquely identify the projection to the underlying geographic coordinate reference system, provided that they are well-known in the receiving application. The projected coordinate reference system is assumed to be a 2D or 3D right-handed Cartesian coordinate system, the optional MapUnit attribute can be used determine the length unit used by the map.
 */
var IfcProjectedCRS = 1457;
/**
 * The projection element is a specialization of the general feature element to represent projections applied to building elements. It represents a solid attached to any element that has physical manifestation.
 */
var IfcProjectionElement = 1458;
/**
 * An IfcProjectLibrary collects all library elements that are included within a referenced project data set.
 */
var IfcProjectLibrary = 1459;
/**
 * A project order is a directive to purchase products and/or perform work, such as for construction or facilities management.
 */
var IfcProjectOrder = 1460;
/**
 * IfcProperty is an abstract generalization for all types of properties that can be associated with IFC objects through the property set mechanism.
 */
var IfcProperty = 1461;
/**
 * The IfcPropertyAbstraction is an abstract supertype of all property related entities defined as dependent resource entities within the specification. It may have an external reference to a dictionary or library that provides additional information about its definition. Instantiable subtypes have property name, value and other instance information.
 */
var IfcPropertyAbstraction = 1462;
/**
 * A property with a bounded value, IfcPropertyBoundedValue, defines a property object which has a maximum of two (numeric or descriptive) values assigned, the first value specifying the upper bound and the second value specifying the lower bound. It defines a property - value bound (min-max) combination for which the property Name, an optional Description, the optional UpperBoundValue with measure type, the optional LowerBoundValue with measure type, and the optional Unit is given. A set point value can be provided in addition to the upper and lower bound values for operational value setting.
 */
var IfcPropertyBoundedValue = 1463;
/**
 * IfcPropertyDefinition defines the generalization of all characteristics (i.e. a grouping of individual properties), that may be assigned to objects. Currently, subtypes of IfcPropertyDefinition include property set occurrences, property set templates, and property templates.
 */
var IfcPropertyDefinition = 1464;
/**
 * An IfcPropertyDependencyRelationship describes an identified dependency between the value of one property and that of another.
 */
var IfcPropertyDependencyRelationship = 1465;
/**
 * A property with an enumerated value, IfcPropertyEnumeratedValue, defines a property object which has a value assigned that is chosen from an enumeration. It defines a property - value combination for which the property Name, an optional Description, the optional EnumerationValues with measure type and optionally an Unit is given.
 */
var IfcPropertyEnumeratedValue = 1466;
/**
 * IfcPropertyEnumeration is a collection of simple or measure values that define a prescribed set of alternatives from which 'enumeration values' are selected. This enables inclusion of enumeration values in property sets. IfcPropertyEnumeration provides a name for the enumeration as well as a list of unique (numeric or descriptive) values (that may have a measure type assigned). The entity defines the list of potential enumerators to be exchanged together (or separately) with properties of type IfcPropertyEnumeratedValue that selects their actual property values from this enumeration.
 */
var IfcPropertyEnumeration = 1467;
/**
 * An IfcPropertyListValue defines a property that has several (numeric or descriptive) values assigned, these values are given by an ordered list. It defines a property - list value combination for which the property Name, an optional Description, the optional ListValues with measure type and optionally an Unit is given. An IfcPropertyListValue is a list of values. The order in which values appear is significant. All list members shall be of the same type.
 */
var IfcPropertyListValue = 1468;
/**
 * The IfcPropertyReferenceValue allows a property value to be of type of an resource level entity. The applicable entities that can be used as value references are given by the IfcObjectReferenceSelect.
 */
var IfcPropertyReferenceValue = 1469;
/**
 * The IfcPropertySet is a container that holds properties within a property tree. These properties are interpreted according to their name attribute. Each individual property has a significant name string. Some property sets are included in the specification of this standard and have a predefined set of properties indicated by assigning a significant name. These property sets are listed under "property sets" within this specification. Property sets applicable to certain objects are listed in the object specification. The naming convention "Pset_Xxx" applies to all those property sets that are defined as part of this specification and it shall be used as the value of the Name attribute.
 */
var IfcPropertySet = 1470;
/**
 * IfcPropertySetDefinition is a generalization of all individual property sets that can be assigned to an object or type object. The property set definition can be either:
 */
var IfcPropertySetDefinition = 1471;
/**
 * IfcPropertySetTemplate defines the template for all dynamically extensible property sets represented by IfcPropertySet. The property set template is a container of property templates within a property tree. The individual property templates are interpreted according to their Name attribute and shall have no values assigned.
 */
var IfcPropertySetTemplate = 1472;
/**
 * The property with a single value IfcPropertySingleValue defines a property object which has a single (numeric or descriptive) value assigned. It defines a property - single value combination for which the property Name, an optional Description, and an optional NominalValue with measure type is provided. In addition, the default unit as specified within the project unit context can be overriden by assigning an Unit.
 */
var IfcPropertySingleValue = 1473;
/**
 * IfcPropertyTableValue is a property with a value range defined by a property object which has two lists of (numeric or descriptive) values assigned. The values specify a table with two columns. The defining values provide the first column and establish the scope for the defined values (the second column). An optional Expression attribute may give the equation used for deriving the range value, which is for information purposes only.
 */
var IfcPropertyTableValue = 1474;
/**
 * The IfcPropertyTemplate is an abstract supertype comprising the templates for all dynamically extensible properties, either as an IfcComplexPropertyTemplate, or an IfcSimplePropertyTemplate. These templates determine the structure of:
 */
var IfcPropertyTemplate = 1475;
/**
 * IfcPropertyTemplateDefinition is a generalization of all property and property set templates. Templates define the collection, types, names, applicable measure types and units of individual properties used in a project. The property template definition can be either:
 */
var IfcPropertyTemplateDefinition = 1476;
/**
 * A protective device breaks an electrical circuit when a stated electric current that passes through it is exceeded.
 */
var IfcProtectiveDevice = 1477;
/**
 * A protective device tripping unit breaks an electrical circuit at a separate breaking unit when a stated electric current that passes through the unit is exceeded.
 */
var IfcProtectiveDeviceTrippingUnit = 1478;
/**
 * The distribution control element type IfcProtectiveDeviceTrippingUnitType defines commonly shared information for occurrences of protective device tripping units. The set of shared information may include:
 */
var IfcProtectiveDeviceTrippingUnitType = 1479;
/**
 * The flow controller type IfcProtectiveDeviceType defines commonly shared information for occurrences of protective devices. The set of shared information may include:
 */
var IfcProtectiveDeviceType = 1480;
/**
 * IfcProxy is intended to be a kind of a container for wrapping objects which are defined by associated properties, which may or may not have a geometric representation and placement in space. A proxy may have a semantic meaning, defined by the Name attribute, and property definitions, attached through the property assignment relationship, which definition may be outside of the definitions given by the current release of IFC.
 */
var IfcProxy = 1481;
/**
 * A pump is a device which imparts mechanical work on fluids or slurries to move them through a channel or pipeline. A typical use of a pump is to circulate chilled water or heating hot water in a building services distribution system.
 */
var IfcPump = 1482;
/**
 * The flow moving device type IfcPumpType defines commonly shared information for occurrences of pumps. The set of shared information may include:
 */
var IfcPumpType = 1483;
/**
 * IfcQuantityArea is a physical quantity that defines a derived area measure to provide an element's physical property. It is normally derived from the physical properties of the element under the specific measure rules given by a method of measurement.
 */
var IfcQuantityArea = 1484;
/**
 * IfcQuantityCount is a physical quantity that defines a derived count measure to provide an element's physical property. It is normally derived from the physical properties of the element under the specific measure rules given by a method of measurement.
 */
var IfcQuantityCount = 1485;
/**
 * IfcQuantityLength is a physical quantity that defines a derived length measure to provide an element's physical property. It is normally derived from the physical properties of the element under the specific measure rules given by a method of measurement.
 */
var IfcQuantityLength = 1486;
/**
 * IfcQuantitySet is the the abstract supertype for all quantity sets attached to objects. The quantity set is a container class that holds the individual quantities within a quantity tree. These quantities are interpreted according to their name attribute and classified according to their measure type. Some quantity sets are included in the IFC specification and have a predefined set of quantities indicated by assigning a significant name. These quantity sets are listed as "quantity sets" within this specification. Quantity sets applicable to certain objects are listed in the object specification.
 */
var IfcQuantitySet = 1487;
/**
 * IfcQuantityTime is an element quantity that defines a time measure to provide a property of time related to an element. It is normally given by the recipe information of the element under the specific measure rules given by a method of measurement.
 */
var IfcQuantityTime = 1488;
/**
 * IfcQuantityVolume is a physical quantity that defines a derived volume measure to provide an element's physical property. It is normally derived from the physical properties of the element under the specific measure rules given by a method of measurement.
 */
var IfcQuantityVolume = 1489;
/**
 * IfcQuantityWeight is a physical element quantity that defines a derived weight measure to provide an element's physical property. It is normally derived from the physical properties of the element under the specific measure rules given by a method of measurement.
 */
var IfcQuantityWeight = 1490;
/**
 * The railing is a frame assembly adjacent to human or vehicle circulation spaces and at some space boundaries where it is used in lieu of walls or to complement walls. Designed as an optional physical support, or to prevent injury or damage, either by falling or collision.
 */
var IfcRailing = 1491;
/**
 * The building element type IfcRailingType defines commonly shared information for occurrences of railings. The set of shared information may include:
 */
var IfcRailingType = 1492;
/**
 * A ramp is a vertical passageway which provides a human or vehicle circulation link between one floor level and another floor level at a different elevation. It may include a landing as an intermediate floor slab. A ramp normally does not include steps.
 */
var IfcRamp = 1493;
/**
 * A ramp comprises a single inclined segment, or several inclined segments that are connected by a horizontal segment, refered to as a landing. A ramp flight is the single inclined segment and part of the ramp construction. In case of single flight ramps, the ramp flight and the ramp are identical.
 */
var IfcRampFlight = 1494;
/**
 * The building element type IfcRampFlightType defines commonly shared information for occurrences of ramp flights. The set of shared information may include:
 */
var IfcRampFlightType = 1495;
/**
 * The building element type IfcRampType defines commonly shared information for occurrences of ramps. The set of shared information may include:
 */
var IfcRampType = 1496;
/**
 * A rational B-spline curve with knots is a B-spline curve described in terms of control points and basic functions. It describes weights in addition to the control points defined at the supertype IfcBSplineCurve.
 */
var IfcRationalBSplineCurveWithKnots = 1497;
/**
 * A rational B-spline surface with knots is a piecewise parametric rational surface described in terms of control points, and associated weight values.
 */
var IfcRationalBSplineSurfaceWithKnots = 1498;
/**
 * IfcRectangleHollowProfileDef defines a section profile that provides the defining parameters of a rectangular (or square) hollow section to be used by the swept surface geometry or the swept area solid. Its parameters and orientation relative to the position coordinate system are according to the following illustration. A square hollow section can be defined by equal values for h and b. The centre of the position coordinate system is in the profiles centre of the bounding box (for symmetric profiles identical with the centre of gravity). Normally, the longer sides are parallel to the y-axis, the shorter sides parallel to the x-axis.
 */
var IfcRectangleHollowProfileDef = 1499;
/**
 * IfcRectangleProfileDef defines a rectangle as the profile definition used by the swept surface geometry or the swept area solid. It is given by its X extent and its Y extent, and placed within the 2D position coordinate system, established by the Position attribute. It is placed centric within the position coordinate system.
 */
var IfcRectangleProfileDef = 1500;
/**
 * The IfcRectangularPyramid is a Construction Solid Geometry (CSG) 3D primitive. It is a solid with a rectangular base and a point called apex as the top. The tapers from the base to the top. The axis from the center of the base to the apex is perpendicular to the base. The inherited Position attribute defines the IfcAxisPlacement3D and provides the location and orientation of the pyramid:
 */
var IfcRectangularPyramid = 1501;
/**
 * The IfcRectangularTrimmedSurface is a surface created by bounding its BasisSurface along two pairs of parallel curves defined within the parametric space of the referenced surface.
 */
var IfcRectangularTrimmedSurface = 1502;
/**
 * IfcRecurrencePattern defines repetitive time periods on the basis of regular recurrences such as each Monday in a week, or every third Tuesday in a month. The population of the remaining attributes such as DayComponent, Position, and Interval depend on the specified recurrence type.
 */
var IfcRecurrencePattern = 1503;
/**
 * This entity is used to refer to a value of an attribute on an instance. It may refer to the value of a scalar attribute or a value within a collection-based attribute. Referenced attributes may be direct values, object references, collections, inverse object references, and inverse collections. References may be chained to form a path of object-attribute references.
 */
var IfcReference = 1504;
/**
 * In a regular time series, the data arrives predictably at predefined intervals. In a regular time series there is no need to store multiple time stamps and the algorithms for analyzing the time series are therefore significantly simpler. Using the start time provided in the supertype, the time step is used to identify the frequency of the occurrences of the list of values.
 */
var IfcRegularTimeSeries = 1505;
/**
 * IfcReinforcementProperties defines the set of properties for a specific combination of reinforcement bar steel grade, bar type and effective depth.
 */
var IfcReinforcementBarProperties = 1506;
/**
 * IfcReinforcementDefinitionProperties defines the cross section properties of reinforcement included in reinforced concrete building elements. The property set definition may be used both in conjunction with insitu and precast structures.
 */
var IfcReinforcementDefinitionProperties = 1507;
/**
 * A reinforcing bar is usually made of steel with manufactured deformations in the surface, and used in concrete and masonry construction to provide additional strength. A single instance of this class may represent one or many of actual rebars, for example a row of rebars.
 */
var IfcReinforcingBar = 1508;
/**
 * The reinforcing element type IfcReinforcingBarType defines commonly shared information for occurrences of reinforcing bars. The set of shared information may include:
 */
var IfcReinforcingBarType = 1509;
/**
 * A reinforcing element represents bars, wires, strands, meshes, tendons, and other components embedded in concrete in such a manner that the reinforcement and the concrete act together in resisting forces.
 */
var IfcReinforcingElement = 1510;
/**
 * The element component type IfcReinforcingElementType defines commonly shared information for occurrences of reinforcing elements. The set of shared information may include:
 */
var IfcReinforcingElementType = 1511;
/**
 * A reinforcing mesh is a series of longitudinal and transverse wires or bars of various gauges, arranged at right angles to each other and welded at all points of intersection; usually used for concrete slab reinforcement. It is also known as welded wire fabric. In scope are plane meshes as well as bent meshes.
 */
var IfcReinforcingMesh = 1512;
/**
 * The reinforcing element type IfcReinforcingMeshType defines commonly shared information for occurrences of reinforcing meshs. The set of shared information may include:
 */
var IfcReinforcingMeshType = 1513;
/**
 * The aggregation relationship IfcRelAggregates is a special type of the general composition/decomposition (or whole/part) relationship IfcRelDecomposes. The aggregation relationship can be applied to all subtypes of IfcObjectDefinition.
 */
var IfcRelAggregates = 1514;
/**
 * The assignment relationship, IfcRelAssigns, is a generalization of "link" relationships among instances of IfcObject and its various 1st level subtypes. A link denotes the specific association through which one object (the client) applies the services of other objects (the suppliers), or through which one object may navigate to other objects.
 */
var IfcRelAssigns = 1515;
/**
 * The objectified relationship IfcRelAssignsToActor handles the assignment of objects (subtypes of IfcObject) to an actor (subtypes of IfcActor).
 */
var IfcRelAssignsToActor = 1516;
/**
 * The objectified relationship IfcRelAssignsToControl handles the assignment of a control (represented by subtypes of IfcControl) to other objects (represented by subtypes of IfcObject, with the exception of controls).
 */
var IfcRelAssignsToControl = 1517;
/**
 * The objectified relationship IfcRelAssignsToGroup handles the assignment of object definitions (individual object occurrences as subtypes of IfcObject, and object types as subtypes of IfcTypeObject) to a group (subtypes of IfcGroup).
 */
var IfcRelAssignsToGroup = 1518;
/**
 * The objectified relationship IfcRelAssignsToGroupByFactor is a specialization of the general grouping mechanism. It allows to add a factor to define the ratio that applies to the assignment of object definitions (individual object occurrences as subtypes of IfcObject and object types as subtypes of IfcTypeObject) to a group (subtypes of IfcGroup).
 */
var IfcRelAssignsToGroupByFactor = 1519;
/**
 * The objectified relationship IfcRelAssignsToProcess handles the assignment of one or many objects to a process or activity. An object can be a product that is the item the process operates on. Processes and activities can operate on things other than products, and can operate in ways other than input and output.
 */
var IfcRelAssignsToProcess = 1520;
/**
 * The objectified relationship IfcRelAssignsToProduct handles the assignment of objects (subtypes of IfcObject) to a product (subtypes of IfcProduct). The Name attribute should be used to classify the usage of the IfcRelAssignsToProduct objectified relationship. The following Name values are proposed:
 */
var IfcRelAssignsToProduct = 1521;
/**
 * The objectified relationship IfcRelAssignsToResource handles the assignment of objects (as subtypes of IfcObject), acting as a resource usage or consumption, to a resource (as subtypes of IfcResource).
 */
var IfcRelAssignsToResource = 1522;
/**
 * The association relationship IfcRelAssociates refers to sources of information (most notably a classification, library, document, approval, contraint, or material). The information associated may reside internally or externally of the project data. There is no dependency implied by the association.
 */
var IfcRelAssociates = 1523;
/**
 * The entity IfcRelAssociatesApproval is used to apply approval information defined by IfcApproval, in IfcApprovalResource schema, to subtypes of IfcRoot.
 */
var IfcRelAssociatesApproval = 1524;
/**
 * The objectified relationship IfcRelAssociatesClassification handles the assignment of a classification item (items of the select IfcClassificationSelect) to objects occurrences (subtypes of IfcObject) or object types (subtypes of IfcTypeObject).
 */
var IfcRelAssociatesClassification = 1525;
/**
 * The entity IfcRelAssociatesConstraint is used to apply constraint information defined by IfcConstraint, in the IfcConstraintResource schema, to subtypes of IfcRoot.
 */
var IfcRelAssociatesConstraint = 1526;
/**
 * The objectified relationship (IfcRelAssociatesDocument) handles the assignment of a document information (items of the select IfcDocumentSelect) to objects occurrences (subtypes of IfcObject) or object types (subtypes of IfcTypeObject).
 */
var IfcRelAssociatesDocument = 1527;
/**
 * The objectified relationship (IfcRelAssociatesLibrary) handles the assignment of a library item (items of the select IfcLibrarySelect) to subtypes of IfcObjectDefinition or IfcPropertyDefinition.
 */
var IfcRelAssociatesLibrary = 1528;
/**
 * IfcRelAssociatesMaterial is an objectified relationship between a material definition and elements or element types to which this material definition applies.
 */
var IfcRelAssociatesMaterial = 1529;
/**
 * IfcRelationship is the abstract generalization of all objectified relationships in IFC. Objectified relationships are the preferred way to handle relationships among objects. This allows to keep relationship specific properties directly at the relationship and opens the possibility to later handle relationship specific behavior.
 */
var IfcRelationship = 1530;
/**
 * IfcRelConnects is a connectivity relationship that connects objects under some criteria. As a general connectivity it does not imply constraints, however subtypes of the relationship define the applicable object types for the connectivity relationship and the semantics of the particular connectivity.
 */
var IfcRelConnects = 1531;
/**
 * The IfcRelConnectsElements objectified relationship provides the generalization of the connectivity between elements. It is a 1 to 1 relationship. The concept of two elements being physically or logically connected is described independently from the connecting elements. The connectivity may be related to the shape representation of the connected entities by providing a connection geometry.
 */
var IfcRelConnectsElements = 1532;
/**
 * The IfcRelConnectsPathElements relationship provides the connectivity information between two elements, which have path information.
 */
var IfcRelConnectsPathElements = 1533;
/**
 * An IfcRelConnectsPorts relationship defines the relationship that is made between two ports at their point of connection. It may include the connection geometry between two ports.
 */
var IfcRelConnectsPorts = 1534;
/**
 * IfcRelConnectsPortToElement is a relationship between a distribution element and dynamically connected ports where connections are realised to other distribution elements.
 */
var IfcRelConnectsPortToElement = 1535;
/**
 * The IfcRelConnectsStructuralActivity relationship connects a structural activity (either an action or reaction) to a structural member, structural connection, or element.
 */
var IfcRelConnectsStructuralActivity = 1536;
/**
 * The entity IfcRelConnectsStructuralMember defines all needed properties describing the connection between structural members and structural connection objects (nodes or supports).
 */
var IfcRelConnectsStructuralMember = 1537;
/**
 * The entity IfcRelConnectsWithEccentricity adds the definition of eccentricity to the connection between a structural member and a structural connection (representing either a node or support).
 */
var IfcRelConnectsWithEccentricity = 1538;
/**
 * IfcRelConnectsWithRealizingElements defines a generic relationship that is made between two elements that require the realization of that relationship by means of further realizing elements.
 */
var IfcRelConnectsWithRealizingElements = 1539;
/**
 * This objectified relationship, IfcRelContainedInSpatialStructure, is used to assign elements to a certain level of the spatial project structure. Any element can only be assigned once to a certain level of the spatial structure. The question, which level is relevant for which type of element, can only be answered within the context of a particular project and might vary within the various regions.
 */
var IfcRelContainedInSpatialStructure = 1540;
/**
 * The IfcRelCoversBldgElements relationship is an objectified relationship between an element and one to many coverings, which cover that element.
 */
var IfcRelCoversBldgElements = 1541;
/**
 * The objectified relationship, IfcRelCoversSpace, relates a space object to one or many coverings, which faces (or is assigned to) the space.
 */
var IfcRelCoversSpaces = 1542;
/**
 * The objectified relationship IfcRelDeclares handles the declaration of objects (subtypes of IfcObject) or properties (subtypes of IfcPropertyDefinition) to a project or project library (represented by IfcProject, or IfcProjectLibrary).
 */
var IfcRelDeclares = 1543;
/**
 * The decomposition relationship, IfcRelDecomposes, defines the general concept of elements being composed or decomposed. The decomposition relationship denotes a whole/part hierarchy with the ability to navigate from the whole (the composition) to the parts and vice versa.
 */
var IfcRelDecomposes = 1544;
/**
 * A generic and abstract relationship which subtypes are used to:
 */
var IfcRelDefines = 1545;
/**
 * The objectified relationship IfcRelDefinesByObject defines the relationship between an object taking part in an object type decomposition and an object occurrences taking part in an occurrence decomposition of that type.
 */
var IfcRelDefinesByObject = 1546;
/**
 * The objectified relationship IfcRelDefinesByProperties defines the relationships between property set definitions and objects. Properties are aggregated in property sets. Property sets can be either directly assigned to occurrence objects using this relationship, or assigned to an object type and assigned via that type to occurrence objects. The assignment of an IfcPropertySet to an IfcTypeObject is not handled via this objectified relationship, but through the direct relationship HasPropertySets at IfcTypeObject.
 */
var IfcRelDefinesByProperties = 1547;
/**
 * The objectified relationship IfcRelDefinesByTemplate defines the relationships between property set template and property sets. Common information about property sets, e.g. the applicable name, description, contained properties, is defined by the property set template and assigned to all property sets.
 */
var IfcRelDefinesByTemplate = 1548;
/**
 * The objectified relationship IfcRelDefinesByType defines the relationship between an object type and object occurrences. The IfcRelDefinesByType is a 1-to-N relationship, as it allows for the assignment of one type information to a single or to many objects. Those objects then share the same object type, and the property sets and properties assigned to the object type.
 */
var IfcRelDefinesByType = 1549;
/**
 * IfcRelFillsElement is an objectified relationship between an opening element and an element that fills (or partially fills) the opening element. It is an one-to-one relationship.
 */
var IfcRelFillsElement = 1550;
/**
 * This objectified relationship between a distribution flow element occurrence and one-to-many control element occurrences indicates that the control element(s) sense or control some aspect of the flow element. It is applied to IfcDistributionFlowElement and IfcDistributionControlElement.
 */
var IfcRelFlowControlElements = 1551;
/**
 * The IfcRelInterferesElements objectified relationship indicates that two elements interfere. Interference is a spatial overlap between the two elements. It is a 1 to 1 relationship. The concept of two elements interfering physically or logically is described independently from the elements. The interference may be related to the shape representation of the entities by providing an interference geometry.
 */
var IfcRelInterferesElements = 1552;
/**
 * The nesting relationship IfcRelNests is a special type of the general composition/decomposition (or whole/part) relationship IfcRelDecomposes. The nesting relationship can be applied to all non physical subtypes of object and object types, namely processes, controls (like cost items), and resources. It can also be applied to physical subtypes of object and object types, namely elements having ports. The nesting implies an order among the nested parts.
 */
var IfcRelNests = 1553;
/**
 * The IfcRelProjectsElement is an objectified relationship between an element and one projection element that creates a modifier to the shape of the element. The relationship is defined to be a 1:1 relationship, if an element has more than one projection, several relationship objects have to be used, each pointing to a different projection element. The IfcRelProjectsElement establishes an aggregation relationship between the main element and a sub ordinary addition feature.
 */
var IfcRelProjectsElement = 1554;
/**
 * The objectified relationship, IfcRelReferencedInSpatialStructure is used to assign elements in addition to those levels of the project spatial\S\ structure, in which they are referenced, but not primarily contained. It is also used to connect a system to the relevant spatial element that it serves.
 */
var IfcRelReferencedInSpatialStructure = 1555;
/**
 * IfcRelSequence is a sequential relationship between processes where one process must occur before the other in time and where the timing of the relationship may be described as a type of sequence. The relating process (IfcRelSequence.RelatingProcess) is considered to be the predecessor in the relationship (has precedence) whilst the related process (IfcRelSequence.RelatedProcess) is the successor.
 */
var IfcRelSequence = 1556;
/**
 * The IfcRelServicesBuildings is an objectified relationship that defines the relationship between a system and the sites, buildings, storeys, spaces, or spatial zones, it serves. Examples of systems are:
 */
var IfcRelServicesBuildings = 1557;
/**
 * The space boundary defines the physical or virtual delimiter of a space by the relationship IfcRelSpaceBoundary to the surrounding elements.
 */
var IfcRelSpaceBoundary = 1558;
/**
 * The 1st level space boundary defines the physical or virtual delimiter of a space by the relationship IfcRelSpaceBoundary1stLevel to the surrounding elements. 1st level space boundaries are characterizeda by:
 */
var IfcRelSpaceBoundary1stLevel = 1559;
/**
 * The 2nd level space boundary defines the physical or virtual delimiter of a space by the relationship IfcRelSpaceBoundary2ndLevel to the surrounding elements. 2nd level space boundaries are characterized by:
 */
var IfcRelSpaceBoundary2ndLevel = 1560;
/**
 * IfcRelVoidsElement is an objectified relationship between a building element and one opening element that creates a void in the element. It is a one-to-one relationship. This relationship implies a Boolean operation of subtraction between the geometric bodies of the element and the opening.
 */
var IfcRelVoidsElement = 1561;
/**
 * The IfcReparametrisedCompositeCurveSegment is geometrically identical to a IfcCompositeCurveSegment but with the additional capability of reparametrization.
 */
var IfcReparametrisedCompositeCurveSegment = 1562;
/**
 * The IfcRepresentation defines the general concept of representing product properties and in particular the product shape.
 */
var IfcRepresentation = 1563;
/**
 * The IfcRepresentationContext defines the context to which the IfcRepresentation of a product is related.
 */
var IfcRepresentationContext = 1564;
/**
 * The IfcRepresentationItem is used within an IfcRepresentation (directly or indirectly through other IfcRepresentationItem's) to represent an IfcProductRepresentation. Most commonly these IfcRepresentationItem's are geometric or topological representation items, that can (but not need to) have presentation style infomation assigned.
 */
var IfcRepresentationItem = 1565;
/**
 * An IfcRepresentationMap defines the base definition (also referred to as block, cell or macro) called MappedRepresentation within the MappingOrigin. The MappingOrigin defines the coordinate system in which the MappedRepresentation is defined.
 */
var IfcRepresentationMap = 1566;
/**
 * IfcResource contains the information needed to represent the costs, schedule, and other impacts from the use of a thing in a process. It is not intended to use IfcResource to model the general properties of the things themselves, while an optional linkage from IfcResource to the things to be used can be specified (specifically, the relationship from subtypes of IfcResource to IfcProduct through the IfcRelAssignsToResource relationship).
 */
var IfcResource = 1567;
/**
 * An IfcResourceApprovalRelationship is used for associating an approval to resource objects. A single approval might be given to one or many items via IfcResourceObjectSelect.
 */
var IfcResourceApprovalRelationship = 1568;
/**
 * An IfcResourceConstraintRelationship is a relationship entity that enables a constraint to be related to one or more resource level objects.
 */
var IfcResourceConstraintRelationship = 1569;
/**
 * IfcResourceLevelRelationship is an abstract base entity for relationships between resource-level entities.
 */
var IfcResourceLevelRelationship = 1570;
/**
 * IfcResourceTime captures the time-related information about a construction resource.
 */
var IfcResourceTime = 1571;
/**
 * An IfcRevolvedAreaSolid is a solid created by revolving a cross section provided by a profile definition about an axis.
 */
var IfcRevolvedAreaSolid = 1572;
/**
 * IfcRevolvedAreaSolidTapered is defined by revolving a cross section along a circular arc. The cross section may change along the revolving sweep from the shape of the start cross section into the shape of the end cross section. Corresponding vertices of the start and end cross sections are then connected. The bounded surface may have holes which will sweep into holes in the solid.
 */
var IfcRevolvedAreaSolidTapered = 1573;
/**
 * The IfcRightCircularCone is a Construction Solid Geometry (CSG) 3D primitive. It is a solid with a circular base and a point called apex as the top. The tapers from the base to the top. The axis from the center of the circular base to the apex is perpendicular to the base. The inherited Position attribute defines the IfcAxisPlacement3D and provides the location and orientation of the cone:
 */
var IfcRightCircularCone = 1574;
/**
 * The IfcRightCircularCylinder is a Construction Solid Geometry (CSG) 3D primitive. It is a solid with a circular base and top. The cylindrical surface between if formed by points at a fixed distance from the axis of the cylinder. The inherited Position attribute defines the IfcAxisPlacement3D and provides:
 */
var IfcRightCircularCylinder = 1575;
/**
 * A roof is the covering of the top part of a building, it protects the building against the effects of wheather.
 */
var IfcRoof = 1576;
/**
 * The building element type IfcRoofType defines commonly shared information for occurrences of roofs. The set of shared information may include:
 */
var IfcRoofType = 1577;
/**
 * IfcRoot is the most abstract and root class for all entity definitions that roots in the kernel or in subsequent layers of the IFC specification. It is therefore the kdtree3 supertype of all IFC entities, beside those defined in an IFC resource schema. All entities that are subtypes of IfcRoot can be used independently, whereas resource schema entities, that are not subtypes of IfcRoot, are not supposed to be independent entities.
 */
var IfcRoot = 1578;
/**
 * IfcRoundedRectangleProfileDef defines a rectangle with equally rounded corners as the profile definition used by the swept surface geometry or the swept area solid. It is given by the X extent, the Y extent, and the radius for the rounded corners, and placed within the 2D position coordinate system, established by the Position attribute. It is placed centric within the position coordinate system, that is, in the center of the bounding box.
 */
var IfcRoundedRectangleProfileDef = 1579;
/**
 * A sanitary terminal is a fixed appliance or terminal usually supplied with water and used for drinking, cleaning or foul water disposal or that is an item of equipment directly used with such an appliance or terminal.
 */
var IfcSanitaryTerminal = 1580;
/**
 * The flow terminal type IfcSanitaryTerminalType defines commonly shared information for occurrences of sanitary terminals. The set of shared information may include:
 */
var IfcSanitaryTerminalType = 1581;
/**
 * IfcSchedulingTime is the abstract supertype of entities that capture time-related information of processes.
 */
var IfcSchedulingTime = 1582;
/**
 * An IfcSeamCurve is a 3-dimensional curve that has additional representations provided by exactly two distinct pcurves describing the same curve at the two extreme ends of a closed parametric surface.
 */
var IfcSeamCurve = 1583;
/**
 * An IfcSectionedSpine is a representation of the shape of a three dimensional object composed by a number of planar cross sections, and a spine curve. The shape is defined between the first element of cross sections and the last element of the cross sections. A sectioned spine may be used to represent a surface or a solid but the interpolation of the shape between the cross sections is not defined.
 */
var IfcSectionedSpine = 1584;
/**
 * IfcSectionProperties defines the cross section properties for a single longitudinal piece of a cross section. It is a special-purpose helper class for IfcSectionReinforcementProperties.
 */
var IfcSectionProperties = 1585;
/**
 * IfcSectionReinforcementProperties defines the cross section properties of reinforcement for a single longitudinal piece of a cross section with a specific reinforcement usage type.
 */
var IfcSectionReinforcementProperties = 1586;
/**
 * A sensor is a device that measures a physical quantity and converts it into a signal which can be read by an observer or by an instrument.
 */
var IfcSensor = 1587;
/**
 * The distribution control element type IfcSensorType defines commonly shared information for occurrences of sensors. The set of shared information may include:
 */
var IfcSensorType = 1588;
/**
 * Shading devices are purpose built devices to protect from the sunlight, from natural light, or screening them from view. Shading devices can form part of the facade or can be mounted inside the building, they can be fixed or operable.
 */
var IfcShadingDevice = 1589;
/**
 * The building element type IfcShadingDeviceType defines commonly shared information for occurrences of shading devices. The set of shared information may include:
 */
var IfcShadingDeviceType = 1590;
/**
 * IfcShapeAspect allows for grouping of shape representation items that represent aspects (or components) of the shape of a product. Thereby shape representations of components of the product shape represent a distinctive part to a product that can be explicitly addressed.
 */
var IfcShapeAspect = 1591;
/**
 * IfcShapeModel represents the concept of a particular geometric and/or topological representation of a product's shape or a product component's shape within a representation context. This representation context has to be a geometric representation context (with the exception of topology representations without associated geometry). The two subtypes are IfcShapeRepresentation to cover geometric models that represent a shape, and IfcTopologyRepresentation to cover the conectivity of a product or product component. The topology may or may not have geometry associated.
 */
var IfcShapeModel = 1592;
/**
 * The IfcShapeRepresentation represents the concept of a particular geometric representation of a product or a product component within a specific geometric representation context. The inherited attribute RepresentationType is used to define the geometric model used for the shape representation (e.g. 'SweptSolid', or 'Brep'), the inherited attribute RepresentationIdentifier is used to denote the kind of the representation captured by the IfcShapeRepresentation (e.g. 'Axis', 'Body', etc.).
 */
var IfcShapeRepresentation = 1593;
/**
 * An IfcShellBasedSurfaceModel represents the shape by a set of open or closed shells. The connected faces within the shell have a dimensionality 2 and are placed in a coordinate space of dimensionality 3.
 */
var IfcShellBasedSurfaceModel = 1594;
/**
 * IfcSimpleProperty is a generalization of a single property object. The various subtypes of IfcSimpleProperty establish different ways in which a property value can be set.
 */
var IfcSimpleProperty = 1595;
/**
 * The IfcSimplePropertyTemplate defines the template for all dynamically extensible properties, either the subtypes of IfcSimpleProperty, or the subtypes of IfcPhysicalSimpleQuantity. The individual property templates are interpreted according to their Name attribute and may have a predefined template type, property units, and property measure types. The correct interpretation of the attributes:
 */
var IfcSimplePropertyTemplate = 1596;
/**
 * A site is a defined area of land, possibly covered with water, on which the project construction is to be completed. A site may be used to erect, retrofit or turn down building(s), or for other construction related developments.
 */
var IfcSite = 1597;
/**
 * The IfcSIUnit covers both standard base SI units such as meter and second, and derived SI units such as Pascal, square meter and cubic meter.
 */
var IfcSIUnit = 1598;
/**
 * A slab is a component of the construction that may enclose a space vertically. The slab may provide the lower support (floor) or upper construction (roof slab) in any space in a building.
 */
var IfcSlab = 1599;
/**
 * The IfcSlabElementedCase defines a slab with certain constraints for the provision of its components. The IfcSlabElementedCase handles all cases of slabs, that are decomposed into parts:
 */
var IfcSlabElementedCase = 1600;
/**
 * The standard slab, IfcSlabStandardCase, defines a slab with certain constraints for the provision of material usage, parameters and with certain constraints for the geometric representation. The IfcSlabStandardCase handles all cases of slabs, that:
 */
var IfcSlabStandardCase = 1601;
/**
 * The element type IfcSlabType defines commonly shared information for occurrences of slabs. The set of shared information may include:
 */
var IfcSlabType = 1602;
/**
 * Describes slippage in support conditions or connection conditions. Slippage means that a relative displacement may occur in a support or connection before support or connection reactions are awoken.
 */
var IfcSlippageConnectionCondition = 1603;
/**
 * A solar device converts solar radiation into other energy such as electric current or thermal energy.
 */
var IfcSolarDevice = 1604;
/**
 * The energy conversion device type IfcSolarDeviceType defines commonly shared information for occurrences of solar devices. The set of shared information may include:
 */
var IfcSolarDeviceType = 1605;
/**
 * An IfcSolidModel represents the 3D shape by different types of solid model representations. It is the kdtree3 abstract supertype of Boundary representation, CSG representation, Sweeping representation and other suitable solid representation schemes.
 */
var IfcSolidModel = 1606;
/**
 * A space represents an area or volume bounded actually or theoretically. Spaces are areas or volumes that provide for certain functions within a building.
 */
var IfcSpace = 1607;
/**
 * Space heaters utilize a combination of radiation and/or natural convection using a heating source such as electricity, steam or hot water to heat a limited space or area. Examples of space heaters include radiators, convectors, baseboard and finned-tube heaters.
 */
var IfcSpaceHeater = 1608;
/**
 * The flow terminal type IfcSpaceHeaterType defines commonly shared information for occurrences of space heaters. The set of shared information may include:
 */
var IfcSpaceHeaterType = 1609;
/**
 * A space represents an area or volume bounded actually or theoretically. Spaces are areas or volumes that provide for certain functions within a building.
 */
var IfcSpaceType = 1610;
/**
 * A spatial element is the generalization of all spatial elements that might be used to define a spatial structure or to define spatial zones.
 */
var IfcSpatialElement = 1611;
/**
 * IfcSpatialElementType defines a list of commonly shared property set definitions of a spatial structure element and an optional set of product representations. It is used to define a spatial element specification (the specific element information, that is kdtree3 to all occurrences of that element type).
 */
var IfcSpatialElementType = 1612;
/**
 * A spatial structure element is the generalization of all spatial elements that might be used to define a spatial structure. That spatial structure is often used to provide a project structure to organize a building project.
 */
var IfcSpatialStructureElement = 1613;
/**
 * The element type (IfcSpatialStructureElementType) defines a list of commonly shared property set definitions of a spatial structure element and an optional set of product representations. It is used to define an element specification (i.e. the specific element information, that is kdtree3 to all occurrences of that element type).
 */
var IfcSpatialStructureElementType = 1614;
/**
 * A spatial zone is a non-hierarchical and potentially overlapping decomposition of the project under some functional consideration. A spatial zone might be used to represent a thermal zone, a construction zone, a lighting zone, a usable area zone. A spatial zone might have its independent placement and shape representation.
 */
var IfcSpatialZone = 1615;
/**
 * The IfcSpatialZoneType defines a list of commonly shared property set definitions of a space and an optional set of product representations. It is used to define a space specification (i.e. the specific space information, that is kdtree3 to all occurrences of that space type).
 */
var IfcSpatialZoneType = 1616;
/**
 * The IfcSphere is a Construction Solid Geometry (CSG) 3D primitive. It is a solid where all points at the surface have the same distance from the center point. The inherited Position attribute defines the IfcAxisPlacement3D and provides:
 */
var IfcSphere = 1617;
/**
 * The IfcSphericalSurface is a bounded elementary surface. The inherited Position attribute defines the IfcAxisPlacement3D and provides:
 */
var IfcSphericalSurface = 1618;
/**
 * A stack terminal is placed at the top of a ventilating stack (such as to prevent ingress by birds or rainwater) or rainwater pipe (to act as a collector or hopper for discharge from guttering).
 */
var IfcStackTerminal = 1619;
/**
 * The flow terminal type IfcStackTerminalType defines commonly shared information for occurrences of stack terminals. The set of shared information may include:
 */
var IfcStackTerminalType = 1620;
/**
 * A stair is a vertical passageway allowing occupants to walk (step) from one floor level to another floor level at a different elevation. It may include a landing as an intermediate floor slab.
 */
var IfcStair = 1621;
/**
 * A stair flight is an assembly of building components in a single "run" of stair steps (not interrupted by a landing). The stair steps and any stringers are included in the stair flight. A winder is also regarded a part of a stair flight.
 */
var IfcStairFlight = 1622;
/**
 * The building element type IfcStairFlightType defines commonly shared information for occurrences of stair flights. The set of shared information may include:
 */
var IfcStairFlightType = 1623;
/**
 * The building element type IfcStairType defines commonly shared information for occurrences of stairs. The set of shared information may include:
 */
var IfcStairType = 1624;
/**
 * A structural action is a structural activity that acts upon a structural item or building element.
 */
var IfcStructuralAction = 1625;
/**
 * The abstract entity IfcStructuralActivity combines the definition of actions (such as forces, displacements, etc.) and reactions (support reactions, internal forces, deflections, etc.) which are specified by using the basic load definitions from the IfcStructuralLoadResource.
 */
var IfcStructuralActivity = 1626;
/**
 * The IfcStructuralAnalysisModel is used to assemble all information needed to represent a structural analysis model. It encompasses certain general properties (such as analysis type), references to all contained structural members, structural supports or connections, as well as loads and the respective load results.
 */
var IfcStructuralAnalysisModel = 1627;
/**
 * An IfcStructuralConnection represents a structural connection object (node connection, edge connection, or surface connection) or supports.
 */
var IfcStructuralConnection = 1628;
/**
 * Describe more rarely needed connection properties.
 */
var IfcStructuralConnectionCondition = 1629;
/**
 * A structural curve action defines an action which is distributed over a curve. A curve action may be connected with a curve member or curve connection, or surface member or surface connection.
 */
var IfcStructuralCurveAction = 1630;
/**
 * Instances of IfcStructuralCurveConnection describe edge 'nodes', i.e. edges where two or more surface members are joined, or edge supports. Edge curves may be straight or curved.
 */
var IfcStructuralCurveConnection = 1631;
/**
 * Instances of IfcStructuralCurveMember describe edge members, i.e. structural analysis idealizations of beams, columns, rods etc.. Curve members may be straight or curved.
 */
var IfcStructuralCurveMember = 1632;
/**
 * This entity describes edge members with varying profile properties. Each instance of IfcStructuralCurveMemberVarying is composed of two or more instances of IfcStructuralCurveMember with differing profile properties. These subordinate members relate to the instance of IfcStructuralCurveMemberVarying by IfcRelAggregates.
 */
var IfcStructuralCurveMemberVarying = 1633;
/**
 * This entity defines a reaction which occurs distributed over a curve. A curve reaction may be connected with a curve member or curve connection, or surface member or surface connection.
 */
var IfcStructuralCurveReaction = 1634;
/**
 * The abstract entity IfcStructuralItem is the generalization of structural members and structural connections, that is, analysis idealizations of elements in the building model. It defines the relation between structural members and connections with structural activities (actions and reactions).
 */
var IfcStructuralItem = 1635;
/**
 * This entity defines an action with constant value which is distributed over a curve.
 */
var IfcStructuralLinearAction = 1636;
/**
 * This abstract entity is the supertype of all loads (actions or reactions) or of certain requirements resulting from structural analysis, or certain provisions which influence structural analysis.
 */
var IfcStructuralLoad = 1637;
/**
 * A load case is a load group, commonly used to group loads from the same action source.
 */
var IfcStructuralLoadCase = 1638;
/**
 * This class combines one or more load or result values in a 1- or 2-dimensional configuration.
 */
var IfcStructuralLoadConfiguration = 1639;
/**
 * The entity IfcStructuralLoadGroup is used to structure the physical impacts. By using the grouping features inherited from IfcGroup, instances of IfcStructuralAction (or its subclasses) and of IfcStructuralLoadGroup can be used to define load groups, load cases and load combinations. (See also IfcLoadGroupTypeEnum.)
 */
var IfcStructuralLoadGroup = 1640;
/**
 * An instance of the entity IfcStructuralLoadLinearForce shall be used to define actions on curves.
 */
var IfcStructuralLoadLinearForce = 1641;
/**
 * Abstract superclass of simple load or result classes.
 */
var IfcStructuralLoadOrResult = 1642;
/**
 * An instance of the entity IfcStructuralLoadPlanarForce shall be used to define actions on faces.
 */
var IfcStructuralLoadPlanarForce = 1643;
/**
 * Instances of the entity IfcStructuralLoadSingleDisplacement shall be used to define displacements.
 */
var IfcStructuralLoadSingleDisplacement = 1644;
/**
 * Defines a displacement with warping.
 */
var IfcStructuralLoadSingleDisplacementDistortion = 1645;
/**
 * Instances of the entity IfcStructuralLoadSingleForce shall be used to define the forces and moments of an action operating on a single point.
 */
var IfcStructuralLoadSingleForce = 1646;
/**
 * Instances of the entity IfcStructuralLoadSingleForceWarping, as a subtype of IfcStructuralLoadSingleForce, shall be used to define an action operation on a single point. In addition to forces and moments defined by its supertype a warping moment can be defined.
 */
var IfcStructuralLoadSingleForceWarping = 1647;
/**
 * The abstract entity IfcStructuralLoadStatic is the supertype of all static loads (actions or reactions) which can be defined. Within scope are single i.e. concentrated forces and moments, linear i.e. one-dimensionally distributed forces and moments, planar i.e. two-dimensionally distributed forces, furthermore displacements and temperature loads.
 */
var IfcStructuralLoadStatic = 1648;
/**
 * An instance of the entity IfcStructuralLoadTemperature shall be used to define actions which are caused by a temperature change. As shown in Figure 430, the change of temperature is given with a constant value which is applied to the complete section and values for temperature differences between outer fibres of the section.
 */
var IfcStructuralLoadTemperature = 1649;
/**
 * The abstract entity IfcStructuralMember is the superclass of all structural items which represent the idealized structural behavior of building elements.
 */
var IfcStructuralMember = 1650;
/**
 * This entity defines an action with constant value which is distributed over a surface.
 */
var IfcStructuralPlanarAction = 1651;
/**
 * This entity defines an action which acts on a point. A point action is typically connected with a point connection. It may also be connected with a curve member or curve connection, or surface member or surface connection.
 */
var IfcStructuralPointAction = 1652;
/**
 * Instances of IfcStructuralPointConnection describe structural nodes or point supports.
 */
var IfcStructuralPointConnection = 1653;
/**
 * This entity defines a reaction which occurs at a point. A point reaction is typically connected with a point connection. It may also be connected with a curve member or curve connection, or surface member or surface connection.
 */
var IfcStructuralPointReaction = 1654;
/**
 * A structural reaction is a structural activity that results from a structural action imposed to a structural item or building element. Examples are support reactions, internal forces, and deflections.
 */
var IfcStructuralReaction = 1655;
/**
 * Instances of the entity IfcStructuralResultGroup are used to group results of structural analysis calculations and to capture the connection to the underlying basic load group. The basic functionality for grouping inherited from IfcGroup is used to collect instances from IfcStructuralReaction or its respective subclasses.
 */
var IfcStructuralResultGroup = 1656;
/**
 * This entity defines an action which is distributed over a surface. A surface action may be connected with a surface member or surface connection.
 */
var IfcStructuralSurfaceAction = 1657;
/**
 * Instances of IfcStructuralSurfaceConnection describe face 'nodes', i.e. faces where two or more surface members are joined, or face supports. Face surfaces may be planar or curved.
 */
var IfcStructuralSurfaceConnection = 1658;
/**
 * Instances of IfcStructuralSurfaceMember describe face members, that is, structural analysis idealizations of slabs, walls, and shells. Surface members may be planar or curved.
 */
var IfcStructuralSurfaceMember = 1659;
/**
 * This entity describes surface members with varying section properties. The properties are provided by means of Pset_StructuralSurfaceMemberVaryingThickness via IfcRelDefinesByProperties, or by means of aggregation: An instance of IfcStructuralSurfaceMemberVarying may be composed of two or more instances of IfcStructuralSurfaceMember with differing section properties. These subordinate members relate to the instance of IfcStructuralSurfaceMemberVarying by IfcRelAggregates.
 */
var IfcStructuralSurfaceMemberVarying = 1660;
/**
 * This entity defines a reaction which occurs distributed over a surface. A surface reaction may be connected with a surface member or surface connection.
 */
var IfcStructuralSurfaceReaction = 1661;
/**
 * The IfcStyledItem holds presentation style information for products, either explicitly for an IfcGeometricRepresentationItem being part of an IfcShapeRepresentation assigned to a product, or by assigning presentation information to IfcMaterial being assigned as other representation for a product.
 */
var IfcStyledItem = 1662;
/**
 * The IfcStyledRepresentation represents the concept of a styled presentation being a representation of a product or a product component, like material. within a representation context. This representation context does not need to be (but may be) a geometric representation context.
 */
var IfcStyledRepresentation = 1663;
/**
 * IfcStyleModel represents the concept of a particular presentation style defined for a material (or other characteristic) of a product or a product component within a representation context. This representation context may (but has not to be) a geometric representation context.
 */
var IfcStyleModel = 1664;
/**
 * IfcSubContractResource is a construction resource needed in a construction process that represents a sub-contractor.
 */
var IfcSubContractResource = 1665;
/**
 * The resource type IfcSubContractResourceType defines commonly shared information for occurrences of subcontract resources. The set of shared information may include:
 */
var IfcSubContractResourceType = 1666;
/**
 *
 */
var IfcSubedge = 1667;
/**
 * An IfcSurface is a 2-dimensional representation item positioned in 3-dimensional space. 2-dimensional means that each point at the surface can be defined by a 2-dimensional coordinate system, usually by u and v coordinates.
 */
var IfcSurface = 1668;
/**
 * An IfcSurfaceCurve is a 3-dimensional curve that has additional representations provided by one or two pcurves.
 */
var IfcSurfaceCurve = 1669;
/**
 * The IfcSurfaceCurveSweptAreaSolid is the result of sweeping an area along a directrix that lies on a reference surface. The swept area is provided by a subtype of IfcProfileDef. The profile is placed by an implicit cartesian transformation operator at the start point of the sweep, where the profile normal agrees to the tangent of the directrix at this point, and the profile''s x-axis agrees to the surface normal. At any point along the directrix, the swept profile origin lies on the directrix, the profile''s normal points towards the tangent of the directrix, and the profile''s x-axis is identical to the surface normal at this point.
 */
var IfcSurfaceCurveSweptAreaSolid = 1670;
/**
 * A surface feature is a modification at (onto, or into) of the surface of an element. Parts of the surface of the entire surface may be affected. The volume and mass of the element may be increased, remain unchanged, or be decreased by the surface feature, depending on manufacturing technology. However, any increase or decrease of volume is small compared to the total volume of the element.
 */
var IfcSurfaceFeature = 1671;
/**
 * The IfcSurfaceOfLinearExtrusion is a surface derived by sweeping a curve along a vector.
 */
var IfcSurfaceOfLinearExtrusion = 1672;
/**
 * The IfcSurfaceOfRevolution is a surface derived by rotating a curve about an axis.
 */
var IfcSurfaceOfRevolution = 1673;
/**
 * Describes required or provided reinforcement area of surface members.
 */
var IfcSurfaceReinforcementArea = 1674;
/**
 * IfcSurfaceStyle is an assignment of one or many surface style elements to a surface, defined by subtypes of IfcSurface, IfcFaceBasedSurfaceModel, IfcShellBasedSurfaceModel, or by subtypes of IfcSolidModel. The positive direction of the surface normal relates to the positive side. In case of solids the outside of the solid is to be taken as positive side.
 */
var IfcSurfaceStyle = 1675;
/**
 * IfcSurfaceStyleLighting is a container class for properties for calculation of physically exact illuminance related to a particular surface style.
 */
var IfcSurfaceStyleLighting = 1676;
/**
 * IfcSurfaceStyleRefraction extends the surface style lighting, or the surface style rendering definition for properties for calculation of physically exact illuminance by adding seldomly used properties. Currently this includes the refraction index (by which the light ray refracts when passing through a prism) and the dispersion factor (or Abbe constant) which takes into account the wavelength dependency of the refraction.
 */
var IfcSurfaceStyleRefraction = 1677;
/**
 * IfcSurfaceStyleRendering holds the properties for visualization related to a particular surface side style. It allows rendering properties to be defined by:
 */
var IfcSurfaceStyleRendering = 1678;
/**
 * The IfcSurfaceStyleShading allows for colour information and transparency used for shading and simple rendering. The surface colour is used for colouring or simple shading of the assigned surfaces and the transparency for identifying translucency, where 0.0 is completely opaque, and 1.0 is completely transparent.
 */
var IfcSurfaceStyleShading = 1679;
/**
 * The entity IfcSurfaceStyleWithTextures allows to include image textures in surface styles. These image textures can be applied repeating across the surface or mapped with a particular scale upon the surface.
 */
var IfcSurfaceStyleWithTextures = 1680;
/**
 * An IfcSurfaceTexture provides a 2-dimensional image-based texture map. It can either be given by referencing an external image file through an URL reference (IfcImageTexture), including the image file as a blob (long binary) into the data set (IfcBlobTexture), or by explicitly including an array of pixels (IfcPixelTexture).
 */
var IfcSurfaceTexture = 1681;
/**
 * An IfcSweptAreaSolid represents the 3D shape by a sweeping representation scheme allowing a two dimensional planar cross section to sweep through space.
 */
var IfcSweptAreaSolid = 1682;
/**
 * An IfcSweptDiskSolid represents the 3D shape by a sweeping representation scheme allowing a two dimensional circularly bounded plane to sweep along a three dimensional Directrix through space.
 */
var IfcSweptDiskSolid = 1683;
/**
 * The IfcSweptDiskSolidPolygonal is a IfcSweptDiskSolid where the Directrix is restricted to be provided by an poly line only. An optional FilletRadius attribute can be asserted, it is then applied as a fillet to all transitions between the segments of the poly line.
 */
var IfcSweptDiskSolidPolygonal = 1684;
/**
 * An IfcSweptSurface is a surface defined by sweeping a curve. The swept surface is defined by a open or closed curve, represented by a subtype if IfcProfileDef, that is provided as a two-dimensional curve on an implicit plane, and by the sweeping operation.
 */
var IfcSweptSurface = 1685;
/**
 * A switch is used in a cable distribution system (electrical circuit) to control or modulate the flow of electricity.
 */
var IfcSwitchingDevice = 1686;
/**
 * The flow controller type IfcSwitchingDeviceType defines commonly shared information for occurrences of switching devices. The set of shared information may include:
 */
var IfcSwitchingDeviceType = 1687;
/**
 * A system is an organized combination of related parts within an AEC product, composed for a kdtree3 purpose or function or to provide a service. A system is essentially a functionally related aggregation of products. The grouping relationship to one or several instances of IfcProduct (the system members) is handled by IfcRelAssignsToGroup.
 */
var IfcSystem = 1688;
/**
 * A system furniture element defines components of modular furniture which are not directly placed in a building structure but aggregated inside furniture.
 */
var IfcSystemFurnitureElement = 1689;
/**
 * The furnishing element type IfcSystemFurnitureElementType defines commonly shared information for occurrences of system furniture elements. The set of shared information may include:
 */
var IfcSystemFurnitureElementType = 1690;
/**
 * An IfcTable is a data structure for the provision of information in the form of rows and columns. Each instance may have IfcTableColumn instances that define the name, description and units for each column. The rows of information are stored as a list of IfcTableRow objects.
 */
var IfcTable = 1691;
/**
 * An IfcTableColumn is a data structure that captures column information for use in an IfcTable. Each instance defines the identifier, name, description, and units of measure that are applicable to the columnar data associated with the IfcTableRow objects.
 */
var IfcTableColumn = 1692;
/**
 * IfcTableRow contains data for a single row within an IfcTable.
 */
var IfcTableRow = 1693;
/**
 * A tank is a vessel or container in which a fluid or gas is stored for later use.
 */
var IfcTank = 1694;
/**
 * The flow storage device type IfcTankType defines commonly shared information for occurrences of tanks. The set of shared information may include:
 */
var IfcTankType = 1695;
/**
 * An IfcTask is an identifiable unit of work to be carried out in a construction project.
 */
var IfcTask = 1696;
/**
 * IfcTaskTime captures the time-related information about a task including the different types (actual or scheduled) of starting and ending times.
 */
var IfcTaskTime = 1697;
/**
 * IfcTaskTimeRecurring is a recurring instance of IfcTaskTime for handling regularly scheduled or repetitive tasks.
 */
var IfcTaskTimeRecurring = 1698;
/**
 * An IfcTaskType defines a particular type of task that may be specified for use within a work control.
 */
var IfcTaskType = 1699;
/**
 * This entity represents an address to which telephone, electronic mail and other forms of telecommunications should be addressed.
 */
var IfcTelecomAddress = 1700;
/**
 * A tendon is a steel element such as a wire, cable, bar, rod, or strand used to impart prestress to concrete when the element is tensioned.
 */
var IfcTendon = 1701;
/**
 * A tendon anchor is the end connection for tendons in prestressed or posttensioned concrete.
 */
var IfcTendonAnchor = 1702;
/**
 * The reinforcing element type IfcTendonAnchorType defines commonly shared information for occurrences of tendon anchors. The set of shared information may include:
 */
var IfcTendonAnchorType = 1703;
/**
 * The reinforcing element type IfcTendonType defines commonly shared information for occurrences of tendons. The set of shared information may include:
 */
var IfcTendonType = 1704;
/**
 * The IfcTessellatedFaceSet is a boundary representation topological model limited to planar faces and straight edges. It may represent an approximation of an analytical surface or solid that may be provided in addition to its tessellation as a separate shape representation. The IfcTessellatedFaceSet provides a compact data representation of an connected face set using indices into ordered lists of vertices, normals, colours, and texture maps.
 */
var IfcTessellatedFaceSet = 1705;
/**
 * The IfcTessellatedItem is the abstract supertype of all tessellated geometric models.
 */
var IfcTessellatedItem = 1706;
/**
 * The text literal is a geometric representation item which describes a text string using a string literal and additional position and path information. The text size and appearance is determined by the IfcTextStyle that is associated to the IfcTextLiteral through an IfcStyledItem.
 */
var IfcTextLiteral = 1707;
/**
 * The text literal with extent is a text literal with the additional explicit information of the planar extent. An alignment attribute defines how the text box is aligned to the placement and how it may expand if additional lines of text need to be added.
 */
var IfcTextLiteralWithExtent = 1708;
/**
 * The IfcTextStyle is a presentation style for annotations that place a text in model space. The IfcTextStyle provides the text style for presentation information assigned to IfcTextLiteral's. The style is defined by color, text font characteristics, and text box characteristics.
 */
var IfcTextStyle = 1709;
/**
 *
 */
var IfcTextStyleFontModel = 1710;
/**
 * The IfcTextStyleForDefinedFont combines the text font color with an optional background color, that fills the text box, defined by the planar extent given to the text literal.
 */
var IfcTextStyleForDefinedFont = 1711;
/**
 * The IfcTextStyleTextModel combines all text style properties, that affect the presentation of a text literal within a given extent. It includes the spacing between characters and words, the horizontal and vertical alignment of the text within the planar box of the extent, decorations (like underline), transformations of the literal (like uppercase), and the height of each text line within a multi-line text block.
 */
var IfcTextStyleTextModel = 1712;
/**
 * The IfcTextureCoordinate is an abstract supertype of the different kinds to apply texture coordinates to geometries. For vertex based geometries an explicit assignment of 2D texture vertices to the 3D geometry points is supported by the subtype IfcTextureMap, in addition there can be a procedural description of how texture coordinates shall be applied to geometric items. If no IfcTextureCoordinate is provided for the IfcSurfaceTexture, the default mapping shall be used.
 */
var IfcTextureCoordinate = 1713;
/**
 * The IfcTextureCoordinateGenerator describes a procedurally defined mapping function with input parameter to map 2D texture coordinates to 3D geometry vertices. The allowable Mode values and input Parameter need to be agreed upon in view definitions and implementer agreements.
 */
var IfcTextureCoordinateGenerator = 1714;
/**
 * An IfcTextureMap provides the mapping of the 2-dimensional texture coordinates to the surface onto which it is mapped. It is used for mapping the texture to surfaces of vertex based geometry models, such as
 */
var IfcTextureMap = 1715;
/**
 * An IfcTextureVertex is a list of 2 (S, T) texture coordinates.
 */
var IfcTextureVertex = 1716;
/**
 * The IfcTextureVertexList defines an ordered collection of texture vertices. Each texture vertex is a two-dimensional vertex provided by a fixed list of two texture coordinates. The attribute TexCoordsList is a two-dimensional list, where
 */
var IfcTextureVertexList = 1717;
/**
 * IfcTimePeriod defines a time period given by a start and end time. Both time definitions consider the time zone and allow for the daylight savings offset.
 */
var IfcTimePeriod = 1718;
/**
 * A time series is a set of a time-stamped data entries. It allows a natural association of data collected over intervals of time. Time series can be regular or irregular. In regular time series data arrive predictably at predefined intervals. In irregular time series some or all time stamps do not follow a repetitive pattern and unpredictable bursts of data may arrive at unspecified points in time.
 */
var IfcTimeSeries = 1719;
/**
 * A time series value is a list of values that comprise the time series. At least one value must be supplied. Applications are expected to normalize values by applying the following three rules:
 */
var IfcTimeSeriesValue = 1720;
/**
 *
 */
var IfcTopologicalRepresentationItem = 1721;
/**
 * IfcTopologyRepresentation represents the concept of a particular topological representation of a product or a product component within a representation context. This representation context does not need to be (but may be) a geometric representation context. Several representation types for shape representation are included as predefined types:
 */
var IfcTopologyRepresentation = 1722;
/**
 * The IfcToroidalSurface is a bounded elementary surface. It is constructed by completely revolving a circle around an axis line. The inherited Position attribute defines the IfcAxisPlacement3D and provides:
 */
var IfcToroidalSurface = 1723;
/**
 * A transformer is an inductive stationary device that transfers electrical energy from one circuit to another.
 */
var IfcTransformer = 1724;
/**
 * The energy conversion device type IfcTransformerType defines commonly shared information for occurrences of transformers. The set of shared information may include:
 */
var IfcTransformerType = 1725;
/**
 * A transport element is a generalization of all transport related objects that move people, animals or goods within a facility. The IfcTransportElement defines the occurrence of a transport element, that (if given), is expressed by the IfcTransportElementType .
 */
var IfcTransportElement = 1726;
/**
 * The element type IfcTransportElementType  defines commonly shared information for occurrences of transport elements. The set of shared information may include:
 */
var IfcTransportElementType = 1727;
/**
 * IfcTrapeziumProfileDef defines a trapezium as the profile definition used by the swept surface geometry or the swept area solid. It is given by its Top X and Bottom X extent and its Y extent as well as by the offset of the Top X extend, and placed within the 2D position coordinate system, established by the Position attribute. It is placed centric within the position coordinate system, that is, in the center of the bounding box.
 */
var IfcTrapeziumProfileDef = 1728;
/**
 * The IfcTriangulatedFaceSet is a tessellated face set with all faces being bound by triangles. The faces are constructed by implicit polylines defined by three Cartesian points. Depending on the value of the attribute Closed the instance of IfcTriangulatedFaceSet represents:
 */
var IfcTriangulatedFaceSet = 1729;
/**
 * An IfcTrimmedCurve is a bounded curve that is trimmed at both ends. The trimming points may be provided by a Cartesian point or by a parameter value, based on the parameterization of the BasisCurve. The SenseAgreement attribute indicates whether the direction of the IfcTrimmedCurve agrees with or is opposed to the direction of the BasisCurve.
 */
var IfcTrimmedCurve = 1730;
/**
 * IfcTShapeProfileDef defines a section profile that provides the defining parameters of a T-shaped section to be used by the swept area solid. Its parameters and orientation relative to the position coordinate system are according to the following illustration. The centre of the position coordinate system is in the profile's centre of the bounding box.
 */
var IfcTShapeProfileDef = 1731;
/**
 * A tube bundle is a device consisting of tubes and bundles of tubes used for heat transfer and contained typically within other energy conversion devices, such as a chiller or coil.
 */
var IfcTubeBundle = 1732;
/**
 * The energy conversion device type IfcTubeBundleType defines commonly shared information for occurrences of tube bundles. The set of shared information may include:
 */
var IfcTubeBundleType = 1733;
/**
 * The object type defines the specific information about a type, being kdtree3 to all occurrences of this type. It refers to the specific level of the well recognized generic - specific - occurrance modeling paradigm. The IfcTypeObject gets assigned to the individual object instances (the occurrences) via the IfcRelDefinesByType relationship.
 */
var IfcTypeObject = 1734;
/**
 * IfcTypeProcess defines a specific (or type) definition of a process or activity without being assigned to a schedule or a time. It is used to define a process or activity specification, that is, the specific process or activity information that is kdtree3 to all occurrences that are defined for that process or activity type.
 */
var IfcTypeProcess = 1735;
/**
 * IfcTypeProduct defines a type definition of a product without being already inserted into a project structure (without having a placement), and not being included in the geometric representation context of the project. It is used to define a product specification, that is, the specific product information that is kdtree3 to all occurrences of that product type.
 */
var IfcTypeProduct = 1736;
/**
 * IfcTypeResource defines a specific (or type) definition of a resource. It is used to define a resource specification (the specific resource, that is kdtree3 to all occurrences that are defined for that resource) and could act as a resource template.
 */
var IfcTypeResource = 1737;
/**
 * A unitary control element combines a number of control components into a single product, such as a thermostat or humidistat.
 */
var IfcUnitaryControlElement = 1738;
/**
 * The distribution control element type IfcUnitaryControlElementType defines commonly shared information for occurrences of unitary control elements. The set of shared information may include:
 */
var IfcUnitaryControlElementType = 1739;
/**
 * Unitary equipment typically combine a number of components into a single product, such as air handlers, pre-packaged rooftop air-conditioning units, heat pumps, and split systems.
 */
var IfcUnitaryEquipment = 1740;
/**
 * The energy conversion device type IfcUnitaryEquipmentType defines commonly shared information for occurrences of unitary equipments. The set of shared information may include:
 */
var IfcUnitaryEquipmentType = 1741;
/**
 * IfcUnitAssignment indicates a set of units which may be assigned. Within an IfcUnitAssigment each unit definition shall be unique; that is, there shall be no redundant unit definitions for the same unit type such as length unit or area unit. For currencies, there shall be only a single IfcMonetaryUnit within an IfcUnitAssignment.
 */
var IfcUnitAssignment = 1742;
/**
 * IfcUShapeProfileDef defines a section profile that provides the defining parameters of a U-shape (channel) section to be used by the swept area solid. Its parameters and orientation relative to the position coordinate system are according to the following illustration. The centre of the position coordinate system is in the profile's centre of the bounding box.
 */
var IfcUShapeProfileDef = 1743;
/**
 * A valve is used in a building services piping distribution system to control or modulate the flow of the fluid.
 */
var IfcValve = 1744;
/**
 * The flow controller type IfcValveType defines commonly shared information for occurrences of valves. The set of shared information may include:
 */
var IfcValveType = 1745;
/**
 * An IfcVector is a geometric representation item having both a magnitude and direction. The magnitude of the vector is solely defined by the Magnitude attribute and the direction is solely defined by the Orientation attribute.
 */
var IfcVector = 1746;
/**
 *
 */
var IfcVertex = 1747;
/**
 *
 */
var IfcVertexLoop = 1748;
/**
 *
 */
var IfcVertexPoint = 1749;
/**
 * A vibration isolator is a device used to minimize the effects of vibration transmissibility in a structure.
 */
var IfcVibrationIsolator = 1750;
/**
 * The element component type IfcVibrationIsolatorType defines commonly shared information for occurrences of vibration isolators. The set of shared information may include:
 */
var IfcVibrationIsolatorType = 1751;
/**
 * A virtual element is a special element used to provide imaginary boundaries, such as between two adjacent, but not separated, spaces. Virtual elements are usually not displayed and does not have quantities and other measures. Therefore IfcVirtualElement does not have material information and quantities attached.
 */
var IfcVirtualElement = 1752;
/**
 * IfcVirtualGridIntersection defines the derived location of the intersection between two grid axes. Offset values may be given to set an offset distance to the grid axis for the calculation of the virtual grid intersection.
 */
var IfcVirtualGridIntersection = 1753;
/**
 * A voiding feature is a modification of an element which reduces its volume. Such a feature may be manufactured in different ways, for example by cutting, drilling, or milling of members made of various materials, or by inlays into the formwork of cast members made of materials such as concrete.
 */
var IfcVoidingFeature = 1754;
/**
 * The wall represents a vertical construction that may bound or subdivide spaces. Wall are usually vertical, or nearly vertical, planar elements, often designed to bear structural loads. A wall is however not required to be load bearing.
 */
var IfcWall = 1755;
/**
 * The IfcWallElementedCase defines a wall with certain constraints for the provision of its components. The IfcWallElementedCase handles all cases of walls, that are decomposed into parts:
 */
var IfcWallElementedCase = 1756;
/**
 * The IfcWallStandardCase defines a wall with certain constraints for the provision of parameters and with certain constraints for the geometric representation. The IfcWallStandardCase handles all cases of walls, that are extruded vertically:
 */
var IfcWallStandardCase = 1757;
/**
 * The element type IfcWallType defines commonly shared information for occurrences of walls.
 */
var IfcWallType = 1758;
/**
 * A waste terminal has the purpose of collecting or intercepting waste from one or more sanitary terminals or other fluid waste generating equipment and discharging it into a single waste/drainage system.
 */
var IfcWasteTerminal = 1759;
/**
 * The flow terminal type IfcWasteTerminalType defines commonly shared information for occurrences of waste terminals. The set of shared information may include:
 */
var IfcWasteTerminalType = 1760;
/**
 * The window is a building element that is predominately used to provide natural light and fresh air. It includes vertical opening but also horizontal opening such as skylights or light domes. It includes constructions with swinging, pivoting, sliding, or revolving panels and fixed panels. A window consists of a lining and one or several panels.
 */
var IfcWindow = 1761;
/**
 * The window lining is the outer frame which enables the window to be fixed in position. The window lining is used to hold the window panels or other casements. The parameter of the IfcWindowLiningProperties define the geometrically relevant parameter of the lining.
 */
var IfcWindowLiningProperties = 1762;
/**
 * A window panel is a casement, that is, a component, fixed or opening, consisting essentially of a frame and the infilling. The infilling of a window panel is normally glazing. The way of operation is defined in the operation type.
 */
var IfcWindowPanelProperties = 1763;
/**
 * The standard window, IfcWindowStandardCase, defines a window with certain constraints for the provision of operation types, opening directions, frame and lining parameters, construction types and with certain constraints for the geometric representation. The IfcWindowStandardCase handles all cases of windows, that:
 */
var IfcWindowStandardCase = 1764;
/**
 * The window style defines a particular style of windows, which may be included into the spatial context of the building model through instances of IfcWindow. A window style defines the overall parameter of the window style and refers to the particular parameter of the lining and one (or several) panels through IfcWindowLiningProperties and IfcWindowPanelProperties.
 */
var IfcWindowStyle = 1765;
/**
 * The element type IfcWindowType defines commonly shared information for occurrences of windows. The set of shared information may include:
 */
var IfcWindowType = 1766;
/**
 * An IfcWorkCalendar defines working and non-working time periods for tasks and resources. It enables to define both specific time periods, such as from 7:00 till 12:00 on 25th August 2009, as well as repetitive time periods based on frequently used recurrence patterns, such as each Monday from 7:00 till 12:00 between 1st March 2009 and 31st December 2009.
 */
var IfcWorkCalendar = 1767;
/**
 * An IfcWorkControl is an abstract supertype which captures information that is kdtree3 to both IfcWorkPlan and IfcWorkSchedule.
 */
var IfcWorkControl = 1768;
/**
 * An IfcWorkPlan represents work plans in a construction or a facilities management project.
 */
var IfcWorkPlan = 1769;
/**
 * An IfcWorkSchedule represents a task schedule of a work plan, which in turn can contain a set of schedules for different purposes.
 */
var IfcWorkSchedule = 1770;
/**
 * IfcWorkTime defines time periods that are used by IfcWorkCalendar for either describing working times or non-working exception times. Besides start and finish dates, a set of time periods can be given by various types of recurrence patterns.
 */
var IfcWorkTime = 1771;
/**
 * A zone is a group of spaces, partial spaces or other zones. Zone structures may not be hierarchical (in contrary to the spatial structure of a project - see IfcSpatialStructureElement), i.e. one individual IfcSpace may be associated with zero, one, or several IfcZone's. IfcSpace's are grouped into an IfcZone by using the objectified relationship IfcRelAssignsToGroup as specified at the supertype IfcGroup.
 */
var IfcZone = 1772;
/**
 * IfcZShapeProfileDef defines a section profile that provides the defining parameters of a Z-shape section to be used by the swept area solid. Its parameters and orientation relative to the position coordinate system are according to the following illustration. The centre of the position coordinate system is in the profile's centre of the bounding box.
 */
var IfcZShapeProfileDef = 1773;
/**
 * Map of names for all supported IFC types.
 */
var typeNames = {
  // TODO
};
/**
 * Map of type codes for all IFC type names.
 */
var typeCodes = {
  // TODO
};

var index$8 = {
  __proto__: null,
  IfcActionRequest: IfcActionRequest,
  IfcActor: IfcActor,
  IfcActorRole: IfcActorRole,
  IfcActuator: IfcActuator,
  IfcActuatorType: IfcActuatorType,
  IfcAddress: IfcAddress,
  IfcAdvancedBrep: IfcAdvancedBrep,
  IfcAdvancedBrepWithVoids: IfcAdvancedBrepWithVoids,
  IfcAdvancedFace: IfcAdvancedFace,
  IfcAirTerminal: IfcAirTerminal,
  IfcAirTerminalBox: IfcAirTerminalBox,
  IfcAirTerminalBoxType: IfcAirTerminalBoxType,
  IfcAirTerminalType: IfcAirTerminalType,
  IfcAirToAirHeatRecovery: IfcAirToAirHeatRecovery,
  IfcAirToAirHeatRecoveryType: IfcAirToAirHeatRecoveryType,
  IfcAlarm: IfcAlarm,
  IfcAlarmType: IfcAlarmType,
  IfcAnnotation: IfcAnnotation,
  IfcAnnotationFillArea: IfcAnnotationFillArea,
  IfcApplication: IfcApplication,
  IfcAppliedValue: IfcAppliedValue,
  IfcApproval: IfcApproval,
  IfcApprovalRelationship: IfcApprovalRelationship,
  IfcArbitraryClosedProfileDef: IfcArbitraryClosedProfileDef,
  IfcArbitraryOpenProfileDef: IfcArbitraryOpenProfileDef,
  IfcArbitraryProfileDefWithVoids: IfcArbitraryProfileDefWithVoids,
  IfcAsset: IfcAsset,
  IfcAsymmetricIShapeProfileDef: IfcAsymmetricIShapeProfileDef,
  IfcAudioVisualAppliance: IfcAudioVisualAppliance,
  IfcAudioVisualApplianceType: IfcAudioVisualApplianceType,
  IfcAxis1Placement: IfcAxis1Placement,
  IfcAxis2Placement2D: IfcAxis2Placement2D,
  IfcAxis2Placement3D: IfcAxis2Placement3D,
  IfcBeam: IfcBeam,
  IfcBeamStandardCase: IfcBeamStandardCase,
  IfcBeamType: IfcBeamType,
  IfcBlobTexture: IfcBlobTexture,
  IfcBlock: IfcBlock,
  IfcBoiler: IfcBoiler,
  IfcBoilerType: IfcBoilerType,
  IfcBooleanClippingResult: IfcBooleanClippingResult,
  IfcBooleanResult: IfcBooleanResult,
  IfcBoundaryCondition: IfcBoundaryCondition,
  IfcBoundaryCurve: IfcBoundaryCurve,
  IfcBoundaryEdgeCondition: IfcBoundaryEdgeCondition,
  IfcBoundaryFaceCondition: IfcBoundaryFaceCondition,
  IfcBoundaryNodeCondition: IfcBoundaryNodeCondition,
  IfcBoundaryNodeConditionWarping: IfcBoundaryNodeConditionWarping,
  IfcBoundedCurve: IfcBoundedCurve,
  IfcBoundedSurface: IfcBoundedSurface,
  IfcBoundingBox: IfcBoundingBox,
  IfcBoxedHalfSpace: IfcBoxedHalfSpace,
  IfcBSplineCurve: IfcBSplineCurve,
  IfcBSplineCurveWithKnots: IfcBSplineCurveWithKnots,
  IfcBSplineSurface: IfcBSplineSurface,
  IfcBSplineSurfaceWithKnots: IfcBSplineSurfaceWithKnots,
  IfcBuilding: IfcBuilding,
  IfcBuildingElementPart: IfcBuildingElementPart,
  IfcBuildingElementPartType: IfcBuildingElementPartType,
  IfcBuildingElementProxy: IfcBuildingElementProxy,
  IfcBuildingElementProxyType: IfcBuildingElementProxyType,
  IfcBuildingStorey: IfcBuildingStorey,
  IfcBuildingSystem: IfcBuildingSystem,
  IfcBurner: IfcBurner,
  IfcBurnerType: IfcBurnerType,
  IfcCableCarrierFitting: IfcCableCarrierFitting,
  IfcCableCarrierFittingType: IfcCableCarrierFittingType,
  IfcCableCarrierSegment: IfcCableCarrierSegment,
  IfcCableCarrierSegmentType: IfcCableCarrierSegmentType,
  IfcCableFitting: IfcCableFitting,
  IfcCableFittingType: IfcCableFittingType,
  IfcCableSegment: IfcCableSegment,
  IfcCableSegmentType: IfcCableSegmentType,
  IfcCartesianPoint: IfcCartesianPoint,
  IfcCartesianPointList: IfcCartesianPointList,
  IfcCartesianPointList2D: IfcCartesianPointList2D,
  IfcCartesianPointList3D: IfcCartesianPointList3D,
  IfcCartesianTransformationOperator: IfcCartesianTransformationOperator,
  IfcCartesianTransformationOperator2D: IfcCartesianTransformationOperator2D,
  IfcCartesianTransformationOperator2DnonUniform: IfcCartesianTransformationOperator2DnonUniform,
  IfcCartesianTransformationOperator3D: IfcCartesianTransformationOperator3D,
  IfcCartesianTransformationOperator3DnonUniform: IfcCartesianTransformationOperator3DnonUniform,
  IfcCenterLineProfileDef: IfcCenterLineProfileDef,
  IfcChiller: IfcChiller,
  IfcChillerType: IfcChillerType,
  IfcChimney: IfcChimney,
  IfcChimneyType: IfcChimneyType,
  IfcCircle: IfcCircle,
  IfcCircleHollowProfileDef: IfcCircleHollowProfileDef,
  IfcCircleProfileDef: IfcCircleProfileDef,
  IfcCivilElement: IfcCivilElement,
  IfcCivilElementType: IfcCivilElementType,
  IfcClassification: IfcClassification,
  IfcClassificationReference: IfcClassificationReference,
  IfcClosedShell: IfcClosedShell,
  IfcCoil: IfcCoil,
  IfcCoilType: IfcCoilType,
  IfcColourRgb: IfcColourRgb,
  IfcColourRgbList: IfcColourRgbList,
  IfcColourSpecification: IfcColourSpecification,
  IfcColumn: IfcColumn,
  IfcColumnStandardCase: IfcColumnStandardCase,
  IfcColumnType: IfcColumnType,
  IfcCommunicationsAppliance: IfcCommunicationsAppliance,
  IfcCommunicationsApplianceType: IfcCommunicationsApplianceType,
  IfcComplexProperty: IfcComplexProperty,
  IfcComplexPropertyTemplate: IfcComplexPropertyTemplate,
  IfcCompositeCurve: IfcCompositeCurve,
  IfcCompositeCurveOnSurface: IfcCompositeCurveOnSurface,
  IfcCompositeCurveSegment: IfcCompositeCurveSegment,
  IfcCompositeProfileDef: IfcCompositeProfileDef,
  IfcCompressor: IfcCompressor,
  IfcCompressorType: IfcCompressorType,
  IfcCondenser: IfcCondenser,
  IfcCondenserType: IfcCondenserType,
  IfcConic: IfcConic,
  IfcConnectedFaceSet: IfcConnectedFaceSet,
  IfcConnectionCurveGeometry: IfcConnectionCurveGeometry,
  IfcConnectionGeometry: IfcConnectionGeometry,
  IfcConnectionPointEccentricity: IfcConnectionPointEccentricity,
  IfcConnectionPointGeometry: IfcConnectionPointGeometry,
  IfcConnectionSurfaceGeometry: IfcConnectionSurfaceGeometry,
  IfcConnectionVolumeGeometry: IfcConnectionVolumeGeometry,
  IfcConstraint: IfcConstraint,
  IfcConstructionEquipmentResource: IfcConstructionEquipmentResource,
  IfcConstructionEquipmentResourceType: IfcConstructionEquipmentResourceType,
  IfcConstructionMaterialResource: IfcConstructionMaterialResource,
  IfcConstructionMaterialResourceType: IfcConstructionMaterialResourceType,
  IfcConstructionProductResource: IfcConstructionProductResource,
  IfcConstructionProductResourceType: IfcConstructionProductResourceType,
  IfcConstructionResource: IfcConstructionResource,
  IfcConstructionResourceType: IfcConstructionResourceType,
  IfcContext: IfcContext,
  IfcContextDependentUnit: IfcContextDependentUnit,
  IfcControl: IfcControl,
  IfcController: IfcController,
  IfcControllerType: IfcControllerType,
  IfcConversionBasedUnit: IfcConversionBasedUnit,
  IfcConversionBasedUnitWithOffset: IfcConversionBasedUnitWithOffset,
  IfcCooledBeam: IfcCooledBeam,
  IfcCooledBeamType: IfcCooledBeamType,
  IfcCoolingTower: IfcCoolingTower,
  IfcCoolingTowerType: IfcCoolingTowerType,
  IfcCoordinateOperation: IfcCoordinateOperation,
  IfcCoordinateReferenceSystem: IfcCoordinateReferenceSystem,
  IfcCostItem: IfcCostItem,
  IfcCostSchedule: IfcCostSchedule,
  IfcCostValue: IfcCostValue,
  IfcCovering: IfcCovering,
  IfcCoveringType: IfcCoveringType,
  IfcCrewResource: IfcCrewResource,
  IfcCrewResourceType: IfcCrewResourceType,
  IfcCsgPrimitive3D: IfcCsgPrimitive3D,
  IfcCsgSolid: IfcCsgSolid,
  IfcCShapeProfileDef: IfcCShapeProfileDef,
  IfcCurrencyRelationship: IfcCurrencyRelationship,
  IfcCurtainWall: IfcCurtainWall,
  IfcCurtainWallType: IfcCurtainWallType,
  IfcCurve: IfcCurve,
  IfcCurveBoundedPlane: IfcCurveBoundedPlane,
  IfcCurveBoundedSurface: IfcCurveBoundedSurface,
  IfcCurveStyle: IfcCurveStyle,
  IfcCurveStyleFont: IfcCurveStyleFont,
  IfcCurveStyleFontAndScaling: IfcCurveStyleFontAndScaling,
  IfcCurveStyleFontPattern: IfcCurveStyleFontPattern,
  IfcCylindricalSurface: IfcCylindricalSurface,
  IfcDamper: IfcDamper,
  IfcDamperType: IfcDamperType,
  IfcDerivedProfileDef: IfcDerivedProfileDef,
  IfcDerivedUnit: IfcDerivedUnit,
  IfcDerivedUnitElement: IfcDerivedUnitElement,
  IfcDimensionalExponents: IfcDimensionalExponents,
  IfcDirection: IfcDirection,
  IfcDiscreteAccessory: IfcDiscreteAccessory,
  IfcDiscreteAccessoryType: IfcDiscreteAccessoryType,
  IfcDistributionChamberElement: IfcDistributionChamberElement,
  IfcDistributionChamberElementType: IfcDistributionChamberElementType,
  IfcDistributionCircuit: IfcDistributionCircuit,
  IfcDistributionControlElement: IfcDistributionControlElement,
  IfcDistributionControlElementType: IfcDistributionControlElementType,
  IfcDistributionElement: IfcDistributionElement,
  IfcDistributionElementType: IfcDistributionElementType,
  IfcDistributionFlowElement: IfcDistributionFlowElement,
  IfcDistributionFlowElementType: IfcDistributionFlowElementType,
  IfcDistributionPort: IfcDistributionPort,
  IfcDistributionSystem: IfcDistributionSystem,
  IfcDocumentInformation: IfcDocumentInformation,
  IfcDocumentInformationRelationship: IfcDocumentInformationRelationship,
  IfcDocumentReference: IfcDocumentReference,
  IfcDoor: IfcDoor,
  IfcDoorLiningProperties: IfcDoorLiningProperties,
  IfcDoorPanelProperties: IfcDoorPanelProperties,
  IfcDoorStandardCase: IfcDoorStandardCase,
  IfcDoorStyle: IfcDoorStyle,
  IfcDoorType: IfcDoorType,
  IfcDraughtingPreDefinedColour: IfcDraughtingPreDefinedColour,
  IfcDraughtingPreDefinedCurveFont: IfcDraughtingPreDefinedCurveFont,
  IfcDuctFitting: IfcDuctFitting,
  IfcDuctFittingType: IfcDuctFittingType,
  IfcDuctSegment: IfcDuctSegment,
  IfcDuctSegmentType: IfcDuctSegmentType,
  IfcDuctSilencer: IfcDuctSilencer,
  IfcDuctSilencerType: IfcDuctSilencerType,
  IfcEdge: IfcEdge,
  IfcEdgeCurve: IfcEdgeCurve,
  IfcEdgeLoop: IfcEdgeLoop,
  IfcElectricAppliance: IfcElectricAppliance,
  IfcElectricApplianceType: IfcElectricApplianceType,
  IfcElectricDistributionBoard: IfcElectricDistributionBoard,
  IfcElectricDistributionBoardType: IfcElectricDistributionBoardType,
  IfcElectricFlowStorageDevice: IfcElectricFlowStorageDevice,
  IfcElectricFlowStorageDeviceType: IfcElectricFlowStorageDeviceType,
  IfcElectricGenerator: IfcElectricGenerator,
  IfcElectricGeneratorType: IfcElectricGeneratorType,
  IfcElectricMotor: IfcElectricMotor,
  IfcElectricMotorType: IfcElectricMotorType,
  IfcElectricTimeControl: IfcElectricTimeControl,
  IfcElectricTimeControlType: IfcElectricTimeControlType,
  IfcElement: IfcElement,
  IfcElementarySurface: IfcElementarySurface,
  IfcElementAssembly: IfcElementAssembly,
  IfcElementAssemblyType: IfcElementAssemblyType,
  IfcElementComponent: IfcElementComponent,
  IfcElementComponentType: IfcElementComponentType,
  IfcElementQuantity: IfcElementQuantity,
  IfcElementType: IfcElementType,
  IfcEllipse: IfcEllipse,
  IfcEllipseProfileDef: IfcEllipseProfileDef,
  IfcEnergyConversionDevice: IfcEnergyConversionDevice,
  IfcEnergyConversionDeviceType: IfcEnergyConversionDeviceType,
  IfcEngine: IfcEngine,
  IfcEngineType: IfcEngineType,
  IfcEvaporativeCooler: IfcEvaporativeCooler,
  IfcEvaporativeCoolerType: IfcEvaporativeCoolerType,
  IfcEvaporator: IfcEvaporator,
  IfcEvaporatorType: IfcEvaporatorType,
  IfcEvent: IfcEvent,
  IfcEventTime: IfcEventTime,
  IfcEventType: IfcEventType,
  IfcExtendedProperties: IfcExtendedProperties,
  IfcExternalInformation: IfcExternalInformation,
  IfcExternallyDefinedHatchStyle: IfcExternallyDefinedHatchStyle,
  IfcExternallyDefinedSurfaceStyle: IfcExternallyDefinedSurfaceStyle,
  IfcExternallyDefinedTextFont: IfcExternallyDefinedTextFont,
  IfcExternalReference: IfcExternalReference,
  IfcExternalReferenceRelationship: IfcExternalReferenceRelationship,
  IfcExternalSpatialElement: IfcExternalSpatialElement,
  IfcExternalSpatialStructureElement: IfcExternalSpatialStructureElement,
  IfcExtrudedAreaSolid: IfcExtrudedAreaSolid,
  IfcExtrudedAreaSolidTapered: IfcExtrudedAreaSolidTapered,
  IfcFace: IfcFace,
  IfcFaceBasedSurfaceModel: IfcFaceBasedSurfaceModel,
  IfcFaceBound: IfcFaceBound,
  IfcFaceOuterBound: IfcFaceOuterBound,
  IfcFaceSurface: IfcFaceSurface,
  IfcFacetedBrep: IfcFacetedBrep,
  IfcFacetedBrepWithVoids: IfcFacetedBrepWithVoids,
  IfcFailureConnectionCondition: IfcFailureConnectionCondition,
  IfcFan: IfcFan,
  IfcFanType: IfcFanType,
  IfcFastener: IfcFastener,
  IfcFastenerType: IfcFastenerType,
  IfcFeatureElement: IfcFeatureElement,
  IfcFeatureElementAddition: IfcFeatureElementAddition,
  IfcFeatureElementSubtraction: IfcFeatureElementSubtraction,
  IfcFillAreaStyle: IfcFillAreaStyle,
  IfcFillAreaStyleHatching: IfcFillAreaStyleHatching,
  IfcFillAreaStyleTiles: IfcFillAreaStyleTiles,
  IfcFilter: IfcFilter,
  IfcFilterType: IfcFilterType,
  IfcFireSuppressionTerminal: IfcFireSuppressionTerminal,
  IfcFireSuppressionTerminalType: IfcFireSuppressionTerminalType,
  IfcFixedReferenceSweptAreaSolid: IfcFixedReferenceSweptAreaSolid,
  IfcFlowController: IfcFlowController,
  IfcFlowControllerType: IfcFlowControllerType,
  IfcFlowFitting: IfcFlowFitting,
  IfcFlowFittingType: IfcFlowFittingType,
  IfcFlowInstrument: IfcFlowInstrument,
  IfcFlowInstrumentType: IfcFlowInstrumentType,
  IfcFlowMeter: IfcFlowMeter,
  IfcFlowMeterType: IfcFlowMeterType,
  IfcFlowMovingDevice: IfcFlowMovingDevice,
  IfcFlowMovingDeviceType: IfcFlowMovingDeviceType,
  IfcFlowSegment: IfcFlowSegment,
  IfcFlowSegmentType: IfcFlowSegmentType,
  IfcFlowStorageDevice: IfcFlowStorageDevice,
  IfcFlowStorageDeviceType: IfcFlowStorageDeviceType,
  IfcFlowTerminal: IfcFlowTerminal,
  IfcFlowTerminalType: IfcFlowTerminalType,
  IfcFlowTreatmentDevice: IfcFlowTreatmentDevice,
  IfcFlowTreatmentDeviceType: IfcFlowTreatmentDeviceType,
  IfcFooting: IfcFooting,
  IfcFootingType: IfcFootingType,
  IfcFurnishingElement: IfcFurnishingElement,
  IfcFurnishingElementType: IfcFurnishingElementType,
  IfcFurniture: IfcFurniture,
  IfcFurnitureType: IfcFurnitureType,
  IfcGeographicElement: IfcGeographicElement,
  IfcGeographicElementType: IfcGeographicElementType,
  IfcGeometricCurveSet: IfcGeometricCurveSet,
  IfcGeometricRepresentationContext: IfcGeometricRepresentationContext,
  IfcGeometricRepresentationItem: IfcGeometricRepresentationItem,
  IfcGeometricRepresentationSubContext: IfcGeometricRepresentationSubContext,
  IfcGeometricSet: IfcGeometricSet,
  IfcGrid: IfcGrid,
  IfcGridAxis: IfcGridAxis,
  IfcGridPlacement: IfcGridPlacement,
  IfcGroup: IfcGroup,
  IfcHalfSpaceSolid: IfcHalfSpaceSolid,
  IfcHeatExchanger: IfcHeatExchanger,
  IfcHeatExchangerType: IfcHeatExchangerType,
  IfcHumidifier: IfcHumidifier,
  IfcHumidifierType: IfcHumidifierType,
  IfcImageTexture: IfcImageTexture,
  IfcIndexedColourMap: IfcIndexedColourMap,
  IfcIndexedPolyCurve: IfcIndexedPolyCurve,
  IfcIndexedPolygonalFace: IfcIndexedPolygonalFace,
  IfcIndexedPolygonalFaceWithVoids: IfcIndexedPolygonalFaceWithVoids,
  IfcIndexedTextureMap: IfcIndexedTextureMap,
  IfcIndexedTriangleTextureMap: IfcIndexedTriangleTextureMap,
  IfcInterceptor: IfcInterceptor,
  IfcInterceptorType: IfcInterceptorType,
  IfcIntersectionCurve: IfcIntersectionCurve,
  IfcInventory: IfcInventory,
  IfcIrregularTimeSeries: IfcIrregularTimeSeries,
  IfcIrregularTimeSeriesValue: IfcIrregularTimeSeriesValue,
  IfcIShapeProfileDef: IfcIShapeProfileDef,
  IfcJunctionBox: IfcJunctionBox,
  IfcJunctionBoxType: IfcJunctionBoxType,
  IfcLaborResource: IfcLaborResource,
  IfcLaborResourceType: IfcLaborResourceType,
  IfcLagTime: IfcLagTime,
  IfcLamp: IfcLamp,
  IfcLampType: IfcLampType,
  IfcLibraryInformation: IfcLibraryInformation,
  IfcLibraryReference: IfcLibraryReference,
  IfcLightDistributionData: IfcLightDistributionData,
  IfcLightFixture: IfcLightFixture,
  IfcLightFixtureType: IfcLightFixtureType,
  IfcLightIntensityDistribution: IfcLightIntensityDistribution,
  IfcLightSource: IfcLightSource,
  IfcLightSourceAmbient: IfcLightSourceAmbient,
  IfcLightSourceDirectional: IfcLightSourceDirectional,
  IfcLightSourceGoniometric: IfcLightSourceGoniometric,
  IfcLightSourcePositional: IfcLightSourcePositional,
  IfcLightSourceSpot: IfcLightSourceSpot,
  IfcLine: IfcLine,
  IfcLocalPlacement: IfcLocalPlacement,
  IfcLoop: IfcLoop,
  IfcLShapeProfileDef: IfcLShapeProfileDef,
  IfcManifoldSolidBrep: IfcManifoldSolidBrep,
  IfcMapConversion: IfcMapConversion,
  IfcMappedItem: IfcMappedItem,
  IfcMaterial: IfcMaterial,
  IfcMaterialClassificationRelationship: IfcMaterialClassificationRelationship,
  IfcMaterialConstituent: IfcMaterialConstituent,
  IfcMaterialConstituentSet: IfcMaterialConstituentSet,
  IfcMaterialDefinition: IfcMaterialDefinition,
  IfcMaterialDefinitionRepresentation: IfcMaterialDefinitionRepresentation,
  IfcMaterialLayer: IfcMaterialLayer,
  IfcMaterialLayerSet: IfcMaterialLayerSet,
  IfcMaterialLayerSetUsage: IfcMaterialLayerSetUsage,
  IfcMaterialLayerWithOffsets: IfcMaterialLayerWithOffsets,
  IfcMaterialList: IfcMaterialList,
  IfcMaterialProfile: IfcMaterialProfile,
  IfcMaterialProfileSet: IfcMaterialProfileSet,
  IfcMaterialProfileSetUsage: IfcMaterialProfileSetUsage,
  IfcMaterialProfileSetUsageTapering: IfcMaterialProfileSetUsageTapering,
  IfcMaterialProfileWithOffsets: IfcMaterialProfileWithOffsets,
  IfcMaterialProperties: IfcMaterialProperties,
  IfcMaterialRelationship: IfcMaterialRelationship,
  IfcMaterialUsageDefinition: IfcMaterialUsageDefinition,
  IfcMeasureWithUnit: IfcMeasureWithUnit,
  IfcMechanicalFastener: IfcMechanicalFastener,
  IfcMechanicalFastenerType: IfcMechanicalFastenerType,
  IfcMedicalDevice: IfcMedicalDevice,
  IfcMedicalDeviceType: IfcMedicalDeviceType,
  IfcMember: IfcMember,
  IfcMemberStandardCase: IfcMemberStandardCase,
  IfcMemberType: IfcMemberType,
  IfcMetric: IfcMetric,
  IfcMirroredProfileDef: IfcMirroredProfileDef,
  IfcMonetaryUnit: IfcMonetaryUnit,
  IfcMotorConnection: IfcMotorConnection,
  IfcMotorConnectionType: IfcMotorConnectionType,
  IfcNamedUnit: IfcNamedUnit,
  IfcObject: IfcObject,
  IfcObjectDefinition: IfcObjectDefinition,
  IfcObjective: IfcObjective,
  IfcObjectPlacement: IfcObjectPlacement,
  IfcOccupant: IfcOccupant,
  IfcOffsetCurve2D: IfcOffsetCurve2D,
  IfcOffsetCurve3D: IfcOffsetCurve3D,
  IfcOpeningElement: IfcOpeningElement,
  IfcOpeningStandardCase: IfcOpeningStandardCase,
  IfcOpenShell: IfcOpenShell,
  IfcOrganization: IfcOrganization,
  IfcOrganizationRelationship: IfcOrganizationRelationship,
  IfcOrientedEdge: IfcOrientedEdge,
  IfcOuterBoundaryCurve: IfcOuterBoundaryCurve,
  IfcOutlet: IfcOutlet,
  IfcOutletType: IfcOutletType,
  IfcOwnerHistory: IfcOwnerHistory,
  IfcParameterizedProfileDef: IfcParameterizedProfileDef,
  IfcPath: IfcPath,
  IfcPcurve: IfcPcurve,
  IfcPerformanceHistory: IfcPerformanceHistory,
  IfcPermeableCoveringProperties: IfcPermeableCoveringProperties,
  IfcPermit: IfcPermit,
  IfcPerson: IfcPerson,
  IfcPersonAndOrganization: IfcPersonAndOrganization,
  IfcPhysicalComplexQuantity: IfcPhysicalComplexQuantity,
  IfcPhysicalQuantity: IfcPhysicalQuantity,
  IfcPhysicalSimpleQuantity: IfcPhysicalSimpleQuantity,
  IfcPile: IfcPile,
  IfcPileType: IfcPileType,
  IfcPipeFitting: IfcPipeFitting,
  IfcPipeFittingType: IfcPipeFittingType,
  IfcPipeSegment: IfcPipeSegment,
  IfcPipeSegmentType: IfcPipeSegmentType,
  IfcPixelTexture: IfcPixelTexture,
  IfcPlacement: IfcPlacement,
  IfcPlanarBox: IfcPlanarBox,
  IfcPlanarExtent: IfcPlanarExtent,
  IfcPlane: IfcPlane,
  IfcPlate: IfcPlate,
  IfcPlateStandardCase: IfcPlateStandardCase,
  IfcPlateType: IfcPlateType,
  IfcPoint: IfcPoint,
  IfcPointOnCurve: IfcPointOnCurve,
  IfcPointOnSurface: IfcPointOnSurface,
  IfcPolygonalBoundedHalfSpace: IfcPolygonalBoundedHalfSpace,
  IfcPolygonalFaceSet: IfcPolygonalFaceSet,
  IfcPolyline: IfcPolyline,
  IfcPolyLoop: IfcPolyLoop,
  IfcPort: IfcPort,
  IfcPostalAddress: IfcPostalAddress,
  IfcPreDefinedColour: IfcPreDefinedColour,
  IfcPreDefinedCurveFont: IfcPreDefinedCurveFont,
  IfcPreDefinedItem: IfcPreDefinedItem,
  IfcPreDefinedProperties: IfcPreDefinedProperties,
  IfcPreDefinedPropertySet: IfcPreDefinedPropertySet,
  IfcPreDefinedTextFont: IfcPreDefinedTextFont,
  IfcPresentationItem: IfcPresentationItem,
  IfcPresentationLayerAssignment: IfcPresentationLayerAssignment,
  IfcPresentationLayerWithStyle: IfcPresentationLayerWithStyle,
  IfcPresentationStyle: IfcPresentationStyle,
  IfcPresentationStyleAssignment: IfcPresentationStyleAssignment,
  IfcProcedure: IfcProcedure,
  IfcProcedureType: IfcProcedureType,
  IfcProcess: IfcProcess,
  IfcProduct: IfcProduct,
  IfcProductDefinitionShape: IfcProductDefinitionShape,
  IfcProductRepresentation: IfcProductRepresentation,
  IfcProfileDef: IfcProfileDef,
  IfcProfileProperties: IfcProfileProperties,
  IfcProject: IfcProject,
  IfcProjectedCRS: IfcProjectedCRS,
  IfcProjectionElement: IfcProjectionElement,
  IfcProjectLibrary: IfcProjectLibrary,
  IfcProjectOrder: IfcProjectOrder,
  IfcProperty: IfcProperty,
  IfcPropertyAbstraction: IfcPropertyAbstraction,
  IfcPropertyBoundedValue: IfcPropertyBoundedValue,
  IfcPropertyDefinition: IfcPropertyDefinition,
  IfcPropertyDependencyRelationship: IfcPropertyDependencyRelationship,
  IfcPropertyEnumeratedValue: IfcPropertyEnumeratedValue,
  IfcPropertyEnumeration: IfcPropertyEnumeration,
  IfcPropertyListValue: IfcPropertyListValue,
  IfcPropertyReferenceValue: IfcPropertyReferenceValue,
  IfcPropertySet: IfcPropertySet,
  IfcPropertySetDefinition: IfcPropertySetDefinition,
  IfcPropertySetTemplate: IfcPropertySetTemplate,
  IfcPropertySingleValue: IfcPropertySingleValue,
  IfcPropertyTableValue: IfcPropertyTableValue,
  IfcPropertyTemplate: IfcPropertyTemplate,
  IfcPropertyTemplateDefinition: IfcPropertyTemplateDefinition,
  IfcProtectiveDevice: IfcProtectiveDevice,
  IfcProtectiveDeviceTrippingUnit: IfcProtectiveDeviceTrippingUnit,
  IfcProtectiveDeviceTrippingUnitType: IfcProtectiveDeviceTrippingUnitType,
  IfcProtectiveDeviceType: IfcProtectiveDeviceType,
  IfcProxy: IfcProxy,
  IfcPump: IfcPump,
  IfcPumpType: IfcPumpType,
  IfcQuantityArea: IfcQuantityArea,
  IfcQuantityCount: IfcQuantityCount,
  IfcQuantityLength: IfcQuantityLength,
  IfcQuantitySet: IfcQuantitySet,
  IfcQuantityTime: IfcQuantityTime,
  IfcQuantityVolume: IfcQuantityVolume,
  IfcQuantityWeight: IfcQuantityWeight,
  IfcRailing: IfcRailing,
  IfcRailingType: IfcRailingType,
  IfcRamp: IfcRamp,
  IfcRampFlight: IfcRampFlight,
  IfcRampFlightType: IfcRampFlightType,
  IfcRampType: IfcRampType,
  IfcRationalBSplineCurveWithKnots: IfcRationalBSplineCurveWithKnots,
  IfcRationalBSplineSurfaceWithKnots: IfcRationalBSplineSurfaceWithKnots,
  IfcRectangleHollowProfileDef: IfcRectangleHollowProfileDef,
  IfcRectangleProfileDef: IfcRectangleProfileDef,
  IfcRectangularPyramid: IfcRectangularPyramid,
  IfcRectangularTrimmedSurface: IfcRectangularTrimmedSurface,
  IfcRecurrencePattern: IfcRecurrencePattern,
  IfcReference: IfcReference,
  IfcRegularTimeSeries: IfcRegularTimeSeries,
  IfcReinforcementBarProperties: IfcReinforcementBarProperties,
  IfcReinforcementDefinitionProperties: IfcReinforcementDefinitionProperties,
  IfcReinforcingBar: IfcReinforcingBar,
  IfcReinforcingBarType: IfcReinforcingBarType,
  IfcReinforcingElement: IfcReinforcingElement,
  IfcReinforcingElementType: IfcReinforcingElementType,
  IfcReinforcingMesh: IfcReinforcingMesh,
  IfcReinforcingMeshType: IfcReinforcingMeshType,
  IfcRelAggregates: IfcRelAggregates,
  IfcRelAssigns: IfcRelAssigns,
  IfcRelAssignsToActor: IfcRelAssignsToActor,
  IfcRelAssignsToControl: IfcRelAssignsToControl,
  IfcRelAssignsToGroup: IfcRelAssignsToGroup,
  IfcRelAssignsToGroupByFactor: IfcRelAssignsToGroupByFactor,
  IfcRelAssignsToProcess: IfcRelAssignsToProcess,
  IfcRelAssignsToProduct: IfcRelAssignsToProduct,
  IfcRelAssignsToResource: IfcRelAssignsToResource,
  IfcRelAssociates: IfcRelAssociates,
  IfcRelAssociatesApproval: IfcRelAssociatesApproval,
  IfcRelAssociatesClassification: IfcRelAssociatesClassification,
  IfcRelAssociatesConstraint: IfcRelAssociatesConstraint,
  IfcRelAssociatesDocument: IfcRelAssociatesDocument,
  IfcRelAssociatesLibrary: IfcRelAssociatesLibrary,
  IfcRelAssociatesMaterial: IfcRelAssociatesMaterial,
  IfcRelationship: IfcRelationship,
  IfcRelConnects: IfcRelConnects,
  IfcRelConnectsElements: IfcRelConnectsElements,
  IfcRelConnectsPathElements: IfcRelConnectsPathElements,
  IfcRelConnectsPorts: IfcRelConnectsPorts,
  IfcRelConnectsPortToElement: IfcRelConnectsPortToElement,
  IfcRelConnectsStructuralActivity: IfcRelConnectsStructuralActivity,
  IfcRelConnectsStructuralMember: IfcRelConnectsStructuralMember,
  IfcRelConnectsWithEccentricity: IfcRelConnectsWithEccentricity,
  IfcRelConnectsWithRealizingElements: IfcRelConnectsWithRealizingElements,
  IfcRelContainedInSpatialStructure: IfcRelContainedInSpatialStructure,
  IfcRelCoversBldgElements: IfcRelCoversBldgElements,
  IfcRelCoversSpaces: IfcRelCoversSpaces,
  IfcRelDeclares: IfcRelDeclares,
  IfcRelDecomposes: IfcRelDecomposes,
  IfcRelDefines: IfcRelDefines,
  IfcRelDefinesByObject: IfcRelDefinesByObject,
  IfcRelDefinesByProperties: IfcRelDefinesByProperties,
  IfcRelDefinesByTemplate: IfcRelDefinesByTemplate,
  IfcRelDefinesByType: IfcRelDefinesByType,
  IfcRelFillsElement: IfcRelFillsElement,
  IfcRelFlowControlElements: IfcRelFlowControlElements,
  IfcRelInterferesElements: IfcRelInterferesElements,
  IfcRelNests: IfcRelNests,
  IfcRelProjectsElement: IfcRelProjectsElement,
  IfcRelReferencedInSpatialStructure: IfcRelReferencedInSpatialStructure,
  IfcRelSequence: IfcRelSequence,
  IfcRelServicesBuildings: IfcRelServicesBuildings,
  IfcRelSpaceBoundary: IfcRelSpaceBoundary,
  IfcRelSpaceBoundary1stLevel: IfcRelSpaceBoundary1stLevel,
  IfcRelSpaceBoundary2ndLevel: IfcRelSpaceBoundary2ndLevel,
  IfcRelVoidsElement: IfcRelVoidsElement,
  IfcReparametrisedCompositeCurveSegment: IfcReparametrisedCompositeCurveSegment,
  IfcRepresentation: IfcRepresentation,
  IfcRepresentationContext: IfcRepresentationContext,
  IfcRepresentationItem: IfcRepresentationItem,
  IfcRepresentationMap: IfcRepresentationMap,
  IfcResource: IfcResource,
  IfcResourceApprovalRelationship: IfcResourceApprovalRelationship,
  IfcResourceConstraintRelationship: IfcResourceConstraintRelationship,
  IfcResourceLevelRelationship: IfcResourceLevelRelationship,
  IfcResourceTime: IfcResourceTime,
  IfcRevolvedAreaSolid: IfcRevolvedAreaSolid,
  IfcRevolvedAreaSolidTapered: IfcRevolvedAreaSolidTapered,
  IfcRightCircularCone: IfcRightCircularCone,
  IfcRightCircularCylinder: IfcRightCircularCylinder,
  IfcRoof: IfcRoof,
  IfcRoofType: IfcRoofType,
  IfcRoot: IfcRoot,
  IfcRoundedRectangleProfileDef: IfcRoundedRectangleProfileDef,
  IfcSanitaryTerminal: IfcSanitaryTerminal,
  IfcSanitaryTerminalType: IfcSanitaryTerminalType,
  IfcSchedulingTime: IfcSchedulingTime,
  IfcSeamCurve: IfcSeamCurve,
  IfcSectionedSpine: IfcSectionedSpine,
  IfcSectionProperties: IfcSectionProperties,
  IfcSectionReinforcementProperties: IfcSectionReinforcementProperties,
  IfcSensor: IfcSensor,
  IfcSensorType: IfcSensorType,
  IfcShadingDevice: IfcShadingDevice,
  IfcShadingDeviceType: IfcShadingDeviceType,
  IfcShapeAspect: IfcShapeAspect,
  IfcShapeModel: IfcShapeModel,
  IfcShapeRepresentation: IfcShapeRepresentation,
  IfcShellBasedSurfaceModel: IfcShellBasedSurfaceModel,
  IfcSimpleProperty: IfcSimpleProperty,
  IfcSimplePropertyTemplate: IfcSimplePropertyTemplate,
  IfcSite: IfcSite,
  IfcSIUnit: IfcSIUnit,
  IfcSlab: IfcSlab,
  IfcSlabElementedCase: IfcSlabElementedCase,
  IfcSlabStandardCase: IfcSlabStandardCase,
  IfcSlabType: IfcSlabType,
  IfcSlippageConnectionCondition: IfcSlippageConnectionCondition,
  IfcSolarDevice: IfcSolarDevice,
  IfcSolarDeviceType: IfcSolarDeviceType,
  IfcSolidModel: IfcSolidModel,
  IfcSpace: IfcSpace,
  IfcSpaceHeater: IfcSpaceHeater,
  IfcSpaceHeaterType: IfcSpaceHeaterType,
  IfcSpaceType: IfcSpaceType,
  IfcSpatialElement: IfcSpatialElement,
  IfcSpatialElementType: IfcSpatialElementType,
  IfcSpatialStructureElement: IfcSpatialStructureElement,
  IfcSpatialStructureElementType: IfcSpatialStructureElementType,
  IfcSpatialZone: IfcSpatialZone,
  IfcSpatialZoneType: IfcSpatialZoneType,
  IfcSphere: IfcSphere,
  IfcSphericalSurface: IfcSphericalSurface,
  IfcStackTerminal: IfcStackTerminal,
  IfcStackTerminalType: IfcStackTerminalType,
  IfcStair: IfcStair,
  IfcStairFlight: IfcStairFlight,
  IfcStairFlightType: IfcStairFlightType,
  IfcStairType: IfcStairType,
  IfcStructuralAction: IfcStructuralAction,
  IfcStructuralActivity: IfcStructuralActivity,
  IfcStructuralAnalysisModel: IfcStructuralAnalysisModel,
  IfcStructuralConnection: IfcStructuralConnection,
  IfcStructuralConnectionCondition: IfcStructuralConnectionCondition,
  IfcStructuralCurveAction: IfcStructuralCurveAction,
  IfcStructuralCurveConnection: IfcStructuralCurveConnection,
  IfcStructuralCurveMember: IfcStructuralCurveMember,
  IfcStructuralCurveMemberVarying: IfcStructuralCurveMemberVarying,
  IfcStructuralCurveReaction: IfcStructuralCurveReaction,
  IfcStructuralItem: IfcStructuralItem,
  IfcStructuralLinearAction: IfcStructuralLinearAction,
  IfcStructuralLoad: IfcStructuralLoad,
  IfcStructuralLoadCase: IfcStructuralLoadCase,
  IfcStructuralLoadConfiguration: IfcStructuralLoadConfiguration,
  IfcStructuralLoadGroup: IfcStructuralLoadGroup,
  IfcStructuralLoadLinearForce: IfcStructuralLoadLinearForce,
  IfcStructuralLoadOrResult: IfcStructuralLoadOrResult,
  IfcStructuralLoadPlanarForce: IfcStructuralLoadPlanarForce,
  IfcStructuralLoadSingleDisplacement: IfcStructuralLoadSingleDisplacement,
  IfcStructuralLoadSingleDisplacementDistortion: IfcStructuralLoadSingleDisplacementDistortion,
  IfcStructuralLoadSingleForce: IfcStructuralLoadSingleForce,
  IfcStructuralLoadSingleForceWarping: IfcStructuralLoadSingleForceWarping,
  IfcStructuralLoadStatic: IfcStructuralLoadStatic,
  IfcStructuralLoadTemperature: IfcStructuralLoadTemperature,
  IfcStructuralMember: IfcStructuralMember,
  IfcStructuralPlanarAction: IfcStructuralPlanarAction,
  IfcStructuralPointAction: IfcStructuralPointAction,
  IfcStructuralPointConnection: IfcStructuralPointConnection,
  IfcStructuralPointReaction: IfcStructuralPointReaction,
  IfcStructuralReaction: IfcStructuralReaction,
  IfcStructuralResultGroup: IfcStructuralResultGroup,
  IfcStructuralSurfaceAction: IfcStructuralSurfaceAction,
  IfcStructuralSurfaceConnection: IfcStructuralSurfaceConnection,
  IfcStructuralSurfaceMember: IfcStructuralSurfaceMember,
  IfcStructuralSurfaceMemberVarying: IfcStructuralSurfaceMemberVarying,
  IfcStructuralSurfaceReaction: IfcStructuralSurfaceReaction,
  IfcStyledItem: IfcStyledItem,
  IfcStyledRepresentation: IfcStyledRepresentation,
  IfcStyleModel: IfcStyleModel,
  IfcSubContractResource: IfcSubContractResource,
  IfcSubContractResourceType: IfcSubContractResourceType,
  IfcSubedge: IfcSubedge,
  IfcSurface: IfcSurface,
  IfcSurfaceCurve: IfcSurfaceCurve,
  IfcSurfaceCurveSweptAreaSolid: IfcSurfaceCurveSweptAreaSolid,
  IfcSurfaceFeature: IfcSurfaceFeature,
  IfcSurfaceOfLinearExtrusion: IfcSurfaceOfLinearExtrusion,
  IfcSurfaceOfRevolution: IfcSurfaceOfRevolution,
  IfcSurfaceReinforcementArea: IfcSurfaceReinforcementArea,
  IfcSurfaceStyle: IfcSurfaceStyle,
  IfcSurfaceStyleLighting: IfcSurfaceStyleLighting,
  IfcSurfaceStyleRefraction: IfcSurfaceStyleRefraction,
  IfcSurfaceStyleRendering: IfcSurfaceStyleRendering,
  IfcSurfaceStyleShading: IfcSurfaceStyleShading,
  IfcSurfaceStyleWithTextures: IfcSurfaceStyleWithTextures,
  IfcSurfaceTexture: IfcSurfaceTexture,
  IfcSweptAreaSolid: IfcSweptAreaSolid,
  IfcSweptDiskSolid: IfcSweptDiskSolid,
  IfcSweptDiskSolidPolygonal: IfcSweptDiskSolidPolygonal,
  IfcSweptSurface: IfcSweptSurface,
  IfcSwitchingDevice: IfcSwitchingDevice,
  IfcSwitchingDeviceType: IfcSwitchingDeviceType,
  IfcSystem: IfcSystem,
  IfcSystemFurnitureElement: IfcSystemFurnitureElement,
  IfcSystemFurnitureElementType: IfcSystemFurnitureElementType,
  IfcTable: IfcTable,
  IfcTableColumn: IfcTableColumn,
  IfcTableRow: IfcTableRow,
  IfcTank: IfcTank,
  IfcTankType: IfcTankType,
  IfcTask: IfcTask,
  IfcTaskTime: IfcTaskTime,
  IfcTaskTimeRecurring: IfcTaskTimeRecurring,
  IfcTaskType: IfcTaskType,
  IfcTelecomAddress: IfcTelecomAddress,
  IfcTendon: IfcTendon,
  IfcTendonAnchor: IfcTendonAnchor,
  IfcTendonAnchorType: IfcTendonAnchorType,
  IfcTendonType: IfcTendonType,
  IfcTessellatedFaceSet: IfcTessellatedFaceSet,
  IfcTessellatedItem: IfcTessellatedItem,
  IfcTextLiteral: IfcTextLiteral,
  IfcTextLiteralWithExtent: IfcTextLiteralWithExtent,
  IfcTextStyle: IfcTextStyle,
  IfcTextStyleFontModel: IfcTextStyleFontModel,
  IfcTextStyleForDefinedFont: IfcTextStyleForDefinedFont,
  IfcTextStyleTextModel: IfcTextStyleTextModel,
  IfcTextureCoordinate: IfcTextureCoordinate,
  IfcTextureCoordinateGenerator: IfcTextureCoordinateGenerator,
  IfcTextureMap: IfcTextureMap,
  IfcTextureVertex: IfcTextureVertex,
  IfcTextureVertexList: IfcTextureVertexList,
  IfcTimePeriod: IfcTimePeriod,
  IfcTimeSeries: IfcTimeSeries,
  IfcTimeSeriesValue: IfcTimeSeriesValue,
  IfcTopologicalRepresentationItem: IfcTopologicalRepresentationItem,
  IfcTopologyRepresentation: IfcTopologyRepresentation,
  IfcToroidalSurface: IfcToroidalSurface,
  IfcTransformer: IfcTransformer,
  IfcTransformerType: IfcTransformerType,
  IfcTransportElement: IfcTransportElement,
  IfcTransportElementType: IfcTransportElementType,
  IfcTrapeziumProfileDef: IfcTrapeziumProfileDef,
  IfcTriangulatedFaceSet: IfcTriangulatedFaceSet,
  IfcTrimmedCurve: IfcTrimmedCurve,
  IfcTShapeProfileDef: IfcTShapeProfileDef,
  IfcTubeBundle: IfcTubeBundle,
  IfcTubeBundleType: IfcTubeBundleType,
  IfcTypeObject: IfcTypeObject,
  IfcTypeProcess: IfcTypeProcess,
  IfcTypeProduct: IfcTypeProduct,
  IfcTypeResource: IfcTypeResource,
  IfcUnitaryControlElement: IfcUnitaryControlElement,
  IfcUnitaryControlElementType: IfcUnitaryControlElementType,
  IfcUnitaryEquipment: IfcUnitaryEquipment,
  IfcUnitaryEquipmentType: IfcUnitaryEquipmentType,
  IfcUnitAssignment: IfcUnitAssignment,
  IfcUShapeProfileDef: IfcUShapeProfileDef,
  IfcValve: IfcValve,
  IfcValveType: IfcValveType,
  IfcVector: IfcVector,
  IfcVertex: IfcVertex,
  IfcVertexLoop: IfcVertexLoop,
  IfcVertexPoint: IfcVertexPoint,
  IfcVibrationIsolator: IfcVibrationIsolator,
  IfcVibrationIsolatorType: IfcVibrationIsolatorType,
  IfcVirtualElement: IfcVirtualElement,
  IfcVirtualGridIntersection: IfcVirtualGridIntersection,
  IfcVoidingFeature: IfcVoidingFeature,
  IfcWall: IfcWall,
  IfcWallElementedCase: IfcWallElementedCase,
  IfcWallStandardCase: IfcWallStandardCase,
  IfcWallType: IfcWallType,
  IfcWasteTerminal: IfcWasteTerminal,
  IfcWasteTerminalType: IfcWasteTerminalType,
  IfcWindow: IfcWindow,
  IfcWindowLiningProperties: IfcWindowLiningProperties,
  IfcWindowPanelProperties: IfcWindowPanelProperties,
  IfcWindowStandardCase: IfcWindowStandardCase,
  IfcWindowStyle: IfcWindowStyle,
  IfcWindowType: IfcWindowType,
  IfcWorkCalendar: IfcWorkCalendar,
  IfcWorkControl: IfcWorkControl,
  IfcWorkPlan: IfcWorkPlan,
  IfcWorkSchedule: IfcWorkSchedule,
  IfcWorkTime: IfcWorkTime,
  IfcZone: IfcZone,
  IfcZShapeProfileDef: IfcZShapeProfileDef,
  typeNames: typeNames,
  typeCodes: typeCodes
};

/** @private */
function earcut(data, holeIndices, dim) {
  dim = dim || 2;
  var hasHoles = holeIndices && holeIndices.length,
    outerLen = hasHoles ? holeIndices[0] * dim : data.length,
    outerNode = linkedList(data, 0, outerLen, dim, true),
    triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev) return triangles;
  var minX, minY, maxX, maxY, x, y, invSize;
  if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

  // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
  if (data.length > 80 * dim) {
    minX = maxX = data[0];
    minY = maxY = data[1];
    for (var i = dim; i < outerLen; i += dim) {
      x = data[i];
      y = data[i + 1];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
    }

    // minX, minY and invSize are later used to transform coords into integers for z-order calculation
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 1 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
  return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
  var i, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  var p = start,
    again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;

  // interlink polygon nodes in z-order
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  var stop = ear,
    prev,
    next;

  // iterate through ears, slicing them one by one
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      // cut off the triangle
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);

      // skipping the next vertex leads to less sliver triangles
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;

    // if we looped through the whole remaining polygon and can't find any more ears
    if (ear === stop) {
      // try filtering points and slicing again
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

        // if this didn't work, try curing all small self-intersections locally
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

        // as a last resort, try splitting the remaining polygon into two
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
  var a = ear.prev,
    b = ear,
    c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

  // now make sure we don't have other points inside the potential ear
  var p = ear.next.next;
  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  var a = ear.prev,
    b = ear,
    c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

  // triangle bbox; min & max are calculated like this for speed
  var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
    minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
    maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
    maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;

  // z-order range for the current triangle bbox;
  var minZ = zOrder(minTX, minTY, minX, minY, invSize),
    maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  var p = ear.prevZ,
    n = ear.nextZ;

  // look for points inside the triangle in both directions
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }

  // look for remaining points in decreasing z-order
  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  }

  // look for remaining points in increasing z-order
  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
  var p = start;
  do {
    var a = p.prev,
      b = p.next.next;
    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim);

      // remove two nodes involved
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  // look for a valid diagonal that divides the polygon into two
  var a = start;
  do {
    var b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        // split the polygon in two by the diagonal
        var c = splitPolygon(a, b);

        // filter colinear points around the cuts
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);

        // run earcut on each half
        earcutLinked(a, triangles, dim, minX, minY, invSize);
        earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue = [],
    i,
    len,
    start,
    end,
    list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);

  // process holes from left to right
  for (i = 0; i < queue.length; i++) {
    eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    var b = splitPolygon(outerNode, hole);

    // filter collinear points around the cuts
    filterPoints(outerNode, outerNode.next);
    filterPoints(b, b.next);
  }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
  var p = outerNode,
    hx = hole.x,
    hy = hole.y,
    qx = -Infinity,
    m;

  // find a segment intersected by a ray from the hole's leftmost point to the left;
  // segment's endpoint with lesser x will be potential connection point
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        if (x === hx) {
          if (hy === p.y) return p;
          if (hy === p.next.y) return p.next;
        }
        m = p.x < p.next.x ? p : p.next;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m) return null;
  if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint

  // look for points inside the triangle of hole point, segment intersection and endpoint;
  // if there are no points found, we have a valid connection;
  // otherwise choose the point of the minimum angle with the ray as connection point

  var stop = m,
    mx = m.x,
    my = m.y,
    tanMin = Infinity,
    tan;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
  var p = start;
  do {
    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
  var i,
    p,
    q,
    e,
    tail,
    numMerges,
    pSize,
    qSize,
    inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e;else list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
  // coords are transformed into non-negative 15-bit integer range
  x = 32767 * (x - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x = (x | x << 8) & 0x00FF00FF;
  x = (x | x << 4) & 0x0F0F0F0F;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;
  y = (y | y << 8) & 0x00FF00FF;
  y = (y | y << 4) & 0x0F0F0F0F;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;
  return x | y << 1;
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
  var p = start,
    leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (
  // dones't intersect other edges
  locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (
  // locally visible
  area(a.prev, a, b.prev) || area(a, b.prev, b)) ||
  // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
  var o1 = sign(area(p1, q1, p2));
  var o2 = sign(area(p1, q1, q2));
  var o3 = sign(area(p2, q2, p1));
  var o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true; // general case

  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

  return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
  var p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);
  return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
  var p = a,
    inside = false,
    px = (a.x + b.x) / 2,
    py = (a.y + b.y) / 2;
  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
  var a2 = new Node(a.i, a.x, a.y),
    b2 = new Node(b.i, b.x, b.y),
    an = a.next,
    bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
  var p = new Node(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
  // vertex index in coordinates array
  this.i = i;

  // vertex coordinates
  this.x = x;
  this.y = y;

  // previous and next vertex nodes in a polygon ring
  this.prev = null;
  this.next = null;

  // z-order curve value
  this.z = null;

  // previous and next nodes in z-order
  this.prevZ = null;
  this.nextZ = null;

  // indicates whether this is a steiner point
  this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
  var hasHoles = holeIndices && holeIndices.length;
  var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
  if (hasHoles) {
    for (var i = 0, len = holeIndices.length; i < len; i++) {
      var start = holeIndices[i] * dim;
      var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      polygonArea -= Math.abs(signedArea(data, start, end, dim));
    }
  }
  var trianglesArea = 0;
  for (i = 0; i < triangles.length; i += 3) {
    var a = triangles[i] * dim;
    var b = triangles[i + 1] * dim;
    var c = triangles[i + 2] * dim;
    trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
  }
  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data, start, end, dim) {
  var sum = 0;
  for (var i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
  var dim = data[0][0].length,
    result = {
      vertices: [],
      holes: [],
      dimensions: dim
    },
    holeIndex = 0;
  for (var i = 0; i < data.length; i++) {
    for (var j = 0; j < data[i].length; j++) {
      for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
    }
    if (i > 0) {
      holeIndex += data[i - 1].length;
      result.holes.push(holeIndex);
    }
  }
  return result;
};

var tempVec2a = createVec2();
var tempVec3a$3 = createVec3();
var tempVec3b$4 = createVec3();
var tempVec3c$4 = createVec3();
/**
 * Loads CityJSON into a {@link @xeokit/scene!SceneModel | SceneModel} and/or a {@link @xeokit/data!DataModel | DataModel}.
 *
 * * Expects {@link @xeokit/scene!SceneModel.built | SceneModel.built} and {@link @xeokit/scene!SceneModel.destroyed | SceneModel.destroyed} to be ````false````
 * * Does not call {@link @xeokit/scene!SceneModel.build | SceneModel.build} - we call that ourselves, when we have finished building the SceneModel
 *
 * See {@link "@xeokit/cityjson"} for usage.
 *
 * @param params - Loading parameters.
 * @param params.fileData - CityJSON file data.
 * @param params.sceneModel - SceneModel to load into.
 * @param params.dataModel - DataModel to load into.
 * @param options - CityJSON loading options
 * @param options.rotateX - True to rotate the model about the X-axis. Default is false.
 * @returns {Promise} Resolves when CityJSON has been loaded into the SceneModel and/or DataModel.
 * @throws *{@link @xeokit/core!SDKError}*
 * * If the SceneModel has already been destroyed.
 * * If the SceneModel has already been built.
 * * If the DataModel has already been destroyed.
 * * If the DataModel has already been built.
 */
function loadCityJSON(params, options) {
  if (options === void 0) {
    options = {
      rotateX: false
    };
  }
  if (params.sceneModel) {
    if (params.sceneModel.destroyed) {
      return Promise.reject(new SDKError("SceneModel already destroyed"));
    }
    if (params.sceneModel.built) {
      return Promise.reject(new SDKError("SceneModel already built"));
    }
  }
  if (params.dataModel) {
    if (params.dataModel.destroyed) {
      return Promise.reject(new SDKError("DataModel already destroyed"));
    }
    if (params.dataModel.built) {
      return Promise.reject(new SDKError("DataModel already built"));
    }
  }
  var fileData = params.fileData;
  var ctx = {
    fileData: fileData,
    vertices: fileData.transform && params.sceneModel ? transformVertices(fileData.vertices, fileData.transform, options.rotateX) : fileData.vertices,
    sceneModel: params.sceneModel,
    dataModel: params.dataModel,
    nextId: 0
  };
  parseCityJSON(ctx);
  return Promise.resolve();
}
function transformVertices(vertices, transform, rotateX) {
  var transformedVertices = [];
  var scale = transform.scale || createVec3([1, 1, 1]);
  var translate = transform.translate || createVec3([0, 0, 0]);
  for (var i = 0, j = 0; i < vertices.length; i++, j += 3) {
    var x = vertices[i][0] * scale[0] + translate[0];
    var y = vertices[i][1] * scale[1] + translate[1];
    var z = vertices[i][2] * scale[2] + translate[2];
    if (rotateX) {
      transformedVertices.push([x, z, y]);
    } else {
      transformedVertices.push([x, y, z]);
    }
  }
  return transformedVertices;
}
function parseCityJSON(ctx) {
  var fileData = ctx.fileData;
  var cityObjects = fileData.CityObjects;
  for (var objectId in cityObjects) {
    parseCityObject(ctx, cityObjects[objectId], objectId);
  }
  if (ctx.dataModel) {
    for (var _objectId in cityObjects) {
      parseRelationship(ctx, cityObjects[_objectId], _objectId);
    }
  }
}
function parseCityObject(ctx, cityObject, objectId) {
  if (ctx.dataModel) {
    ctx.dataModel.createObject({
      id: objectId,
      name: cityObject.type + " : " + objectId,
      type: typeCodes$1[cityObject.type] | 0,
      parent: cityObject.parents ? cityObject.parents[0] : null
    });
  }
  if (ctx.sceneModel) {
    if (!(cityObject.geometry && cityObject.geometry.length > 0)) {
      return;
    }
    var meshIds = [];
    for (var i = 0, len = cityObject.geometry.length; i < len; i++) {
      var geometry = cityObject.geometry[i];
      var objectMaterial = void 0;
      var surfaceMaterials = void 0;
      var appearance = ctx.fileData.appearance;
      if (appearance) {
        var materials = appearance.materials;
        if (materials) {
          var geometryMaterial = geometry.material;
          if (geometryMaterial) {
            var themeIds = Object.keys(geometryMaterial);
            if (themeIds.length > 0) {
              var themeId = themeIds[0];
              var theme = geometryMaterial[themeId];
              if (theme.value !== undefined) {
                objectMaterial = materials[theme.value];
              } else {
                var values = theme.values;
                if (values) {
                  surfaceMaterials = [];
                  for (var j = 0, lenj = values.length; j < lenj; j++) {
                    var value = values[i];
                    var surfaceMaterial = materials[value];
                    surfaceMaterials.push(surfaceMaterial);
                  }
                }
              }
            }
          }
        }
      }
      if (surfaceMaterials) {
        parseGeometrySurfacesWithOwnMaterials(ctx, geometry, surfaceMaterials, meshIds);
      } else {
        parseGeometrySurfacesWithSharedMaterial(ctx, geometry, objectMaterial, meshIds);
      }
    }
    if (meshIds.length > 0) {
      ctx.sceneModel.createObject({
        id: objectId,
        meshIds: meshIds
      });
    }
  }
}
function parseRelationship(ctx, cityObject, objectId) {
  if (cityObject.parents) {
    ctx.dataModel.createRelationship({
      relatingObjectId: cityObject.parents[0],
      relatedObjectId: objectId,
      type: BasicAggregation$1
    });
  }
}
function parseGeometrySurfacesWithOwnMaterials(ctx, geometry, surfaceMaterials, meshIds) {
  var geomType = geometry.type;
  switch (geomType) {
    case "MultiPoint":
      break;
    case "MultiLineString":
      break;
    case "MultiSurface":
    case "CompositeSurface":
      var surfaces = geometry.boundaries;
      parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, surfaces, meshIds);
      break;
    case "Solid":
      var shells = geometry.boundaries;
      for (var j = 0; j < shells.length; j++) {
        var _surfaces = shells[j];
        parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, _surfaces, meshIds);
      }
      break;
    case "MultiSolid":
    case "CompositeSolid":
      var solids = geometry.boundaries;
      for (var _j = 0; _j < solids.length; _j++) {
        for (var k = 0; k < solids[_j].length; k++) {
          var _surfaces2 = solids[_j][k];
          parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, _surfaces2, meshIds);
        }
      }
      break;
  }
}
function parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, surfaces, meshIds) {
  var vertices = ctx.vertices;
  var sceneModel = ctx.sceneModel;
  for (var i = 0; i < surfaces.length; i++) {
    var surface = surfaces[i];
    var surfaceMaterial = surfaceMaterials[i] || {
      diffuseColor: [0.8, 0.8, 0.8],
      transparency: 1.0
    };
    var face = [];
    var holes = [];
    var sharedIndices = [];
    var geometryCfg = {
      positions: [],
      indices: []
    };
    for (var j = 0; j < surface.length; j++) {
      if (face.length > 0) {
        holes.push(face.length);
      }
      var newFace = extractLocalIndices(ctx, surface[j], sharedIndices, geometryCfg);
      face.push.apply(face, newFace);
    }
    if (face.length === 3) {
      // Triangle
      geometryCfg.indices.push(face[0]);
      geometryCfg.indices.push(face[1]);
      geometryCfg.indices.push(face[2]);
    } else if (face.length > 3) {
      // Polygon
      // Prepare to triangulate
      var pList = [];
      for (var k = 0; k < face.length; k++) {
        pList.push({
          x: vertices[sharedIndices[face[k]]][0],
          y: vertices[sharedIndices[face[k]]][1],
          z: vertices[sharedIndices[face[k]]][2]
        });
      }
      var normal = getNormalOfPositions(pList, createVec3());
      // Convert to 2D
      var pv = [];
      for (var _k = 0; _k < pList.length; _k++) {
        to2D(pList[_k], normal, tempVec2a);
        pv.unshift(tempVec2a[0]);
        pv.unshift(tempVec2a[1]);
      }
      // Triangulate
      var tr = earcut(pv, holes, 2);
      // Create triangles
      for (var _k2 = 0; _k2 < tr.length; _k2 += 3) {
        geometryCfg.indices.unshift(face[tr[_k2]]);
        geometryCfg.indices.unshift(face[tr[_k2 + 1]]);
        geometryCfg.indices.unshift(face[tr[_k2 + 2]]);
      }
    }
    var geometryId = "" + ctx.nextId++;
    sceneModel.createGeometry({
      id: geometryId,
      primitive: TrianglesPrimitive,
      positions: geometryCfg.positions,
      indices: geometryCfg.indices
    });
    var meshId = "" + ctx.nextId++;
    sceneModel.createMesh({
      id: meshId,
      geometryId: geometryId,
      color: surfaceMaterial && surfaceMaterial.diffuseColor ? surfaceMaterial.diffuseColor : [0.8, 0.8, 0.8],
      opacity: surfaceMaterial && surfaceMaterial.transparency !== undefined ? 1.0 - surfaceMaterial.transparency : 1.0
    });
    meshIds.push(meshId);
  }
}
function parseGeometrySurfacesWithSharedMaterial(ctx, geometry, objectMaterial, meshIds) {
  var sceneModel = ctx.sceneModel;
  var sharedIndices = [];
  var geometryCfg = {
    positions: [],
    indices: []
  };
  var geomType = geometry.type;
  switch (geomType) {
    case "MultiPoint":
      break;
    case "MultiLineString":
      break;
    case "MultiSurface":
    case "CompositeSurface":
      var surfaces = geometry.boundaries;
      parseSurfacesWithSharedMaterial(ctx, surfaces, sharedIndices, geometryCfg);
      break;
    case "Solid":
      var shells = geometry.boundaries;
      for (var j = 0; j < shells.length; j++) {
        var _surfaces3 = shells[j];
        parseSurfacesWithSharedMaterial(ctx, _surfaces3, sharedIndices, geometryCfg);
      }
      break;
    case "MultiSolid":
    case "CompositeSolid":
      var solids = geometry.boundaries;
      for (var _j2 = 0; _j2 < solids.length; _j2++) {
        for (var k = 0; k < solids[_j2].length; k++) {
          var _surfaces4 = solids[_j2][k];
          parseSurfacesWithSharedMaterial(ctx, _surfaces4, sharedIndices, geometryCfg);
        }
      }
      break;
  }
  if (geometryCfg.positions.length > 0 && geometryCfg.indices.length > 0) {
    var geometryId = "" + ctx.nextId++;
    sceneModel.createGeometry({
      id: geometryId,
      primitive: TrianglesPrimitive,
      positions: geometryCfg.positions,
      indices: geometryCfg.indices
    });
    var meshId = "" + ctx.nextId++;
    sceneModel.createMesh({
      id: meshId,
      geometryId: geometryId,
      color: objectMaterial && objectMaterial.diffuseColor ? objectMaterial.diffuseColor : [0.8, 0.8, 0.8],
      opacity: 1.0
    });
    meshIds.push(meshId);
  }
}
function parseSurfacesWithSharedMaterial(ctx, surfaces, sharedIndices, primitiveCfg) {
  var vertices = ctx.vertices;
  for (var i = 0; i < surfaces.length; i++) {
    var boundary = [];
    var holes = [];
    for (var j = 0; j < surfaces[i].length; j++) {
      if (boundary.length > 0) {
        holes.push(boundary.length);
      }
      var newBoundary = extractLocalIndices(ctx, surfaces[i][j], sharedIndices, primitiveCfg);
      boundary.push.apply(boundary, newBoundary);
    }
    if (boundary.length === 3) {
      // Triangle
      primitiveCfg.indices.push(boundary[0]);
      primitiveCfg.indices.push(boundary[1]);
      primitiveCfg.indices.push(boundary[2]);
    } else if (boundary.length > 3) {
      // Polygon
      var pList = [];
      for (var k = 0; k < boundary.length; k++) {
        pList.push({
          x: vertices[sharedIndices[boundary[k]]][0],
          y: vertices[sharedIndices[boundary[k]]][1],
          z: vertices[sharedIndices[boundary[k]]][2]
        });
      }
      var normal = getNormalOfPositions(pList, createVec3());
      var pv = [];
      for (var _k3 = 0; _k3 < pList.length; _k3++) {
        to2D(pList[_k3], normal, tempVec2a);
        pv.unshift(tempVec2a[0]);
        pv.unshift(tempVec2a[1]);
      }
      var tr = earcut(pv, holes, 2);
      for (var _k4 = 0; _k4 < tr.length; _k4 += 3) {
        primitiveCfg.indices.unshift(boundary[tr[_k4]]);
        primitiveCfg.indices.unshift(boundary[tr[_k4 + 1]]);
        primitiveCfg.indices.unshift(boundary[tr[_k4 + 2]]);
      }
    }
  }
}
function extractLocalIndices(ctx, boundary, sharedIndices, geometryCfg) {
  var vertices = ctx.vertices;
  var newBoundary = [];
  for (var i = 0, len = boundary.length; i < len; i++) {
    var index = boundary[i];
    if (sharedIndices.includes(index)) {
      var vertexIndex = sharedIndices.indexOf(index);
      newBoundary.push(vertexIndex);
    } else {
      geometryCfg.positions.push(vertices[index][0]);
      geometryCfg.positions.push(vertices[index][1]);
      geometryCfg.positions.push(vertices[index][2]);
      newBoundary.push(sharedIndices.length);
      sharedIndices.push(index);
    }
  }
  return newBoundary;
}
function getNormalOfPositions(positions, normal) {
  for (var i = 0; i < positions.length; i++) {
    var nexti = i + 1;
    if (nexti === positions.length) {
      nexti = 0;
    }
    normal[0] += (positions[i].y - positions[nexti].y) * (positions[i].z + positions[nexti].z);
    normal[1] += (positions[i].z - positions[nexti].z) * (positions[i].x + positions[nexti].x);
    normal[2] += (positions[i].x - positions[nexti].x) * (positions[i].y + positions[nexti].y);
  }
  return normalizeVec3(normal);
}
function to2D(_p, _n, re) {
  var p = tempVec3a$3;
  var n = tempVec3b$4;
  var x3 = tempVec3c$4;
  p[0] = _p.x;
  p[1] = _p.y;
  p[2] = _p.z;
  n[0] = _n.x;
  n[1] = _n.y;
  n[2] = _n.z;
  x3[0] = 1.1;
  x3[1] = 1.1;
  x3[2] = 1.1;
  var dist = lenVec3(subVec3(x3, n));
  if (dist < 0.01) {
    x3[0] += 1.0;
    x3[1] += 2.0;
    x3[2] += 3.0;
  }
  var dot = dotVec3(x3, n);
  var tmp2 = mulVec3Scalar(n, dot, createVec3());
  x3[0] -= tmp2[0];
  x3[1] -= tmp2[1];
  x3[2] -= tmp2[2];
  normalizeVec3(x3);
  var y3 = cross3Vec3(n, x3, createVec3());
  var x = dotVec3(p, x3);
  var y = dotVec3(p, y3);
  re[0] = x;
  re[1] = y;
}

/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2Fcityjson.svg)](https://badge.fury.io/js/%40xeokit%2Fcityjson)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/cityjson/badge)](https://www.jsdelivr.com/package/npm/@xeokit/cityjson)
 *
 * <img style="padding:0px; padding-top:20px; padding-bottom:30px;" src="media://images/example_cityJSON.png"/>
 *
 * # xeokit CityJSON Importer
 *
 * ---
 *
 * ### *Import 3D urban models from CityJSON format*
 *
 * ---
 *
 * The xeokit SDK allows us to import 3D urban models from [CityJSON](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#cityjson), a JSON-based
 * file format specifically designed for lightweight, user-friendly, and human-readable
 * storage and sharing of 3D models. CityJSON can represent both basic geometric shapes and intricate objects such as
 * buildings and trees, offering a simple alternative to other formats like CityGML.
 *
 * To import a CityJSON model into xeokit, simply use the {@link @xeokit/cityjson!loadCityJSON} function, which will load
 * the file into both a {@link @xeokit/scene!SceneModel | SceneModel} and a {@link @xeokit/data!DataModel | DataModel}.
 *
 * <br>
 *
 * [![](https://mermaid.ink/img/pako:eNqNUsFuwjAM_ZXKp00CabtWqIeN0wQD0WsupnFHpjSpnORQIf59SUMHCImtl9TPznvPjo_QWElQQqPRuaXCL8ZOGGGkYmq8sqZY7VI85ou6IUPreEMXR2GK-CmZT7v_jvUuBw0TetqM0NNzxvZBaTkFkpxnO6TwlNgn_iV6HOkfsfdse2I_1PRIL2M70pi6cAfV32a2F5Z_WcwGVxblu_LDR7353GKclZsGsVj0KSZPXFUZQmYc3kLbEmfA_Y7vrDG1e6OhrzQu7G0w43sk8rH43oqAFwHzeSXgVUB9pfVH6fJi41p7St_fhhl0xB0qGTdndCjAH6gjAWX8ldRi0F5AdBpLMXhbD6aB0nOgGYQ-9k3nXYOyRe0iSlJ5y-vzNqbj9AOT7uJt?type=png)](https://mermaid.live/edit#pako:eNqNUsFuwjAM_ZXKp00CabtWqIeN0wQD0WsupnFHpjSpnORQIf59SUMHCImtl9TPznvPjo_QWElQQqPRuaXCL8ZOGGGkYmq8sqZY7VI85ou6IUPreEMXR2GK-CmZT7v_jvUuBw0TetqM0NNzxvZBaTkFkpxnO6TwlNgn_iV6HOkfsfdse2I_1PRIL2M70pi6cAfV32a2F5Z_WcwGVxblu_LDR7353GKclZsGsVj0KSZPXFUZQmYc3kLbEmfA_Y7vrDG1e6OhrzQu7G0w43sk8rH43oqAFwHzeSXgVUB9pfVH6fJi41p7St_fhhl0xB0qGTdndCjAH6gjAWX8ldRi0F5AdBpLMXhbD6aB0nOgGYQ-9k3nXYOyRe0iSlJ5y-vzNqbj9AOT7uJt)
 *
 * <br>
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/cityjson
 * ````
 *
 * ## Usage
 *
 * In the example below, we'll import a CityJSON file into a {@link @xeokit/scene!SceneModel | SceneModel}
 * and a {@link @xeokit/data!DataModel | DataModel}. The {@link @xeokit/core!SDKError} class
 * is used to handle errors that may occur during the process:
 *
 * ````javascript
 * import { Scene } from "@xeokit/scene";
 * import { Data } from "@xeokit/data";
 * import { loadCityJSON } from "@xeokit/cityjson";
 *
 * const scene = new Scene();
 * const data = new Data();
 * const dataModel = data.createModel({ id: "myModel" });
 * const sceneModel = scene.createModel({ id: "myModel" });
 *
 * if (dataModel instanceof SDKError) {
 *      console.error(dataModel.message);
 * } else if (sceneModel instanceof SDKError) {
 *      console.error(dataModel.message);
 * } else {
 *      fetch("myModel.json")
 *          .then(response => response.json())
 *          .then(jsonStr => {
 *
 *              const fileData = JSON.parse(jsonStr);
 *
 *              loadCityJSON({
 *                  fileData,
 *                  sceneModel,
 *                  dataModel,
 *                  rotateX: true
 *              }).then(() => {
 *                  sceneModel.build();
 *                  dataModel.build();
 *              }).catch((sdkError)=>{
 *                  console.error(sdkError.message);
 *              });
 * }
 * ````
 *
 * @module @xeokit/cityjson
 */

var index$7 = {
  __proto__: null,
  loadCityJSON: loadCityJSON
};

/**
 * Loads .BIM into a {@link @xeokit/scene!SceneModel | SceneModel} and/or a {@link @xeokit/data!DataModel | DataModel}.
 *
 * * Expects {@link @xeokit/scene!SceneModel.built | SceneModel.built} and {@link @xeokit/scene!SceneModel.destroyed | SceneModel.destroyed} to be ````false````
 * * Does not call {@link @xeokit/scene!SceneModel.build | SceneModel.build} - we call that ourselves, when we have finished building the SceneModel
 *
 * See {@link "@xeokit/dotbim"} for usage.
 *
 * @param params - Loading parameters.
 * @param params.fileData - .BIM file data.
 * @param params.sceneModel - SceneModel to load into.
 * @param params.dataModel - DataModel to load into.
 * @param options - .BIM loading options
 * @param options.error - Callback to log any non-fatal errors that occur while loading.
 * @returns {Promise} Resolves when .BIM has been loaded into the SceneModel and/or DataModel.
 * @throws *{@link @xeokit/core!SDKError}*
 * * If the SceneModel has already been destroyed.
 * * If the SceneModel has already been built.
 * * If the DataModel has already been destroyed.
 * * If the DataModel has already been built.
 */
function loadDotBIM(params, options) {
  if (options === void 0) {
    options = {};
  }
  return new Promise(function (resolve, reject) {
    if (params.sceneModel.destroyed) {
      throw new SDKError("SceneModel already destroyed");
    }
    if (params.sceneModel.built) {
      throw new SDKError("SceneModel already built");
    }
    if (params.dataModel) {
      if (params.dataModel.destroyed) {
        throw new SDKError("DataModel already destroyed");
      }
      if (params.dataModel.built) {
        throw new SDKError("DataModel already built");
      }
    }
    var fileData = params.fileData;
    var ctx = {
      fileData: fileData,
      sceneModel: params.sceneModel,
      dataModel: params.dataModel,
      nextId: 0,
      error: options.error || function (errMsg) {}
    };
    parseDotBIM(ctx);
    resolve();
  });
}
function parseDotBIM(ctx) {
  var fileData = ctx.fileData;
  var meshes = fileData.meshes;
  for (var i = 0, len = meshes.length; i < len; i++) {
    var mesh = meshes[i];
    var geometry = ctx.sceneModel.createGeometry({
      id: mesh.mesh_id,
      primitive: TrianglesPrimitive,
      positions: mesh.coordinates,
      indices: mesh.indices
    });
    if (geometry instanceof SDKError) {
      ctx.error("[SceneModel.createGeometry]: " + geometry.message);
    }
  }
  var elements = fileData.elements;
  for (var _i = 0, _len = elements.length; _i < _len; _i++) {
    var element = elements[_i];
    var objectId = "" + element.guid;
    if (ctx.sceneModel) {
      var geometryId = element.mesh_id;
      var meshId = objectId + "-mesh-" + _i;
      var _mesh = ctx.sceneModel.createMesh({
        id: meshId,
        geometryId: geometryId,
        baseColor: element.color
      });
      if (_mesh instanceof SDKError) {
        ctx.error("[SceneModel.createMesh]: " + _mesh.message);
        continue;
      }
      var sceneObject = ctx.sceneModel.createObject({
        id: objectId,
        meshIds: [meshId]
      });
      if (sceneObject instanceof SDKError) {
        ctx.error("[SceneModel.createObject]: " + sceneObject.message);
        continue;
      }
    }
    if (ctx.dataModel) {
      if (!ctx.dataModel.objects[element.guid]) {
        var dataObject = ctx.dataModel.createObject({
          id: objectId,
          type: element.type
        });
        if (dataObject instanceof SDKError) {
          ctx.error("[SceneModel.createObject]: " + dataObject.message);
        }
      }
    }
  }
}

/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2Fdotbim.svg)](https://badge.fury.io/js/%40xeokit%2Fdotbim)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/dotbim/badge)](https://www.jsdelivr.com/package/npm/@xeokit/dotbim)
 *
 * <img style="padding:0px; padding-top:20px; padding-bottom:30px; width: 180px;" src="media://images/dotbim-logo.png"/>
 *
 * # xeokit .BIM Importer
 *
 * ---
 *
 * ### *Import building models from the open, free and simple .BIM file format*
 *
 * ---
 *
 * The xeokit SDK allows us to import 3D models from [.BIM](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#dotbim), a JSON-based
 * file format specifically designed for lightweight, user-friendly, and human-readable storage and sharing of 3D BIM models.
 *
 * .BIM is an open-source and minimalist file format for BIM that's built to be easy to read and write. Essentially, .BIM
 * is a transfer format that contains triangulated meshes with a dictionary of information attached to them.
 *
 * To import a .BIM model into xeokit, simply use the {@link loadDotBIM} function, which will load the file into both
 * a {@link @xeokit/scene!SceneModel | SceneModel} and a {@link @xeokit/data!DataModel | DataModel}.
 *
 * <br>
 *
 * [![](https://mermaid.ink/img/pako:eNqNUk1vgkAQ_StkTm2CRpDvGA-GSxNNjdyavazsUGmAJbtLUmr8711ApHow5bLMm9n33szOGVLOECJICyplnNNPQUtSkYrlAlOV88rYHrq4zxtJihXu9I3COJPK0F_OhpMfv3S9HIJUIFX43kMvrwN2bPKCjQFDqQRvu_DSsY_8MVW0p3_GXgteo1Btgs_0BuyABe26kKe8vs_sJ5Z_WRwMbjllMVebt92e6knJcQyrVd3FqFCs1wNEhaDtpskyFAMgb8O7KozN3ikUN4WJO2uq_i066r700QaBBYHZbE3AIpD80XlaGE8GJtUx-XgTTChRlDRnelt6ZwTUCUskEOlfhhltCkVAO9SltFE8aasUIiUaNKGpdbd43S-IMlpIjSLLFRe76wZ2hwk1rSA6wzdEtmfNLct3Lc8OlqHnha4JrYbtuRP6nuuElm97wdK9mPDDuWZdzAPbcxzPDh0_cFzHDXu6jz7Z-bj8Aq5V9Qs?type=png)](https://mermaid.live/edit#pako:eNqNUk1vgkAQ_StkTm2CRpDvGA-GSxNNjdyavazsUGmAJbtLUmr8711ApHow5bLMm9n33szOGVLOECJICyplnNNPQUtSkYrlAlOV88rYHrq4zxtJihXu9I3COJPK0F_OhpMfv3S9HIJUIFX43kMvrwN2bPKCjQFDqQRvu_DSsY_8MVW0p3_GXgteo1Btgs_0BuyABe26kKe8vs_sJ5Z_WRwMbjllMVebt92e6knJcQyrVd3FqFCs1wNEhaDtpskyFAMgb8O7KozN3ikUN4WJO2uq_i066r700QaBBYHZbE3AIpD80XlaGE8GJtUx-XgTTChRlDRnelt6ZwTUCUskEOlfhhltCkVAO9SltFE8aasUIiUaNKGpdbd43S-IMlpIjSLLFRe76wZ2hwk1rSA6wzdEtmfNLct3Lc8OlqHnha4JrYbtuRP6nuuElm97wdK9mPDDuWZdzAPbcxzPDh0_cFzHDXu6jz7Z-bj8Aq5V9Qs)
 *
 * <br>
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/dotbim
 * ````
 *
 * ## Usage
 *
 * In the example below, we'll import a .BIM file into a {@link @xeokit/scene!SceneModel | SceneModel}
 * and a {@link @xeokit/data!DataModel | DataModel}. The {@link @xeokit/core!SDKError} class
 * is used to handle errors that may occur during the process:
 *
 * ````javascript
 * import { Scene } from "@xeokit/scene";
 * import { Data } from "@xeokit/data";
 * import { loadDotBIM } from "@xeokit/dotbim";
 *
 * const scene = new Scene();
 * const data = new Data();
 * const dataModel = data.createModel({ id: "myModel" });
 * const sceneModel = scene.createModel({ id: "myModel" });
 *
 * if (dataModel instanceof SDKError) {
 *      console.error(dataModel.message);
 * } else if (sceneModel instanceof SDKError) {
 *      console.error(dataModel.message);
 * } else {
 *      fetch("myModel.bim")
 *          .then(response => response.json())
 *          .then(data => {
 *
 *              const fileData = JSON.parse(data);
 *
 *              return loadDotBIM({
 *                  data: fileData,
 *                  sceneModel,
 *                  dataModel
 *              });
 *
 *          }).then(() => {
 *              sceneModel.build();
 *              dataModel.build();
 *          });
 * }
 * ````
 *
 * @module @xeokit/dotbim
 */

var index$6 = {
  __proto__: null,
  loadDotBIM: loadDotBIM
};

/**
 * Represents and controls the visual state of a {@link @xeokit/scene!SceneModel | SceneObject} in
 * a {@link @xeokit/viewer!View |View's} canvas.
 *
 * ## Summary
 *
 * * Stored in {@link View.objects | View.objects} and {@link @xeokit/view!ViewLayer.objects | ViewLayer.objects}
 * * Viewer automatically creates one of these in each existing {@link @xeokit/viewer!View} for each {@link @xeokit/scene!SceneModel | SceneObject} created
 * * {@link @xeokit/scene!SceneObject.layerId | SceneObject.layerId} determines which of the View's {@link @xeokit/view!ViewLayer | ViewLayers} to put the ViewObject in
 *
 * ## Overview
 *
 * Every View automatically maintains within itself a ViewObject for each {@link @xeokit/scene!SceneModel | SceneObject} that exists in the {@link @xeokit/viewer!Viewer}.
 *
 * Whenever we create a SceneObject, each View will automatically create a corresponding ViewObject within itself. When
 * we destroy a SceneObject, each View will automatically destroy its corresponding ViewObject. The ViewObjects in a View
 * are therefore a manifest of the ViewerObjects in the View.
 *
 * {@link @xeokit/viewer!ViewLayer}.
 */
var _rendererViewObject = /*#__PURE__*/_classPrivateFieldLooseKey("rendererViewObject");
var _state$f = /*#__PURE__*/_classPrivateFieldLooseKey("state");
var ViewObject = /*#__PURE__*/function () {
  /**
   * @private
   */
  function ViewObject(layer, sceneObject, rendererViewObject) {
    /**
     * Unique ID of this ViewObject within {@link @xeokit/view!ViewLayer.objects}.
     */
    this.id = void 0;
    /**
     * The ViewLayer to which this ViewObject belongs.
     */
    this.layer = void 0;
    /**
     * The corresponding {@link @xeokit/scene!SceneObject}.
     */
    this.sceneObject = void 0;
    /**
     * The corresponding {@link RendererViewObject}.
     * @internal
     */
    Object.defineProperty(this, _rendererViewObject, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _state$f, {
      writable: true,
      value: void 0
    });
    this.id = sceneObject.id;
    this.layer = layer;
    this.sceneObject = sceneObject;
    _classPrivateFieldLooseBase(this, _rendererViewObject)[_rendererViewObject] = rendererViewObject;
    _classPrivateFieldLooseBase(this, _state$f)[_state$f] = {
      visible: true,
      culled: false,
      pickable: true,
      clippable: true,
      collidable: true,
      xrayed: false,
      selected: false,
      highlighted: false,
      edges: false,
      colorize: new Float32Array(4),
      colorized: false,
      opacityUpdated: false
    };
    _classPrivateFieldLooseBase(this, _rendererViewObject)[_rendererViewObject].setVisible(this.layer.view.viewIndex, _classPrivateFieldLooseBase(this, _state$f)[_state$f].visible);
    this.layer.objectVisibilityUpdated(this, _classPrivateFieldLooseBase(this, _state$f)[_state$f].visible, true);
  }
  /**
   * Gets the World-space axis-aligned 3D boundary of this ViewObject.
   */
  var _proto = ViewObject.prototype;
  /**
   * @private
   */
  _proto._destroy = function _destroy() {
    // Called by ViewLayer#destroyViewObjects
    if (_classPrivateFieldLooseBase(this, _state$f)[_state$f].visible) {
      this.layer.objectVisibilityUpdated(this, false, false);
    }
    if (_classPrivateFieldLooseBase(this, _state$f)[_state$f].xrayed) {
      this.layer.objectXRayedUpdated(this, false);
    }
    if (_classPrivateFieldLooseBase(this, _state$f)[_state$f].selected) {
      this.layer.objectSelectedUpdated(this, false);
    }
    if (_classPrivateFieldLooseBase(this, _state$f)[_state$f].highlighted) {
      this.layer.objectHighlightedUpdated(this, false);
    }
    if (_classPrivateFieldLooseBase(this, _state$f)[_state$f].colorized) {
      this.layer.objectColorizeUpdated(this, false);
    }
    if (_classPrivateFieldLooseBase(this, _state$f)[_state$f].opacityUpdated) {
      this.layer.objectOpacityUpdated(this, false);
    }
    this.layer.redraw();
  };
  _createClass(ViewObject, [{
    key: "aabb",
    get: function get() {
      return this.sceneObject.aabb;
    }
    /**
     * Gets if this ViewObject is visible.
     *
     * * When {@link @xeokit/viewer!ViewObject.visible} is ````true```` the ViewObject will be registered by {@link @xeokit/viewer!ViewObject.id} in {@link @xeokit/view!ViewLayer.visibleObjects}.
     * * Each ViewObject is only rendered when {@link @xeokit/viewer!ViewObject.visible} is ````true```` and {@link @xeokit/viewer!ViewObject.culled} is ````false````.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsVisible} to batch-update the visibility of ViewObjects, which fires a single event for the batch.
     */
  }, {
    key: "visible",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$f)[_state$f].visible;
    }
    /**
     * Sets if this ViewObject is visible.
     *
     * * When {@link @xeokit/viewer!ViewObject.visible} is ````true```` the ViewObject will be registered by {@link @xeokit/viewer!ViewObject.id} in {@link @xeokit/view!ViewLayer.visibleObjects}.
     * * Each ViewObject is only rendered when {@link @xeokit/viewer!ViewObject.visible} is ````true```` and {@link @xeokit/viewer!ViewObject.culled} is ````false````.
     * * Fires an "objectVisibility" event on associated {@link @xeokit/viewer!ViewLayer}s.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsVisible} to batch-update the visibility of ViewObjects, which fires a single event for the batch.
     */,
    set: function set(visible) {
      if (visible === _classPrivateFieldLooseBase(this, _state$f)[_state$f].visible) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$f)[_state$f].visible = visible;
      var result = _classPrivateFieldLooseBase(this, _rendererViewObject)[_rendererViewObject].setVisible(this.layer.view.viewIndex, visible);
      if (result instanceof SDKError) {
        throw result;
      }
      this.layer.objectVisibilityUpdated(this, visible, true);
      this.layer.redraw();
    }
    /**
     * Gets if this ViewObject is X-rayed.
     *
     * * When {@link @xeokit/viewer!ViewObject.xrayed} is ````true```` the ViewObject will be registered by {@link @xeokit/viewer!ViewObject.id} in {@link @xeokit/view!ViewLayer.xrayedObjects | ViewLayer.xrayedObjects}.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsXRayed} to batch-update the X-rayed state of ViewObjects.
     */
  }, {
    key: "xrayed",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$f)[_state$f].xrayed;
    }
    /**
     * Sets if this ViewObject is X-rayed.
     *
     * * When {@link @xeokit/viewer!ViewObject.xrayed} is ````true```` the ViewObject will be registered by {@link @xeokit/viewer!ViewObject.id} in {@link @xeokit/view!ViewLayer.xrayedObjects | ViewLayer.xrayedObjects}.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsXRayed} to batch-update the X-rayed state of ViewObjects.
     */,
    set: function set(xrayed) {
      if (_classPrivateFieldLooseBase(this, _state$f)[_state$f].xrayed === xrayed) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$f)[_state$f].xrayed = xrayed;
      var result = _classPrivateFieldLooseBase(this, _rendererViewObject)[_rendererViewObject].setXRayed(this.layer.view.viewIndex, xrayed);
      if (result instanceof SDKError) {
        throw result;
      }
      this.layer.objectXRayedUpdated(this, xrayed);
      this.layer.redraw();
    }
    /**
     * Gets if this ViewObject shows edges.
     */
  }, {
    key: "edges",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$f)[_state$f].edges;
    }
    /**
     * Sets if this ViewObject shows edges.
     */,
    set: function set(edges) {
      if (_classPrivateFieldLooseBase(this, _state$f)[_state$f].edges === edges) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$f)[_state$f].edges = edges;
      var result = _classPrivateFieldLooseBase(this, _rendererViewObject)[_rendererViewObject].setEdges(this.layer.view.viewIndex, edges);
      if (result instanceof SDKError) {
        throw result;
      }
      this.layer.redraw();
    }
    /**
     * Gets if this ViewObject is highlighted.
     *
     * * When {@link @xeokit/viewer!ViewObject.highlighted} is ````true```` the ViewObject will be registered by {@link @xeokit/viewer!ViewObject.id} in {@link @xeokit/view!ViewLayer.highlightedObjects | ViewLayer.highlightedObjects}.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsHighlighted} to batch-update the highlighted state of ViewObjects.
     */
  }, {
    key: "highlighted",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$f)[_state$f].highlighted;
    }
    /**
     * Sets if this ViewObject is highlighted.
     *
     * * When {@link @xeokit/viewer!ViewObject.highlighted} is ````true```` the ViewObject will be registered by {@link @xeokit/viewer!ViewObject.id} in {@link @xeokit/view!ViewLayer.highlightedObjects | ViewLayer.highlightedObjects}.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsHighlighted} to batch-update the highlighted state of ViewObjects.
     */,
    set: function set(highlighted) {
      if (highlighted === _classPrivateFieldLooseBase(this, _state$f)[_state$f].highlighted) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$f)[_state$f].highlighted = highlighted;
      var result = _classPrivateFieldLooseBase(this, _rendererViewObject)[_rendererViewObject].setHighlighted(this.layer.view.viewIndex, highlighted);
      if (result instanceof SDKError) {
        throw result;
      }
      this.layer.objectHighlightedUpdated(this, highlighted);
      this.layer.redraw();
    }
    /**
     * Gets if this ViewObject is selected.
     *
     * * When {@link @xeokit/viewer!ViewObject.selected} is ````true```` the ViewObject will be registered by {@link @xeokit/viewer!ViewObject.id} in {@link @xeokit/view!ViewLayer.selectedObjects | ViewLayer.selectedObjects}.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsSelected} to batch-update the selected state of ViewObjects.
     */
  }, {
    key: "selected",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$f)[_state$f].selected;
    }
    /**
     * Sets if this ViewObject is selected.
     *
     * * When {@link @xeokit/viewer!ViewObject.selected} is ````true```` the ViewObject will be registered by {@link @xeokit/viewer!ViewObject.id} in {@link @xeokit/view!ViewLayer.selectedObjects | ViewLayer.selectedObjects}.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsSelected} to batch-update the selected state of ViewObjects.
     */,
    set: function set(selected) {
      if (selected === _classPrivateFieldLooseBase(this, _state$f)[_state$f].selected) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$f)[_state$f].selected = selected;
      var result = _classPrivateFieldLooseBase(this, _rendererViewObject)[_rendererViewObject].setSelected(this.layer.view.viewIndex, selected);
      if (result instanceof SDKError) {
        throw result;
      }
      this.layer.objectSelectedUpdated(this, selected);
      this.layer.redraw();
    }
    /**
     * Gets if this ViewObject is culled.
     *
     * * The ViewObject is only rendered when {@link @xeokit/viewer!ViewObject.visible} is ````true```` and {@link @xeokit/viewer!ViewObject.culled} is ````false````.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsCulled} to batch-update the culled state of ViewObjects.
     */
  }, {
    key: "culled",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$f)[_state$f].culled;
    }
    /**
     * Sets if this ViewObject is culled.
     *
     * * The ViewObject is only rendered when {@link @xeokit/viewer!ViewObject.visible} is ````true```` and {@link @xeokit/viewer!ViewObject.culled} is ````false````.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsCulled} to batch-update the culled state of ViewObjects.
     */,
    set: function set(culled) {
      if (culled === _classPrivateFieldLooseBase(this, _state$f)[_state$f].culled) {
        return;
      }
      var result = _classPrivateFieldLooseBase(this, _rendererViewObject)[_rendererViewObject].setCulled(this.layer.view.viewIndex, culled);
      if (result instanceof SDKError) {
        throw result;
      }
      _classPrivateFieldLooseBase(this, _state$f)[_state$f].culled = culled;
      this.layer.redraw();
    }
    /**
     * Gets if this ViewObject is clippable.
     *
     * * Clipping is done by the {@link SectionPlane}s in {@link @xeokit/view!ViewLayer.sectionPlanes}.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsClippable} to batch-update the clippable state of ViewObjects.
     */
  }, {
    key: "clippable",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$f)[_state$f].clippable;
    }
    /**
     * Sets if this ViewObject is clippable.
     *
     * * Clipping is done by the {@link SectionPlane}s in {@link @xeokit/view!ViewLayer.sectionPlanes}.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsClippable} to batch-update the clippable state of ViewObjects.
     */,
    set: function set(clippable) {
      if (clippable === _classPrivateFieldLooseBase(this, _state$f)[_state$f].clippable) {
        return;
      }
      var result = _classPrivateFieldLooseBase(this, _rendererViewObject)[_rendererViewObject].setCulled(this.layer.view.viewIndex, clippable);
      if (result instanceof SDKError) {
        throw result;
      }
      _classPrivateFieldLooseBase(this, _state$f)[_state$f].clippable = clippable;
      this.layer.redraw();
    }
    /**
     * Gets if this ViewObject is included in boundary calculations.
     *
     * * When ````true````, the 3D World boundaries returned by {@link @xeokit/view!ViewLayer.aabb} will include this ViewObject's boundary.
     * * The ViewObject's 3D boundary is held in {@link @xeokit/scene!SceneObject.aabb}.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsCollidable} to batch-update the collidable state of ViewObjects.
     */
  }, {
    key: "collidable",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$f)[_state$f].collidable;
    }
    /**
     * Sets if this ViewObject included in boundary calculations.
     *
     * * When ````true````, the 3D World boundaries returned by {@link @xeokit/view!ViewLayer.aabb} will include this ViewObject's boundary.
     * * The ViewObject's 3D boundary is held in {@link @xeokit/scene!SceneObject.aabb}.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsCollidable} to batch-update the collidable state of ViewObjects.
     */,
    set: function set(collidable) {
      if (collidable === _classPrivateFieldLooseBase(this, _state$f)[_state$f].collidable) {
        return;
      }
      var result = _classPrivateFieldLooseBase(this, _rendererViewObject)[_rendererViewObject].setCollidable(this.layer.view.viewIndex, collidable);
      if (result instanceof SDKError) {
        throw result;
      }
      _classPrivateFieldLooseBase(this, _state$f)[_state$f].collidable = collidable;
      // this._setAABBDirty();
      // this.layer._aabbDirty = true;
    }
    /**
     * Gets if this ViewObject is pickable.
     *
     * * Picking is done with {@link @xeokit/view!ViewLayer.pick}.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsPickable} to batch-update the pickable state of ViewObjects.
     */
  }, {
    key: "pickable",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$f)[_state$f].pickable;
    }
    /**
     * Sets if this ViewObject is pickable.
     *
     * * Picking is done with {@link @xeokit/view!ViewLayer.pick}.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsPickable} to batch-update the pickable state of ViewObjects.
     */,
    set: function set(pickable) {
      if (_classPrivateFieldLooseBase(this, _state$f)[_state$f].pickable === pickable) {
        return;
      }
      var result = _classPrivateFieldLooseBase(this, _rendererViewObject)[_rendererViewObject].setPickable(this.layer.view.viewIndex, pickable);
      if (result instanceof SDKError) {
        throw result;
      }
      _classPrivateFieldLooseBase(this, _state$f)[_state$f].pickable = pickable;
      // No need to trigger a render;
      // state is only used when picking
    }
    /**
     * Gets the RGB colorize color for this ViewObject.
     *
     * * Multiplies by rendered fragment colors.
     * * Each element of the color is in range ````[0..1]````.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsColorized} to batch-update the colorized state of ViewObjects.
     */
  }, {
    key: "colorize",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$f)[_state$f].colorize;
    }
    /**
     * Sets the RGB colorize color for this ViewObject.
     *
     * * Multiplies by rendered fragment colors.
     * * Each element of the color is in range ````[0..1]````.
     * * Set to ````null```` or ````undefined```` to reset the colorize color to its default value of ````[1,1,1]````.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsColorized} to batch-update the colorized state of ViewObjects.
     */,
    set: function set(value) {
      var colorize = _classPrivateFieldLooseBase(this, _state$f)[_state$f].colorize;
      if (value) {
        colorize[0] = value[0];
        colorize[1] = value[1];
        colorize[2] = value[2];
      } else {
        colorize[0] = 1;
        colorize[1] = 1;
        colorize[2] = 1;
      }
      var result = _classPrivateFieldLooseBase(this, _rendererViewObject)[_rendererViewObject].setColorize(this.layer.view.viewIndex, colorize);
      if (result instanceof SDKError) {
        throw result;
      }
      _classPrivateFieldLooseBase(this, _state$f)[_state$f].colorized = !!value;
      this.layer.objectColorizeUpdated(this, _classPrivateFieldLooseBase(this, _state$f)[_state$f].colorized);
      this.layer.redraw();
    }
    /**
     * Gets the opacity factor for this ViewObject.
     *
     * * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsOpacity} to batch-update the opacities of ViewObjects.
     */
  }, {
    key: "opacity",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$f)[_state$f].colorize[3];
    }
    /**
     * Sets the opacity factor for this ViewObject.
     *
     * * This is a factor in range ````[0..1]```` which multiplies by the rendered fragment alphas.
     * * Set to ````null```` or ````undefined```` to reset the opacity to its default value of ````1````.
     * * Use {@link @xeokit/view!ViewLayer.setObjectsOpacity} to batch-update the opacities of ViewObjects.
     */,
    set: function set(opacity) {
      var colorize = _classPrivateFieldLooseBase(this, _state$f)[_state$f].colorize;
      _classPrivateFieldLooseBase(this, _state$f)[_state$f].opacityUpdated = opacity !== null && opacity !== undefined;
      // @ts-ignore
      colorize[3] = _classPrivateFieldLooseBase(this, _state$f)[_state$f].opacityUpdated ? opacity : 1.0;
      this.layer.objectOpacityUpdated(this, _classPrivateFieldLooseBase(this, _state$f)[_state$f].opacityUpdated);
      this.layer.redraw();
    }
  }]);
  return ViewObject;
}();

/**
 *  An arbitrarily-aligned World-space clipping plane.
 *
 * ## Summary
 *
 * * Belongs to a {@link @xeokit/viewer!View}.
 * * Slices portions off {@link @xeokit/viewer!ViewObject | ViewObjects} to create cross-section views or reveal interiors.
 * * Registered by {@link SectionPlane.id} in {@link View.sectionPlanes}.
 * * Indicates its World-space position in {@link SectionPlane.pos} and orientation vector in {@link SectionPlane.dir}.
 * * Discards elements from the half-space in the direction of {@link SectionPlane.dir}.
 * * Can be be enabled or disabled via {@link SectionPlane.active}.
 *
 * ## Usage
 *
 * In the example below, we'll create two SectionPlanes to slice a model loaded from glTF. Note that we could also create them
 * using a {@link SectionPlanesPlugin}.
 *
 * ````javascript
 * import {Viewer, GLTFLoaderPlugin, SectionPlane} from "xeokit-viewer.es.js";
 *
 * const viewer = new Viewer({
 *      canvasId: "myCanvas"
 * });
 *
 * const gltfLoaderPlugin = new GLTFModelsPlugin(viewer, {
 *      id: "GLTFModels"
 * });
 *
 * const model = gltfLoaderPlugin.load({
 *      id: "myModel",
 *      src: "./models/gltf/mygltfmodel.gltf"
 * });
 *
 * // Create a SectionPlane on negative diagonal
 * const sectionPlane1 = new SectionPlane(viewer.scene, {
 *     pos: [1.0, 1.0, 1.0],
 *     dir: [-1.0, -1.0, -1.0],
 *     active: true
 * }),
 *
 * // Create a SectionPlane on positive diagonal
 * const sectionPlane2 = new SectionPlane(viewer.scene, {
 *     pos: [-1.0, -1.0, -1.0],
 *     dir: [1.0, 1.0, 1.0],
 *     active: true
 * });
 * ````
 */
var _state$e = /*#__PURE__*/_classPrivateFieldLooseKey("state");
var SectionPlane = /*#__PURE__*/function (_Component) {
  _inheritsLoose(SectionPlane, _Component);
  /**
   * @private
   * @constructor
   */
  function SectionPlane(view, cfg) {
    var _this;
    if (cfg === void 0) {
      cfg = {};
    }
    _this = _Component.call(this, view, cfg) || this;
    /**
     * The View to which this DirLight belongs.
     *
     * @property view
     * @type {View}
     * @final
     */
    _this.view = void 0;
    /**
     * Emits an event each time {@link SectionPlane.pos} changes.
     *
     * @event
     */
    _this.onPos = void 0;
    /**
     * Emits an event each time {@link SectionPlane.dir} changes.
     *
     * @event
     */
    _this.onDir = void 0;
    /**
     * Emits an event each time {@link SectionPlane.active} changes.
     *
     * @event
     */
    _this.onActive = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _state$e, {
      writable: true,
      value: void 0
    });
    _this.view = view;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _state$e)[_state$e] = {
      active: cfg.active !== false,
      pos: new Float64Array(cfg.pos || [0, 0, 0]),
      dir: new Float32Array(cfg.pos || [0, 0, -1]),
      dist: 0
    };
    _this.onPos = new EventEmitter(new dist.EventDispatcher());
    _this.onDir = new EventEmitter(new dist.EventDispatcher());
    _this.onActive = new EventEmitter(new dist.EventDispatcher());
    return _this;
  }
  /**
   * Gets if this SectionPlane is active or not.
   *
   * Default value is ````true````.
   *
   * @returns Returns ````true```` if active.
   */
  var _proto = SectionPlane.prototype;
  /**
   * Inverts the direction of {@link SectionPlane.dir}.
   */
  _proto.flipDir = function flipDir() {
    var dir = _classPrivateFieldLooseBase(this, _state$e)[_state$e].dir;
    dir[0] *= -1.0;
    dir[1] *= -1.0;
    dir[2] *= -1.0;
    _classPrivateFieldLooseBase(this, _state$e)[_state$e].dist = -dotVec3(_classPrivateFieldLooseBase(this, _state$e)[_state$e].pos, _classPrivateFieldLooseBase(this, _state$e)[_state$e].dir);
    this.onDir.dispatch(this, _classPrivateFieldLooseBase(this, _state$e)[_state$e].dir);
    this.view.redraw();
  }
  /**
   * Destroys this SectionPlane.
   */;
  _proto.destroy = function destroy() {
    this.onPos.clear();
    this.onDir.clear();
    _Component.prototype.destroy.call(this);
  };
  _createClass(SectionPlane, [{
    key: "active",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$e)[_state$e].active;
    }
    /**
     * Sets if this SectionPlane is active or not.
     *
     * Default value is ````true````.
     *
     * @param value Set ````true```` to activate else ````false```` to deactivate.
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$e)[_state$e].active === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$e)[_state$e].active = value;
      this.view.redraw();
      this.onActive.dispatch(this, _classPrivateFieldLooseBase(this, _state$e)[_state$e].active);
    }
    /**
     * Gets the World-space position of this SectionPlane's plane.
     *
     * Default value is ````[0, 0, 0]````.
     *
     * @returns  Current position.
     */
  }, {
    key: "pos",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$e)[_state$e].pos;
    }
    /**
     * Sets the World-space position of this SectionPlane's plane.
     *
     * Default value is ````[0, 0, 0]````.
     *
     * @param value New position.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _state$e)[_state$e].pos.set(value);
      _classPrivateFieldLooseBase(this, _state$e)[_state$e].dist = -dotVec3(_classPrivateFieldLooseBase(this, _state$e)[_state$e].pos, _classPrivateFieldLooseBase(this, _state$e)[_state$e].dir);
      this.onPos.dispatch(this, _classPrivateFieldLooseBase(this, _state$e)[_state$e].pos);
    }
    /**
     * Gets the direction of this SectionPlane's plane.
     *
     * Default value is ````[0, 0, -1]````.
     *
     * @returns value Current direction.
     */
  }, {
    key: "dir",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$e)[_state$e].dir;
    }
    /**
     * Sets the direction of this SectionPlane's plane.
     *
     * Default value is ````[0, 0, -1]````.
     *
     * @param value New direction.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _state$e)[_state$e].dir.set(value);
      _classPrivateFieldLooseBase(this, _state$e)[_state$e].dist = -dotVec3(_classPrivateFieldLooseBase(this, _state$e)[_state$e].pos, _classPrivateFieldLooseBase(this, _state$e)[_state$e].dir);
      this.view.redraw();
      this.onDir.dispatch(this, _classPrivateFieldLooseBase(this, _state$e)[_state$e].dir);
    }
    /**
     * Gets this SectionPlane's distance to the origin of the World-space coordinate system.
     *
     * This is the dot product of {@link SectionPlane.pos} and {@link SectionPlane.dir} and is automatically re-calculated
     * each time either of two properties are updated.
     *
     * @returns Distance to the origin of the World-space coordinate system.
     */
  }, {
    key: "dist",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$e)[_state$e].dist;
    }
  }]);
  return SectionPlane;
}(Component);

var _unitsInfo;
var unitsInfo = (_unitsInfo = {}, _unitsInfo[MetersUnit] = {
  abbrev: "m"
}, _unitsInfo[CentimetersUnit] = {
  abbrev: "cm"
}, _unitsInfo[MillimetersUnit] = {
  abbrev: "mm"
}, _unitsInfo[YardsUnit] = {
  abbrev: "yd"
}, _unitsInfo[FeetUnit] = {
  abbrev: "ft"
}, _unitsInfo[InchesUnit] = {
  abbrev: "in"
}, _unitsInfo);
/**
 * Configures its {@link @xeokit/viewer!View}'s measurement unit and mapping between the Real-space and World-space 3D Cartesian coordinate systems.
 *
 *
 * ## Summary
 *
 * * Located at {@link View.metrics}.
 * * {@link Metrics.units} configures the Real-space unit type, which is {@link @xeokit/constants!MetersUnit} by default.
 * * {@link Metrics.scale} configures the number of Real-space units represented by each unit within the World-space 3D coordinate system. This is ````1.0```` by default.
 * * {@link Metrics.origin} configures the 3D Real-space origin, in current Real-space units, at which this {@link @xeokit/viewer!View}'s World-space coordinate origin sits, This is ````[0,0,0]```` by default.
 *
 * ## Usage
 *
 * ````JavaScript
 * import {Viewer, constants} from "xeokit-viewer.es.js";
 *
 * const viewer = new Viewer();
 *
 * const view1 = myViewer.createView({
 *      id: "myView",
 *      canvasId: "myCanvas1"
 * });
 *
 * const metrics = view1.metrics;
 *
 * metrics.units = MetersUnit;
 * metrics.scale = 10.0;
 * metrics.origin = [100.0, 0.0, 200.0];
 * ````
 */
var _units = /*#__PURE__*/_classPrivateFieldLooseKey("units");
var _scale = /*#__PURE__*/_classPrivateFieldLooseKey("scale");
var _origin$1 = /*#__PURE__*/_classPrivateFieldLooseKey("origin");
var Metrics = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Metrics, _Component);
  /**
   * @private
   */
  function Metrics(view, cfg) {
    var _this;
    if (cfg === void 0) {
      cfg = {
        units: MetersUnit,
        scale: 1.0,
        origin: [1, 1, 1]
      };
    }
    _this = _Component.call(this, view, cfg) || this;
    Object.defineProperty(_assertThisInitialized(_this), _units, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _scale, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _origin$1, {
      writable: true,
      value: void 0
    });
    /**
     * Emits an event each time {@link Metrics.units} changes.
     *
     * @event
     */
    _this.onUnits = void 0;
    /**
     * Emits an event each time {@link Metrics.scale} changes.
     *
     * @event
     */
    _this.onScale = void 0;
    /**
     * Emits an event each time {@link Metrics.origin} changes.
     *
     * @event
     */
    _this.onOrigin = void 0;
    _this.onUnits = new EventEmitter(new dist.EventDispatcher());
    _this.onScale = new EventEmitter(new dist.EventDispatcher());
    _this.onOrigin = new EventEmitter(new dist.EventDispatcher());
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _units)[_units] = MetersUnit;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _scale)[_scale] = 1.0;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _origin$1)[_origin$1] = createVec3([0, 0, 0]);
    _this.units = cfg.units;
    _this.scale = cfg.scale;
    _this.origin = cfg.origin;
    return _this;
  }
  /**
   * Gets info about the supported Real-space unit types.
   *
   * With {@link constants} indicating each unit type, the info will be:
   *
   * ````javascript
   * {
   *     [MetersUnit]: {
   *         abbrev: "m"
   *     },
   *     [CentimetersUnit]: {
   *         abbrev: "cm"
   *     },
   *     [MillimetersUnit]: {
   *         abbrev: "mm"
   *     },
   *     [YardsUnit]: {
   *         abbrev: "yd"
   *     },
   *     [FeetUnit]: {
   *         abbrev: "ft"
   *     },
   *     [InchesUnit]: {
   *         abbrev: "in"
   *     }
   * }
   * ````
   *
   * @type {*}
   */
  var _proto = Metrics.prototype;
  /**
   * Converts a 3D position from World-space to Real-space.
   *
   * This is equivalent to ````realPos = #origin + (worldPos * #scale)````.
   *
   * @param worldPos World-space 3D position, in World coordinate system units.
   * @param [realPos] Destination for Real-space 3D position.
   * @returns  Real-space 3D position, in units indicated by {@link Metrics#units}.
   */
  _proto.worldToRealPos = function worldToRealPos(worldPos, realPos) {
    if (realPos === void 0) {
      realPos = createVec3();
    }
    realPos[0] = _classPrivateFieldLooseBase(this, _origin$1)[_origin$1][0] + _classPrivateFieldLooseBase(this, _scale)[_scale] * worldPos[0];
    realPos[1] = _classPrivateFieldLooseBase(this, _origin$1)[_origin$1][1] + _classPrivateFieldLooseBase(this, _scale)[_scale] * worldPos[1];
    realPos[2] = _classPrivateFieldLooseBase(this, _origin$1)[_origin$1][2] + _classPrivateFieldLooseBase(this, _scale)[_scale] * worldPos[2];
    return realPos;
  }
  /**
   * Converts a 3D position from Real-space to World-space.
   *
   * This is equivalent to ````worldPos = (worldPos - #origin) / #scale````.
   *
   * @param realPos Real-space 3D position.
   * @param [worldPos] Destination for World-space 3D position.
   * @returns  World-space 3D position.
   */;
  _proto.realToWorldPos = function realToWorldPos(realPos, worldPos) {
    if (worldPos === void 0) {
      worldPos = createVec3();
    }
    worldPos[0] = (realPos[0] - _classPrivateFieldLooseBase(this, _origin$1)[_origin$1][0]) / _classPrivateFieldLooseBase(this, _scale)[_scale];
    worldPos[1] = (realPos[1] - _classPrivateFieldLooseBase(this, _origin$1)[_origin$1][1]) / _classPrivateFieldLooseBase(this, _scale)[_scale];
    worldPos[2] = (realPos[2] - _classPrivateFieldLooseBase(this, _origin$1)[_origin$1][2]) / _classPrivateFieldLooseBase(this, _scale)[_scale];
    return worldPos;
  }
  /**
   * @private
   */;
  _proto.destroy = function destroy() {
    _Component.prototype.destroy.call(this);
    this.onUnits.clear();
    this.onScale.clear();
    this.onOrigin.clear();
  };
  _createClass(Metrics, [{
    key: "unitsInfo",
    get: function get() {
      return unitsInfo;
    }
    /**
     * Gets the {@link @xeokit/viewer!View}'s Real-space unit type.
     */
  }, {
    key: "units",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _units)[_units];
    }
    /**
     * Sets the {@link @xeokit/viewer!View}'s Real-space unit type.
     *
     * Accepted values are {@link @xeokit/constants!MetersUnit}, {@link @xeokit/constants!CentimetersUnit}, {@link @xeokit/constants!MillimetersUnit}, {@link @xeokit/constants!YardsUnit}, {@link @xeokit/constants!FeetUnit} and {@link @xeokit/constants!InchesUnit}.
     */,
    set: function set(value) {
      if (!value) {
        value = MetersUnit;
      }
      // @ts-ignore
      var info = unitsInfo[value];
      if (!info) {
        this.error("Unsupported value for 'units': " + value + " defaulting to MetersUnit");
        value = MetersUnit;
      }
      _classPrivateFieldLooseBase(this, _units)[_units] = value;
      this.onUnits.dispatch(this, _classPrivateFieldLooseBase(this, _units)[_units]);
    }
    /**
     * Gets the number of Real-space units represented by each unit of the {@link @xeokit/viewer!View}'s World-space coordinate system.
     */
  }, {
    key: "scale",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _scale)[_scale];
    }
    /**
     * Sets the number of Real-space units represented by each unit of the {@link @xeokit/viewer!View}'s World-space coordinate system.
     *
     * For example, if {@link Metrics.units} is {@link @xeokit/constants!MetersUnit}, and there are ten meters per World-space coordinate system unit, then ````scale```` would have a value of ````10.0````.
     */,
    set: function set(value) {
      value = value || 1;
      if (value <= 0) {
        this.error("scale value should be larger than zero");
        return;
      }
      _classPrivateFieldLooseBase(this, _scale)[_scale] = value;
      this.onScale.dispatch(this, _classPrivateFieldLooseBase(this, _scale)[_scale]);
    }
    /**
     * Gets the 3D Real-space origin, in Real-space units, at which this {@link @xeokit/viewer!View}'s World-space coordinate origin ````[0,0,0]```` sits.
     */
  }, {
    key: "origin",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _origin$1)[_origin$1];
    }
    /**
     * Sets the Real-space 3D origin, in Real-space units, at which this {@link @xeokit/viewer!View}'s World-space coordinate origin ````[0,0,0]```` sits.
     */,
    set: function set(value) {
      if (!value) {
        _classPrivateFieldLooseBase(this, _origin$1)[_origin$1][0] = 0;
        _classPrivateFieldLooseBase(this, _origin$1)[_origin$1][1] = 0;
        _classPrivateFieldLooseBase(this, _origin$1)[_origin$1][2] = 0;
        return;
      }
      _classPrivateFieldLooseBase(this, _origin$1)[_origin$1][0] = value[0];
      _classPrivateFieldLooseBase(this, _origin$1)[_origin$1][1] = value[1];
      _classPrivateFieldLooseBase(this, _origin$1)[_origin$1][2] = value[2];
      this.onOrigin.dispatch(this, _classPrivateFieldLooseBase(this, _origin$1)[_origin$1]);
    }
  }]);
  return Metrics;
}(Component);

/**
 * Configures Scalable Ambient Obscurance (SAO) for a {@link @xeokit/viewer!View}.
 */
var _state$d = /*#__PURE__*/_classPrivateFieldLooseKey("state");
var SAO = /*#__PURE__*/function (_Component) {
  _inheritsLoose(SAO, _Component);
  /** @private */
  function SAO(view, params) {
    var _this;
    _this = _Component.call(this, view, params) || this;
    /**
     * The View to which this SAO belongs.
     */
    _this.view = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _state$d, {
      writable: true,
      value: void 0
    });
    _this.view = view;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _state$d)[_state$d] = {
      renderModes: [QualityRender],
      enabled: params.enabled !== false,
      kernelRadius: params.kernelRadius || 100.0,
      intensity: params.intensity !== undefined ? params.intensity : 0.15,
      bias: params.bias !== undefined ? params.bias : 0.5,
      scale: params.scale !== undefined ? params.scale : 1.0,
      minResolution: params.minResolution !== undefined ? params.minResolution : 0.0,
      numSamples: params.numSamples !== undefined ? params.numSamples : 10,
      blur: !!params.blur,
      blendCutoff: params.blendCutff !== undefined ? params.blendCutoff : 0.3,
      blendFactor: params.blendFactor !== undefined ? params.blendFactor : 1.0
    };
    return _this;
  }
  /**
   * Sets which rendering modes in which to render SAO.
   *
   * Supported rendering modes are:
   *
   * * {@link @xeokit/constants!FastRender | FastRender} - Fast rendering mode for smooth interactivity.
   * * {@link @xeokit/constants!QualityRender | QualityRender} - Quality rendering mode for maximum image fidelity.
   *
   * Default value is [{@link @xeokit/constants!QualityRender | QualityRender}].
   *
   * @param renderModes The rendering modes
   * @returns *{@link @xeokit/core!SDKError}*
   * * Rendering mode not supported.
   */
  var _proto = SAO.prototype;
  _proto.setRenderModes = function setRenderModes(renderModes) {
    for (var i = 0, len = renderModes.length; i < len; i++) {
      var renderMode = renderModes[i];
      if (renderMode !== QualityRender && renderMode !== FastRender) {
        return new SDKError("Failed to set render modes for SAO - unsupported mode - supported modes are FastRender and QualityRender");
      }
    }
    _classPrivateFieldLooseBase(this, _state$d)[_state$d].renderModes = renderModes;
    this.view.redraw();
  }
  /**
   * Gets which rendering modes in which to render SAO.
   *
   * Supported rendering modes are:
   *
   * * {@link @xeokit/constants!FastRender | FastRender} - Fast rendering mode for smooth interactivity.
   * * {@link @xeokit/constants!QualityRender | QualityRender} - Quality rendering mode for maximum image fidelity.
   *
   * Default value is [{@link @xeokit/constants!QualityRender | QualityRender}].
   */;
  /**
   * @private
   */
  _proto.destroy = function destroy() {
    _Component.prototype.destroy.call(this);
  };
  _createClass(SAO, [{
    key: "renderModes",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$d)[_state$d].renderModes;
    }
    /**
     * Gets whether SAO is supported by this browser and GPU.
     *
     * Even when enabled, SAO will only work if supported.
     */
  }, {
    key: "supported",
    get: function get() {
      return this.view.viewer.renderer.getSAOSupported();
    }
    /**
     * Gets whether SAO is enabled for the {@link @xeokit/viewer!View}.
     *
     * Even when enabled, SAO will only apply if supported.
     *
     * Default value is ````false````.
     */
  }, {
    key: "enabled",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$d)[_state$d].enabled;
    }
    /**
     * Sets whether SAO is enabled for the {@link @xeokit/viewer!View}.
     *
     * Even when enabled, SAO will only work if supported.
     *
     * Default value is ````false````.
     */,
    set: function set(value) {
      value = !!value;
      if (_classPrivateFieldLooseBase(this, _state$d)[_state$d].enabled === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$d)[_state$d].enabled = value;
      this.view.redraw();
    }
    /**
     * Returns true if SAO is currently possible, where it is supported, enabled, and the current view state is compatible.
     * Called internally by renderer logic.
     * @private
     */
  }, {
    key: "possible",
    get: function get() {
      if (!this.supported) {
        return false;
      }
      if (!_classPrivateFieldLooseBase(this, _state$d)[_state$d].enabled) {
        return false;
      }
      var projectionType = this.view.camera.projectionType;
      if (projectionType === CustomProjectionType) {
        return false;
      }
      if (projectionType === FrustumProjectionType) {
        return false;
      }
      return true;
    }
    /**
     * Gets the maximum area that SAO takes into account when checking for possible occlusion for each fragment.
     *
     * Default value is ````100.0````.
     */
  }, {
    key: "kernelRadius",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$d)[_state$d].kernelRadius;
    }
    /**
     * Sets the maximum area that SAO takes into account when checking for possible occlusion for each fragment.
     *
     * Default value is ````100.0````.
     */,
    set: function set(value) {
      if (value === undefined || value === null) {
        value = 100.0;
      }
      if (_classPrivateFieldLooseBase(this, _state$d)[_state$d].kernelRadius === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$d)[_state$d].kernelRadius = value;
      this.view.redraw();
    }
    /**
     * Gets the degree of darkening (ambient obscurance) produced by the SAO effect.
     *
     * Default value is ````0.15````.
     */
  }, {
    key: "intensity",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$d)[_state$d].intensity;
    }
    /**
     * Sets the degree of darkening (ambient obscurance) produced by the SAO effect.
     *
     * Default value is ````0.15````.
     */,
    set: function set(value) {
      if (value === undefined || value === null) {
        value = 0.15;
      }
      if (_classPrivateFieldLooseBase(this, _state$d)[_state$d].intensity === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$d)[_state$d].intensity = value;
      this.view.redraw();
    }
    /**
     * Gets the SAO bias.
     *
     * Default value is ````0.5````.
     */
  }, {
    key: "bias",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$d)[_state$d].bias;
    }
    /**
     * Sets the SAO bias.
     *
     * Default value is ````0.5````.
     */,
    set: function set(value) {
      if (value === undefined || value === null) {
        value = 0.5;
      }
      if (_classPrivateFieldLooseBase(this, _state$d)[_state$d].bias === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$d)[_state$d].bias = value;
      this.view.redraw();
    }
    /**
     * Gets the SAO occlusion scale.
     *
     * Default value is ````1.0````.
     */
  }, {
    key: "scale",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$d)[_state$d].scale;
    }
    /**
     * Sets the SAO occlusion scale.
     *
     * Default value is ````1.0````.
     */,
    set: function set(value) {
      if (value === undefined || value === null) {
        value = 1.0;
      }
      if (_classPrivateFieldLooseBase(this, _state$d)[_state$d].scale === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$d)[_state$d].scale = value;
      this.view.redraw();
    }
    /**
     * Gets the SAO minimum resolution.
     *
     * Default value is ````0.0````.
     */
  }, {
    key: "minResolution",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$d)[_state$d].minResolution;
    }
    /**
     * Sets the SAO minimum resolution.
     *
     * Default value is ````0.0````.
     */,
    set: function set(value) {
      if (value === undefined || value === null) {
        value = 0.0;
      }
      if (_classPrivateFieldLooseBase(this, _state$d)[_state$d].minResolution === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$d)[_state$d].minResolution = value;
      this.view.redraw();
    }
    /**
     * Gets the number of SAO samples.
     *
     * Default value is ````10````.
     */
  }, {
    key: "numSamples",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$d)[_state$d].numSamples;
    }
    /**
     * Sets the number of SAO samples.
     *
     * Default value is ````10````.
     *
     * Update this sparingly, since it causes a shader recompile.
     */,
    set: function set(value) {
      if (value === undefined || value === null) {
        value = 10;
      }
      if (_classPrivateFieldLooseBase(this, _state$d)[_state$d].numSamples === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$d)[_state$d].numSamples = value;
      this.view.redraw();
    }
    /**
     * Gets whether Guassian blur is enabled.
     *
     * Default value is ````true````.
     */
  }, {
    key: "blur",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$d)[_state$d].blur;
    }
    /**
     * Sets whether Guassian blur is enabled.
     *
     * Default value is ````true````.
     */,
    set: function set(value) {
      value = value !== false;
      if (_classPrivateFieldLooseBase(this, _state$d)[_state$d].blur === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$d)[_state$d].blur = value;
      this.view.redraw();
    }
    /**
     * Gets the SAO blend cutoff.
     *
     * Default value is ````0.3````.
     *
     * Normally you don't need to alter this.
     */
  }, {
    key: "blendCutoff",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$d)[_state$d].blendCutoff;
    }
    /**
     * Sets the SAO blend cutoff.
     *
     * Default value is ````0.3````.
     *
     * Normally you don't need to alter this.
     */,
    set: function set(value) {
      if (value === undefined || value === null) {
        value = 0.3;
      }
      if (_classPrivateFieldLooseBase(this, _state$d)[_state$d].blendCutoff === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$d)[_state$d].blendCutoff = value;
      this.view.redraw();
    }
    /**
     * Gets the SAO blend scale.
     *
     * Default value is ````1.0````.
     *
     * Normally you don't need to alter this.
     */
  }, {
    key: "blendFactor",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$d)[_state$d].blendFactor;
    }
    /**
     * Sets the SAO blend factor.
     *
     * Default value is ````1.0````.
     *
     * Normally you don't need to alter this.
     */,
    set: function set(value) {
      if (value === undefined || value === null) {
        value = 1.0;
      }
      if (_classPrivateFieldLooseBase(this, _state$d)[_state$d].blendFactor === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$d)[_state$d].blendFactor = value;
      this.view.redraw();
    }
  }]);
  return SAO;
}(Component);

/**
 * Configures the shape of "lines" geometry primitives.
 *
 * * Located at {@link View#linesMaterial}.
 */
var _state$c = /*#__PURE__*/_classPrivateFieldLooseKey("state");
var LinesMaterial = /*#__PURE__*/function (_Component) {
  _inheritsLoose(LinesMaterial, _Component);
  /**
   * @private
   */
  function LinesMaterial(view, options) {
    var _this;
    if (options === void 0) {
      options = {
        lineWidth: 1
      };
    }
    _this = _Component.call(this, view, options) || this;
    /**
     * The View to which this LinesMaterial belongs.
     */
    _this.view = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _state$c, {
      writable: true,
      value: void 0
    });
    _this.view = view;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _state$c)[_state$c] = {
      lineWidth: options.lineWidth !== undefined && options.lineWidth !== null ? options.lineWidth : 1
    };
    return _this;
  }
  /**
   * Sets line width.
   *
   * Default value is ````1```` pixels.
   */
  _createClass(LinesMaterial, [{
    key: "lineWidth",
    get:
    /**
     * Gets the line width.
     *
     * Default value is ````1```` pixels.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$c)[_state$c].lineWidth;
    },
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _state$c)[_state$c].lineWidth = value || 1;
      this.view.redraw();
    }
  }]);
  return LinesMaterial;
}(Component);

/**
 * A layer of {@link @xeokit/viewer!ViewObject | ViewObjects} in a {@link @xeokit/viewer!View}.
 *
 * See {@link "@xeokit/viewer"} for usage.
 *
 * ## Summary
 *
 * * Automatically stores a {@link @xeokit/viewer!ViewObject} for each existing {@link RendererObject} that has a matching {@link RendererObject.layerId | ViewerObject.layerId}
 * * Useful for segreggating {@link @xeokit/viewer!ViewObject | ViewObjects} into layers
 * * Created automatically or manually (see {@link View.createLayer | View.createLayer})
 * * Stored in {@link View.layers | View.layers}
 *
 * ## Overview
 *
 * ViewLayers organize a {@link View |View's} {@link @xeokit/viewer!ViewObject | ViewObjects} into layers, according to which aspects of
 * the view they represent. They make it easier for us to focus our interactions on the ViewObjects that are relevant
 * to the particular aspects we're interested in.
 *
 * ### Typical use case: segregating model objects from environment objects
 *
 * A typical use case for this feature is to group environmental {@link @xeokit/viewer!ViewObject | ViewObjects} (e.g. ground, skybox) in an "environment" ViewLayer,
 * and group model ViewObjects in a "model" ViewLayer. Then we can focus our model interactions (show, hide, highlight,
 * save/load BCF viewpoints, etc.) on the ViewObjects in the "model" ViewLayer, without involving the "environment"
 * ViewObjects at all, which are effectively in the background. We can basically ignore the environment objects as we
 * do various batch operations on our model objects, i.e. "X-ray all", "X-ray everything except for walls" and so on.
 *
 * ### Automatic ViewLayers
 *
 * By default, each {@link @xeokit/viewer!View} automatically lazy-creates ViewLayers within itself as required. As {@link RendererObject | ViewerObjects} appear in the
 * {@link @xeokit/viewer!Viewer}, {@link @xeokit/viewer!ViewObject | ViewObjects} and Viewlayers magically appear in each existing View.
 *
 * Recall that, whenever a {@link RendererObject} is created, each existing {@link @xeokit/viewer!View} will automatically create a
 * corresponding {@link @xeokit/viewer!ViewObject} to represent and control that ViewerObject's appearance within the View's canvas.
 *
 * If the {@link RendererObject} also happens to have a value set on its {@link RendererObject.layerId} ID property, then the View
 * will also automatically ensure that it contains a matching {@link @xeokit/viewer!ViewLayer}, and will register the new ViewObject
 * in that ViewLayer. Note that each ViewObject can belong to a maximum of one ViewLayer.
 *
 * When a {@link @xeokit/viewer!View} automatically creates Viewlayers, it will also automatically destroy them again whenever
 * their {@link RendererObject | ViewerObjects} have all been destroyed.
 *
 * ### Manual ViewLayers
 *
 * We can configure a {@link @xeokit/viewer!View} to **not** automatically create ViewLayers, and instead rely on us to manually create them.
 *
 * When we do that, the View will only create the {@link @xeokit/viewer!ViewObject | ViewObjects} within itself for the ViewLayers that we created. The
 * View will ignore all ViewerObjects that don't have {@link RendererObject.layerId} values that match the IDs of our
 * manually-created ViewLayers.
 *
 * This feature is useful for ensuring that aspect-focused Views don't contain huge numbers of unused ViewObjects for
 * ViewerObjects that they never need to show.
 *
 * When we manually create ViewLayers like this, then the View will not automatically destroy them whenever
 * their {@link RendererObject | ViewerObjects} have all been destroyed. This keeps the ViewLayers around, in case
 * we create matching ViewerObjects again in future.
 *
 * ## Examples
 *
 * ### Exampe 1: Automatic ViewLayers
 *
 * Create a {@link @xeokit/viewer!Viewer}:
 *
 *````javascript
 * import {Viewer} from "@xeokit/viewer";
 *
 * const myViewer = new Viewer({
 *      id: "myViewer"
 * });
 *````
 *
 * Create a {@link @xeokit/viewer!View}, with the default setting of ````false```` for {@link ViewParams.autoLayers}:
 *
 * ````javascript
 * const view1 = myViewer.createView({
 *      id: "myView",
 *      canvasId: "myView1",
 *      autoLayers: true // <<----------- Default
 * });
 *
 * view1.camera.eye = [-3.933, 2.855, 27.018];
 * view1.camera.look = [4.400, 3.724, 8.899];
 * view1.camera.up = [-0.018, 0.999, 0.039];
 * ````
 *
 * Next, we'll create a {@link @xeokit/scene!SceneModel | SceneModel} containing two model {@link RendererObject | ViewerObjects} that represent a building
 * foundation and walls, along with two environmental ViewerObjects that represent a skybox and ground plane.
 *
 * The ground and skybox ViewerObjects specify that their {@link @xeokit/viewer!ViewObject | ViewObjects} belong
 * to "environment" ViewLayers, while the model ViewerObjects specify that their ViewObjects belong to "model" ViewLayers.
 *
 * ````javascript
 * const sceneModel = myViewer.scene.createModel({
 *      id: "myModel"
 * });
 *
 * // (calls to SceneModel createGeometry and
 * // createMesh omitted for brevity)
 *
 * sceneModel.createObject({
 *      id: "ground",
 *      meshIds: ["groundMesh}],
 *      layerId: "environment"
 * });
 *
 * sceneModel.createObject({
 *      id: "skyBox",
 *      meshIds: ["skyBoxMesh}],
 *      layerId: "environment"
 * });
 *
 * sceneModel.createObject({
 *      id: "houseFoundation",
 *      meshIds: ["myMesh}],
 *      layerId: "model"
 * });
 *
 * sceneModel.createObject({
 *      id: "houseWalls",
 *      meshIds: ["myMesh}],
 *      layerId: "model"
 * });
 *
 * sceneModel.build();
 * ````
 *
 * Our {@link @xeokit/viewer!View} has now automatically created an "environment" {@link @xeokit/viewer!ViewLayer}, which contains {@link @xeokit/viewer!ViewObject | ViewObjects} for the skybox and
 * ground plane ViewerObjects, and a "model" ViewLayer, which contains ViewObjects for the house foundation and walls.
 *
 * We can now batch-update the ViewObjects in each ViewLayer independently. As mentioned, this is useful when we need to ignore things
 * like UI or environmental objects in batch-updates, BCF viewpoints etc.
 *
 * ````javascript
 * // viewer.objects contains four ViewerObjects with IDs "ground", "skyBox", "houseFoundation" and "houseWalls"
 *
 * // viewer.views.view1.objects contains four ViewObjects with IDs "ground", "skyBox", "houseFoundation" and "houseWalls"
 *
 * // viewer.views.view1.layers contains two ViewLayers with IDs "environment" and "model"
 *
 * const environmentLayer = view1.layers["environment"];
 * environmentLayer.setObjectsVisible(environmentLayer.objectIds, true);

 * const modelLayer = view1.layers["model"];
 * modelLayer.setObjectsVisible(modelLayer.objectIds, true);
 * ````
 *
 * ### Example 2: Manual ViewLayers
 *
 * Create a {@link @xeokit/viewer!Viewer}:
 *
 * ````javascript
 * import {Viewer} from "@xeokit/viewer";
 *
 * const myViewer = new Viewer({
 *      id: "myViewer"
 * });
 * ````
 *
 * Create a {@link @xeokit/viewer!View}, this time with ````false```` for {@link ViewParams.autoLayers}, in order to **not**
 * automatically create ViewLayers on demand:
 *
 * ````javascript
 * const view1 = myViewer.createView({
 *      id: "myView",
 *      canvasId: "myCanvas1",
 *      autoLayers: false // <<----------- Override default
 * });
 *
 * view1.camera.eye = [-3.933, 2.855, 27.018];
 * view1.camera.look = [4.400, 3.724, 8.899];
 * view1.camera.up = [-0.018, 0.999, 0.039];
 * ````
 *
 * We'll manually create the "model" ViewLayer, and won't create an "environment" ViewLayer:
 *
 * ````javascript
 * const modelViewLayer = view1.createLayer({
 *     id: "model",
 *     visible: true
 * });
 * ````
 *
 * As we did in the previous example, we'll now create a {@link @xeokit/scene!SceneModel | SceneModel} containing two model
 * {@link RendererObject | ViewerObjects} that represent a building foundation and walls, along with two environmental
 * ViewerObjects that represent a skybox and ground plane.
 *
 * As before, the ground and skybox ViewerObjects specify that their {@link @xeokit/viewer!ViewObject | ViewObjects} belong to "environment" ViewLayers,
 * while the model ViewerObjects specify that their ViewObjects belong to "model" ViewLayers.
 *
 * ````javascript
 * const sceneModel = myViewer.scene.createModel({
 *      id: "myModel"
 * });
 *
 * // (calls to SceneModel createGeometry and
 * // createMesh omitted for brevity)
 *
 * sceneModel.createObject({
 *      id: "ground",
 *      meshIds: ["groundMesh}],
 *      layerId: "environment"
 * });
 *
 * sceneModel.createObject({
 *      id: "skyBox",
 *      meshIds: ["skyBoxMesh}],
 *      layerId: "environment"
 * });
 *
 * sceneModel.createObject({
 *      id: "houseFoundation",
 *      meshIds: ["myMesh}],
 *      layerId: "model"
 * });
 *
 * sceneModel.createObject({
 *      id: "houseWalls",
 *      meshIds: ["myMesh}],
 *      layerId: "model"
 * });
 *
 * sceneModel.build();
 * ````
 *
 * This time, however, our {@link @xeokit/viewer!View} has now created {@link @xeokit/viewer!ViewObject | ViewObjects} for the "model" ViewerObjects, while
 * ignoring the "environment" ViewerObjects.
 *
 * As far as this View is concerned, the "environment" ViewerObjects do not exist.
 *
 * ````javascript
 * // viewer.scene.objects contains four SceneObjects with IDs "ground", "skyBox", "houseFoundation" and "houseWalls"
 *
 * // viewer.views.view1.objects contains two ViewObjects with IDs "houseFoundation" and "houseWalls"
 *
 * // viewer.views.view1.layers contains one ViewLayer with ID "model"
 *
 * const modelLayer = view1.layers["model"];
 * modelLayer.setObjectsVisible(modelLayer.objectIds, true);
 * ````
 */
var _renderModes = /*#__PURE__*/_classPrivateFieldLooseKey("renderModes");
var _numObjects$1 = /*#__PURE__*/_classPrivateFieldLooseKey("numObjects");
var _objectIds$1 = /*#__PURE__*/_classPrivateFieldLooseKey("objectIds");
var _numVisibleObjects$1 = /*#__PURE__*/_classPrivateFieldLooseKey("numVisibleObjects");
var _visibleObjectIds$1 = /*#__PURE__*/_classPrivateFieldLooseKey("visibleObjectIds");
var _numXRayedObjects$1 = /*#__PURE__*/_classPrivateFieldLooseKey("numXRayedObjects");
var _xrayedObjectIds$1 = /*#__PURE__*/_classPrivateFieldLooseKey("xrayedObjectIds");
var _numHighlightedObjects$1 = /*#__PURE__*/_classPrivateFieldLooseKey("numHighlightedObjects");
var _highlightedObjectIds$1 = /*#__PURE__*/_classPrivateFieldLooseKey("highlightedObjectIds");
var _numSelectedObjects$1 = /*#__PURE__*/_classPrivateFieldLooseKey("numSelectedObjects");
var _selectedObjectIds$1 = /*#__PURE__*/_classPrivateFieldLooseKey("selectedObjectIds");
var _numColorizedObjects$1 = /*#__PURE__*/_classPrivateFieldLooseKey("numColorizedObjects");
var _colorizedObjectIds$1 = /*#__PURE__*/_classPrivateFieldLooseKey("colorizedObjectIds");
var _numOpacityObjects$1 = /*#__PURE__*/_classPrivateFieldLooseKey("numOpacityObjects");
var _opacityObjectIds$1 = /*#__PURE__*/_classPrivateFieldLooseKey("opacityObjectIds");
var _qualityRender$1 = /*#__PURE__*/_classPrivateFieldLooseKey("qualityRender");
var _initViewObjects = /*#__PURE__*/_classPrivateFieldLooseKey("initViewObjects");
var _createViewObjects = /*#__PURE__*/_classPrivateFieldLooseKey("createViewObjects");
var _destroyViewObjects = /*#__PURE__*/_classPrivateFieldLooseKey("destroyViewObjects");
var ViewLayer = /*#__PURE__*/function (_Component) {
  _inheritsLoose(ViewLayer, _Component);
  function ViewLayer(options) {
    var _this;
    _this = _Component.call(this, options.view, options) || this;
    Object.defineProperty(_assertThisInitialized(_this), _destroyViewObjects, {
      value: _destroyViewObjects2
    });
    Object.defineProperty(_assertThisInitialized(_this), _createViewObjects, {
      value: _createViewObjects2
    });
    Object.defineProperty(_assertThisInitialized(_this), _initViewObjects, {
      value: _initViewObjects2
    });
    /**
     * Map of the all {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
     *
     * These are the ViewObjects for which {@link @xeokit/viewer!ViewObject.layerId | ViewObject.layerId} has the same value as {@link @xeokit/view!ViewLayer.id}.
     *
     * Each {@link @xeokit/viewer!ViewObject} is mapped here by {@link @xeokit/viewer!ViewObject.id}.
     *
     * The ViewLayer automatically ensures that there is a {@link @xeokit/viewer!ViewObject} here for
     * each {@link RendererObject} in the {@link @xeokit/viewer!Viewer}
     */
    _this.objects = void 0;
    /**
     * Map of the currently visible {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
     *
     * A ViewObject is visible when {@link @xeokit/viewer!ViewObject.visible} is true.
     *
     * Each {@link @xeokit/viewer!ViewObject} is mapped here by {@link @xeokit/viewer!ViewObject.id}.
     */
    _this.visibleObjects = void 0;
    /**
     * Map of currently x-rayed {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
     *
     * A ViewObject is x-rayed when {@link @xeokit/viewer!ViewObject.xrayed} is true.
     *
     * Each {@link @xeokit/viewer!ViewObject} is mapped here by {@link @xeokit/viewer!ViewObject.id}.
     */
    _this.xrayedObjects = void 0;
    /**
     * Map of currently highlighted {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
     *
     * A ViewObject is highlighted when {@link @xeokit/viewer!ViewObject.highlighted} is true.
     *
     * Each {@link @xeokit/viewer!ViewObject} is mapped here by {@link @xeokit/viewer!ViewObject.id}.
     */
    _this.highlightedObjects = void 0;
    /**
     * Map of currently selected {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
     *
     * A ViewObject is selected when {@link @xeokit/viewer!ViewObject.selected} is true.
     *
     * Each {@link @xeokit/viewer!ViewObject} is mapped here by {@link @xeokit/viewer!ViewObject.id}.
     */
    _this.selectedObjects = void 0;
    /**
     * Map of currently colorized {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
     *
     * Each {@link @xeokit/viewer!ViewObject} is mapped here by {@link @xeokit/viewer!ViewObject.id}.
     */
    _this.colorizedObjects = void 0;
    /**
     * Map of {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer whose opacity has been updated.
     *
     * Each {@link @xeokit/viewer!ViewObject} is mapped here by {@link @xeokit/viewer!ViewObject.id}.
     */
    _this.opacityObjects = void 0;
    /**
     * When true, View destroys this ViewLayer as soon as there are no ViewObjects
     * that need it. When false, View retains it.
     * @private
     */
    _this.autoDestroy = void 0;
    /**
     * Emits an event each time the visibility of a {@link @xeokit/viewer!ViewObject} changes.
     *
     * ViewObjects are shown and hidden with {@link View.setObjectsVisible}, {@link @xeokit/view!ViewLayer.setObjectsVisible} or {@link @xeokit/viewer!ViewObject.visible}.
     *
     * @event
     */
    _this.onObjectVisibility = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _renderModes, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _numObjects$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _objectIds$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _numVisibleObjects$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _visibleObjectIds$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _numXRayedObjects$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _xrayedObjectIds$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _numHighlightedObjects$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _highlightedObjectIds$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _numSelectedObjects$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _selectedObjectIds$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _numColorizedObjects$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _colorizedObjectIds$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _numOpacityObjects$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _opacityObjectIds$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _qualityRender$1, {
      writable: true,
      value: void 0
    });
    _this.gammaOutput = void 0;
    _this.id = options.id;
    _this.viewer = options.viewer;
    _this.view = options.view;
    _this.objects = {};
    _this.visibleObjects = {};
    _this.xrayedObjects = {};
    _this.highlightedObjects = {};
    _this.selectedObjects = {};
    _this.colorizedObjects = {};
    _this.opacityObjects = {};
    _this.autoDestroy = options.autoDestroy !== false;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _numObjects$1)[_numObjects$1] = 0;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _numVisibleObjects$1)[_numVisibleObjects$1] = 0;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _numXRayedObjects$1)[_numXRayedObjects$1] = 0;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _numHighlightedObjects$1)[_numHighlightedObjects$1] = 0;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _numSelectedObjects$1)[_numSelectedObjects$1] = 0;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _numColorizedObjects$1)[_numColorizedObjects$1] = 0;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _numOpacityObjects$1)[_numOpacityObjects$1] = 0;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _qualityRender$1)[_qualityRender$1] = !!options.qualityRender;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _renderModes)[_renderModes] = [];
    _this.onObjectVisibility = new EventEmitter(new dist.EventDispatcher());
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _initViewObjects)[_initViewObjects]();
    return _this;
  }
  /**
   * Gets the gamma factor.
   */
  var _proto = ViewLayer.prototype;
  /**
   * @private
   */
  _proto.registerViewObject = function registerViewObject(viewObject) {
    this.objects[viewObject.id] = viewObject;
    _classPrivateFieldLooseBase(this, _numObjects$1)[_numObjects$1]++;
    _classPrivateFieldLooseBase(this, _objectIds$1)[_objectIds$1] = null; // Lazy regenerate
  }
  /**
   * @private
   */;
  _proto.deregisterViewObject = function deregisterViewObject(viewObject) {
    delete this.objects[viewObject.id];
    delete this.visibleObjects[viewObject.id];
    delete this.xrayedObjects[viewObject.id];
    delete this.highlightedObjects[viewObject.id];
    delete this.selectedObjects[viewObject.id];
    delete this.colorizedObjects[viewObject.id];
    delete this.opacityObjects[viewObject.id];
    _classPrivateFieldLooseBase(this, _numObjects$1)[_numObjects$1]--;
    _classPrivateFieldLooseBase(this, _objectIds$1)[_objectIds$1] = null; // Lazy regenerate
  }
  /**
   * @private
   */;
  _proto.redraw = function redraw() {
    this.viewer.renderer.setImageDirty(this.view.viewIndex);
  }
  /**
   * @private
   */;
  _proto.objectVisibilityUpdated = function objectVisibilityUpdated(viewObject, visible, notify) {
    if (notify === void 0) {
      notify = true;
    }
    if (visible) {
      this.visibleObjects[viewObject.id] = viewObject;
      _classPrivateFieldLooseBase(this, _numVisibleObjects$1)[_numVisibleObjects$1]++;
    } else {
      delete this.visibleObjects[viewObject.id];
      _classPrivateFieldLooseBase(this, _numVisibleObjects$1)[_numVisibleObjects$1]--;
    }
    _classPrivateFieldLooseBase(this, _visibleObjectIds$1)[_visibleObjectIds$1] = null; // Lazy regenerate
    if (notify) {
      this.onObjectVisibility.dispatch(this, viewObject);
    }
    this.view.objectVisibilityUpdated(viewObject, visible, notify);
  }
  /**
   * @private
   */;
  _proto.objectXRayedUpdated = function objectXRayedUpdated(viewObject, xrayed) {
    if (xrayed) {
      this.xrayedObjects[viewObject.id] = viewObject;
      _classPrivateFieldLooseBase(this, _numXRayedObjects$1)[_numXRayedObjects$1]++;
    } else {
      delete this.xrayedObjects[viewObject.id];
      _classPrivateFieldLooseBase(this, _numXRayedObjects$1)[_numXRayedObjects$1]--;
    }
    _classPrivateFieldLooseBase(this, _xrayedObjectIds$1)[_xrayedObjectIds$1] = null; // Lazy regenerate
    this.view.objectXRayedUpdated(viewObject, xrayed);
  }
  /**
   * @private
   */;
  _proto.objectHighlightedUpdated = function objectHighlightedUpdated(viewObject, highlighted) {
    if (highlighted) {
      this.highlightedObjects[viewObject.id] = viewObject;
      _classPrivateFieldLooseBase(this, _numHighlightedObjects$1)[_numHighlightedObjects$1]++;
    } else {
      delete this.highlightedObjects[viewObject.id];
      _classPrivateFieldLooseBase(this, _numHighlightedObjects$1)[_numHighlightedObjects$1]--;
    }
    _classPrivateFieldLooseBase(this, _highlightedObjectIds$1)[_highlightedObjectIds$1] = null; // Lazy regenerate
    this.view.objectHighlightedUpdated(viewObject, highlighted);
  }
  /**
   * @private
   */;
  _proto.objectSelectedUpdated = function objectSelectedUpdated(viewObject, selected) {
    if (selected) {
      this.selectedObjects[viewObject.id] = viewObject;
      _classPrivateFieldLooseBase(this, _numSelectedObjects$1)[_numSelectedObjects$1]++;
    } else {
      delete this.selectedObjects[viewObject.id];
      _classPrivateFieldLooseBase(this, _numSelectedObjects$1)[_numSelectedObjects$1]--;
    }
    _classPrivateFieldLooseBase(this, _selectedObjectIds$1)[_selectedObjectIds$1] = null; // Lazy regenerate
    this.view.objectSelectedUpdated(viewObject, selected);
  }
  /**
   * @private
   */;
  _proto.objectColorizeUpdated = function objectColorizeUpdated(viewObject, colorized) {
    if (colorized) {
      this.colorizedObjects[viewObject.id] = viewObject;
      _classPrivateFieldLooseBase(this, _numColorizedObjects$1)[_numColorizedObjects$1]++;
    } else {
      delete this.colorizedObjects[viewObject.id];
      _classPrivateFieldLooseBase(this, _numColorizedObjects$1)[_numColorizedObjects$1]--;
    }
    _classPrivateFieldLooseBase(this, _colorizedObjectIds$1)[_colorizedObjectIds$1] = null; // Lazy regenerate
    this.view.objectColorizeUpdated(viewObject, colorized);
  }
  /**
   * @private
   */;
  _proto.objectOpacityUpdated = function objectOpacityUpdated(viewObject, opacityUpdated) {
    if (opacityUpdated) {
      this.opacityObjects[viewObject.id] = viewObject;
      _classPrivateFieldLooseBase(this, _numOpacityObjects$1)[_numOpacityObjects$1]++;
    } else {
      delete this.opacityObjects[viewObject.id];
      _classPrivateFieldLooseBase(this, _numOpacityObjects$1)[_numOpacityObjects$1]--;
    }
    _classPrivateFieldLooseBase(this, _opacityObjectIds$1)[_opacityObjectIds$1] = null; // Lazy regenerate
    this.view.objectOpacityUpdated(viewObject, opacityUpdated);
  }
  /**
   * Updates the visibility of the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
   *
   * - Updates {@link @xeokit/viewer!ViewObject.visible} on the Objects with the given IDs.
   * - Updates {@link @xeokit/view!ViewLayer.visibleObjects} and {@link @xeokit/view!ViewLayer.numVisibleObjects}.
   *
   * @param {String[]} objectIds Array of {@link @xeokit/viewer!ViewObject.id} values.
   * @param visible Whether or not to cull.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsVisible = function setObjectsVisible(objectIds, visible) {
    return this.withObjects(objectIds, function (viewObject) {
      var changed = viewObject.visible !== visible;
      viewObject.visible = visible;
      return changed;
    });
  }
  /**
   * Updates the collidability of the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
   *
   * Updates {@link @xeokit/viewer!ViewObject.collidable} on the Objects with the given IDs.
   *
   * @param {String[]} objectIds Array of {@link @xeokit/viewer!ViewObject.id} values.
   * @param collidable Whether or not to cull.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsCollidable = function setObjectsCollidable(objectIds, collidable) {
    return this.withObjects(objectIds, function (viewObject) {
      var changed = viewObject.collidable !== collidable;
      viewObject.collidable = collidable;
      return changed;
    });
  }
  /**
   * Updates the culled status of the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
   *
   * Updates {@link @xeokit/viewer!ViewObject.culled} on the Objects with the given IDs.
   *
   * @param {String[]} objectIds Array of {@link @xeokit/viewer!ViewObject.id} values.
   * @param culled Whether or not to cull.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsCulled = function setObjectsCulled(objectIds, culled) {
    return this.withObjects(objectIds, function (viewObject) {
      var changed = viewObject.culled !== culled;
      viewObject.culled = culled;
      return changed;
    });
  }
  /**
   * Selects or deselects the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
   *
   * - Updates {@link @xeokit/viewer!ViewObject.selected} on the Objects with the given IDs.
   * - Updates {@link @xeokit/view!ViewLayer.selectedObjects} and {@link @xeokit/view!ViewLayer.numSelectedObjects}.
   *
   * @param  objectIds One or more {@link @xeokit/viewer!ViewObject.id} values.
   * @param selected Whether or not to select.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsSelected = function setObjectsSelected(objectIds, selected) {
    return this.withObjects(objectIds, function (viewObject) {
      var changed = viewObject.selected !== selected;
      viewObject.selected = selected;
      return changed;
    });
  }
  /**
   * Highlights or un-highlights the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
   *
   * - Updates {@link @xeokit/viewer!ViewObject.highlighted} on the Objects with the given IDs.
   * - Updates {@link @xeokit/view!ViewLayer.highlightedObjects} and {@link @xeokit/view!ViewLayer.numHighlightedObjects}.
   *
   * @param  objectIds One or more {@link @xeokit/viewer!ViewObject.id} values.
   * @param highlighted Whether or not to highlight.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsHighlighted = function setObjectsHighlighted(objectIds, highlighted) {
    return this.withObjects(objectIds, function (viewObject) {
      var changed = viewObject.highlighted !== highlighted;
      viewObject.highlighted = highlighted;
      return changed;
    });
  }
  /**
   * Applies or removes X-ray rendering for the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
   *
   * - Updates {@link @xeokit/viewer!ViewObject.xrayed} on the Objects with the given IDs.
   * - Updates {@link @xeokit/view!ViewLayer.xrayedObjects} and {@link @xeokit/view!ViewLayer.numXRayedObjects}.
   *
   * @param  objectIds One or more {@link @xeokit/viewer!ViewObject.id} values.
   * @param xrayed Whether or not to xray.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsXRayed = function setObjectsXRayed(objectIds, xrayed) {
    return this.withObjects(objectIds, function (viewObject) {
      var changed = viewObject.xrayed !== xrayed;
      if (changed) {
        viewObject.xrayed = xrayed;
      }
      return changed;
    });
  }
  /**
   * Colorizes the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
   *
   * - Updates {@link @xeokit/viewer!ViewObject.colorize} on the Objects with the given IDs.
   * - Updates {@link @xeokit/view!ViewLayer.colorizedObjects} and {@link @xeokit/view!ViewLayer.numColorizedObjects}.
   *
   * @param  objectIds One or more {@link @xeokit/viewer!ViewObject.id} values.
   * @param colorize - RGB colorize factors in range ````[0..1,0..1,0..1]````.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} changed opacity, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsColorized = function setObjectsColorized(objectIds, colorize) {
    return this.withObjects(objectIds, function (viewObject) {
      viewObject.colorize = colorize;
    });
  }
  /**
   * Sets the opacity of the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
   *
   * - Updates {@link @xeokit/viewer!ViewObject.opacity} on the Objects with the given IDs.
   * - Updates {@link @xeokit/view!ViewLayer.opacityObjects} and {@link @xeokit/view!ViewLayer.numOpacityObjects}.
   *
   * @param  objectIds - One or more {@link @xeokit/viewer!ViewObject.id} values.
   * @param opacity - Opacity factor in range ````[0..1]````.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} changed opacity, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsOpacity = function setObjectsOpacity(objectIds, opacity) {
    return this.withObjects(objectIds, function (viewObject) {
      var changed = viewObject.opacity !== opacity;
      if (changed) {
        viewObject.opacity = opacity;
      }
      return changed;
    });
  }
  /**
   * Sets the pickability of the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
   *
   * - Updates {@link @xeokit/viewer!ViewObject.pickable} on the Objects with the given IDs.
   * - Enables or disables the ability to pick the given Objects with {@link @xeokit/view!ViewLayer.pick}.
   *
   * @param {String[]} objectIds Array of {@link @xeokit/viewer!ViewObject.id} values.
   * @param pickable Whether or not to set pickable.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsPickable = function setObjectsPickable(objectIds, pickable) {
    return this.withObjects(objectIds, function (viewObject) {
      var changed = viewObject.pickable !== pickable;
      if (changed) {
        viewObject.pickable = pickable;
      }
      return changed;
    });
  }
  /**
   * Sets the clippability of the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
   *
   * - Updates {@link @xeokit/viewer!ViewObject.clippable} on the Objects with the given IDs.
   * - Enables or disables the ability to pick the given Objects with {@link @xeokit/view!ViewLayer.pick}.
   *
   * @param {String[]} objectIds Array of {@link @xeokit/viewer!ViewObject.id} values.
   * @param clippable Whether or not to set clippable.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsClippable = function setObjectsClippable(objectIds, clippable) {
    return this.withObjects(objectIds, function (viewObject) {
      var changed = viewObject.clippable !== clippable;
      if (changed) {
        viewObject.clippable = clippable;
      }
      return changed;
    });
  }
  /**
   * Iterates with a callback over the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
   *
   * @param  objectIds One or more {@link @xeokit/viewer!ViewObject.id} values.
   * @param callback Callback to execute on each {@link @xeokit/viewer!ViewObject}.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */;
  _proto.withObjects = function withObjects(objectIds, callback) {
    var changed = false;
    for (var i = 0, len = objectIds.length; i < len; i++) {
      var id = objectIds[i];
      var viewObject = this.objects[id];
      if (viewObject) {
        changed = callback(viewObject) || changed;
      }
    }
    return changed;
  };
  /**
   * Destroys this ViewLayer.
   *
   * Causes {@link @xeokit/viewer!Viewer} to fire a "viewDestroyed" event.
   */
  _proto.destroy = function destroy() {
    _Component.prototype.destroy.call(this);
  };
  _createClass(ViewLayer, [{
    key: "gammaFactor",
    get: function get() {
      return 1.0;
    }
    /**
     * Sets which rendering modes in which to render the {@linkk ViewObject | ViewObjects} in this ViewLayer.
     *
     * Default value is [].
     */
  }, {
    key: "renderModes",
    get:
    /**
     * Gets which rendering modes in which to render the {@linkk ViewObject | ViewObjects} in this ViewLayer.
     *
     * Default value is [].
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _renderModes)[_renderModes];
    }
    /**
     * Gets the number of {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _renderModes)[_renderModes] = value;
      this.view.redraw();
    }
  }, {
    key: "numObjects",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _numObjects$1)[_numObjects$1];
    }
    /**
     * Gets the IDs of the {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
     */
  }, {
    key: "objectIds",
    get: function get() {
      if (!_classPrivateFieldLooseBase(this, _objectIds$1)[_objectIds$1]) {
        _classPrivateFieldLooseBase(this, _objectIds$1)[_objectIds$1] = Object.keys(this.objects);
      }
      return _classPrivateFieldLooseBase(this, _objectIds$1)[_objectIds$1];
    }
    /**
     * Gets the number of visible {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
     */
  }, {
    key: "numVisibleObjects",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _numVisibleObjects$1)[_numVisibleObjects$1];
    }
    /**
     * Gets the IDs of the visible {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
     */
  }, {
    key: "visibleObjectIds",
    get: function get() {
      if (!_classPrivateFieldLooseBase(this, _visibleObjectIds$1)[_visibleObjectIds$1]) {
        _classPrivateFieldLooseBase(this, _visibleObjectIds$1)[_visibleObjectIds$1] = Object.keys(this.visibleObjects);
      }
      return _classPrivateFieldLooseBase(this, _visibleObjectIds$1)[_visibleObjectIds$1];
    }
    /**
     * Gets the number of X-rayed {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
     */
  }, {
    key: "numXRayedObjects",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _numXRayedObjects$1)[_numXRayedObjects$1];
    }
    /**
     * Gets the IDs of the X-rayed {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
     */
  }, {
    key: "xrayedObjectIds",
    get: function get() {
      if (!_classPrivateFieldLooseBase(this, _xrayedObjectIds$1)[_xrayedObjectIds$1]) {
        _classPrivateFieldLooseBase(this, _xrayedObjectIds$1)[_xrayedObjectIds$1] = Object.keys(this.xrayedObjects);
      }
      return _classPrivateFieldLooseBase(this, _xrayedObjectIds$1)[_xrayedObjectIds$1];
    }
    /**
     * Gets the number of highlighted {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
     */
  }, {
    key: "numHighlightedObjects",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _numHighlightedObjects$1)[_numHighlightedObjects$1];
    }
    /**
     * Gets the IDs of the highlighted {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
     */
  }, {
    key: "highlightedObjectIds",
    get: function get() {
      if (!_classPrivateFieldLooseBase(this, _highlightedObjectIds$1)[_highlightedObjectIds$1]) {
        _classPrivateFieldLooseBase(this, _highlightedObjectIds$1)[_highlightedObjectIds$1] = Object.keys(this.highlightedObjects);
      }
      return _classPrivateFieldLooseBase(this, _highlightedObjectIds$1)[_highlightedObjectIds$1];
    }
    /**
     * Gets the number of selected {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
     */
  }, {
    key: "numSelectedObjects",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _numSelectedObjects$1)[_numSelectedObjects$1];
    }
    /**
     * Gets the IDs of the selected {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
     */
  }, {
    key: "selectedObjectIds",
    get: function get() {
      if (!_classPrivateFieldLooseBase(this, _selectedObjectIds$1)[_selectedObjectIds$1]) {
        _classPrivateFieldLooseBase(this, _selectedObjectIds$1)[_selectedObjectIds$1] = Object.keys(this.selectedObjects);
      }
      return _classPrivateFieldLooseBase(this, _selectedObjectIds$1)[_selectedObjectIds$1];
    }
    /**
     * Gets the number of colorized {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
     */
  }, {
    key: "numColorizedObjects",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _numColorizedObjects$1)[_numColorizedObjects$1];
    }
    /**
     * Gets the IDs of the colorized {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer.
     */
  }, {
    key: "colorizedObjectIds",
    get: function get() {
      if (!_classPrivateFieldLooseBase(this, _colorizedObjectIds$1)[_colorizedObjectIds$1]) {
        _classPrivateFieldLooseBase(this, _colorizedObjectIds$1)[_colorizedObjectIds$1] = Object.keys(this.colorizedObjects);
      }
      return _classPrivateFieldLooseBase(this, _colorizedObjectIds$1)[_colorizedObjectIds$1];
    }
    /**
     * Gets the IDs of the {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer that have updated opacities.
     */
  }, {
    key: "opacityObjectIds",
    get: function get() {
      if (!_classPrivateFieldLooseBase(this, _opacityObjectIds$1)[_opacityObjectIds$1]) {
        _classPrivateFieldLooseBase(this, _opacityObjectIds$1)[_opacityObjectIds$1] = Object.keys(this.opacityObjects);
      }
      return _classPrivateFieldLooseBase(this, _opacityObjectIds$1)[_opacityObjectIds$1];
    }
    /**
     * Gets the number of {@link @xeokit/viewer!ViewObject | ViewObjects} in this ViewLayer that have updated opacities.
     */
  }, {
    key: "numOpacityObjects",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _numOpacityObjects$1)[_numOpacityObjects$1];
    }
  }]);
  return ViewLayer;
}(Component);
function _initViewObjects2() {
  var _this2 = this;
  var models = this.viewer.scene.models;
  for (var id in models) {
    var model = models[id];
    _classPrivateFieldLooseBase(this, _createViewObjects)[_createViewObjects](model);
  }
  this.viewer.scene.onModelCreated.subscribe(function (scene, model) {
    _classPrivateFieldLooseBase(_this2, _createViewObjects)[_createViewObjects](model);
  });
  this.viewer.scene.onModelDestroyed.subscribe(function (scene, model) {
    _classPrivateFieldLooseBase(_this2, _destroyViewObjects)[_destroyViewObjects](model);
  });
}
function _createViewObjects2(model) {
  var sceneObjects = model.objects;
  for (var id in sceneObjects) {
    var sceneObject = sceneObjects[id];
    var rendererViewObject = this.viewer.renderer.rendererViewObjects[id];
    if (rendererViewObject.layerId == this.id) {
      var viewObject = new ViewObject(this, sceneObject, rendererViewObject);
      this.objects[viewObject.id] = viewObject;
      _classPrivateFieldLooseBase(this, _numObjects$1)[_numObjects$1]++;
      _classPrivateFieldLooseBase(this, _objectIds$1)[_objectIds$1] = null; // Lazy regenerate
    }
  }
}
function _destroyViewObjects2(model) {
  var viewerObjects = model.objects;
  for (var id in viewerObjects) {
    var viewerObject = viewerObjects[id];
    var viewObject = this.objects[viewerObject.id];
    viewObject._destroy();
    _classPrivateFieldLooseBase(this, _numObjects$1)[_numObjects$1]--;
    _classPrivateFieldLooseBase(this, _objectIds$1)[_objectIds$1] = null; // Lazy regenerate
  }
}

/**
 * Configures the appearance of {@link @xeokit/viewer!ViewObject | ViewObjects} when they are xrayed, highlighted or selected.
 *
 * ## Summary
 *
 * * Located at {@link View.xrayMaterial}, {@link View.highlightMaterial} and {@link View.selectedMaterial}.
 * * XRay a {@link @xeokit/viewer!ViewObject} by setting {@link @xeokit/viewer!ViewObject.xrayed} ````true````.
 * * Highlight a {@link @xeokit/viewer!ViewObject} by setting {@link @xeokit/viewer!ViewObject.highlighted} ````true````.
 * * Select a {@link @xeokit/viewer!ViewObject} by setting {@link @xeokit/viewer!ViewObject.selected} ````true````.
 */
var _state$b = /*#__PURE__*/_classPrivateFieldLooseKey("state");
var EmphasisMaterial = /*#__PURE__*/function (_Component) {
  _inheritsLoose(EmphasisMaterial, _Component);
  /**
   * @private
   */
  function EmphasisMaterial(view, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _Component.call(this, view, options) || this;
    /**
     * The View to which this EmphasisMaterial belongs.
     */
    _this.view = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _state$b, {
      writable: true,
      value: void 0
    });
    _this.view = view;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _state$b)[_state$b] = {
      fill: !!options.fill,
      fillColor: new Float32Array(options.fillColor || [0.4, 0.4, 0.4]),
      fillAlpha: options.fillAlpha !== undefined && options.fillAlpha !== null ? options.fillAlpha : 0.2,
      edges: options.edges !== false,
      edgeColor: new Float32Array(options.edgeColor || [0.2, 0.2, 0.2]),
      edgeAlpha: options.edgeAlpha !== undefined && options.edgeAlpha !== null ? options.edgeAlpha : 0.5,
      edgeWidth: options.edgeWidth !== undefined && options.edgeWidth !== null ? options.edgeWidth : 1,
      backfaces: !!options.backfaces
    };
    return _this;
  }
  /**
   * Sets if the surfaces of emphasized {@link @xeokit/viewer!ViewObject | ViewObjects} are filled with color.
   *
   * Default is ````true````.
   */
  var _proto = EmphasisMaterial.prototype;
  /**
   * @private
   */
  _proto.destroy = function destroy() {
    _Component.prototype.destroy.call(this);
  };
  _createClass(EmphasisMaterial, [{
    key: "fill",
    get:
    /**
     * Gets if the surfaces of emphasized {@link @xeokit/viewer!ViewObject | ViewObjects} are filled with color.
     *
     * Default is ````true````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$b)[_state$b].fill;
    }
    /**
     * Sets the RGB surface fill color for the surfaces of emphasized {@link @xeokit/viewer!ViewObject | ViewObjects}.
     *
     * Default is ````[0.4, 0.4, 0.4]````.
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$b)[_state$b].fill === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$b)[_state$b].fill = value;
      this.view.redraw();
    }
  }, {
    key: "fillColor",
    get:
    /**
     * Gets the RGB surface fill color for the surfaces of emphasized {@link @xeokit/viewer!ViewObject | ViewObjects}.
     *
     * Default is ````[0.4, 0.4, 0.4]````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$b)[_state$b].fillColor;
    }
    /**
     * Sets the transparency of the surfaces of emphasized {@link @xeokit/viewer!ViewObject | ViewObjects}.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default is ````0.2````.
     */,
    set: function set(value) {
      var fillColor = _classPrivateFieldLooseBase(this, _state$b)[_state$b].fillColor;
      if (fillColor[0] === value[0] && fillColor[1] === value[1] && fillColor[2] === value[2]) {
        return;
      }
      fillColor[0] = 0.4;
      fillColor[1] = 0.4;
      fillColor[2] = 0.4;
      this.view.redraw();
    }
  }, {
    key: "fillAlpha",
    get:
    /**
     * Gets the transparency of the surfaces of emphasized {@link @xeokit/viewer!ViewObject | ViewObjects}.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default is ````0.2````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$b)[_state$b].fillAlpha;
    }
    /**
     * Sets if the edges on emphasized {@link @xeokit/viewer!ViewObject | ViewObjects} are visible.
     *
     * Default is ````true````.
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$b)[_state$b].fillAlpha === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$b)[_state$b].fillAlpha = value;
      this.view.redraw();
    }
  }, {
    key: "edges",
    get:
    /**
     * Gets if the edges on emphasized {@link @xeokit/viewer!ViewObject | ViewObjects} are visible.
     *
     * Default is ````true````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$b)[_state$b].edges;
    }
    /**
     * Sets the RGB color of the edges of emphasized {@link @xeokit/viewer!ViewObject | ViewObjects}.
     *
     * Default is ```` [0.2, 0.2, 0.2]````.
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$b)[_state$b].edges === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$b)[_state$b].edges = value;
      this.view.redraw();
    }
  }, {
    key: "edgeColor",
    get:
    /**
     * Gets the RGB color of the edges of emphasized {@link @xeokit/viewer!ViewObject | ViewObjects}.
     *
     * Default is ```` [0.2, 0.2, 0.2]````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$b)[_state$b].edgeColor;
    }
    /**
     * Sets the transparency of the edges of emphasized {@link @xeokit/viewer!ViewObject | ViewObjects}.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default is ````0.2````.
     */,
    set: function set(value) {
      var edgeColor = _classPrivateFieldLooseBase(this, _state$b)[_state$b].edgeColor;
      if (edgeColor[0] === value[0] && edgeColor[1] === value[1] && edgeColor[2] === value[2]) {
        return;
      }
      edgeColor[0] = 0.2;
      edgeColor[1] = 0.2;
      edgeColor[2] = 0.2;
      this.view.redraw();
    }
  }, {
    key: "edgeAlpha",
    get:
    /**
     * Gets the transparency of the edges of emphasized {@link @xeokit/viewer!ViewObject | ViewObjects}.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default is ````0.2````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$b)[_state$b].edgeAlpha;
    }
    /**
     * Sets the width of the edges of emphasized {@link @xeokit/viewer!ViewObject | ViewObjects}.
     *
     * Default value is ````1.0```` pixels.
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$b)[_state$b].edgeAlpha === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$b)[_state$b].edgeAlpha = value;
      this.view.redraw();
    }
  }, {
    key: "edgeWidth",
    get:
    /**
     * Gets the width of the edges of emphasized {@link @xeokit/viewer!ViewObject | ViewObjects}.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0```` pixels.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$b)[_state$b].edgeWidth;
    }
    /**
     * Sets whether to render backfaces of emphasized {@link @xeokit/viewer!ViewObject | ViewObjects} when {@link EmphasisMaterial.fill} is ````true````.
     *
     * Default is ````false````.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _state$b)[_state$b].edgeWidth = value;
      this.view.redraw();
    }
  }, {
    key: "backfaces",
    get:
    /**
     * Gets whether to render backfaces of emphasized {@link @xeokit/viewer!ViewObject | ViewObjects} when {@link EmphasisMaterial.fill} is ````true````.
     *
     * Default is ````false````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$b)[_state$b].backfaces;
    }
    /**
     * @private
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$b)[_state$b].backfaces === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$b)[_state$b].backfaces = value;
      this.view.redraw();
    }
  }, {
    key: "hash",
    get: function get() {
      return "";
    }
  }]);
  return EmphasisMaterial;
}(Component);

/**
 * Configures the appearance of {@link @xeokit/viewer!ViewObject | ViewObjects} when their edges are emphasised.
 *
 * ## Summary
 *
 * * Located at {@link View.edges}.
 * * Emphasise edges of a {@link @xeokit/viewer!ViewObject} by setting {@link @xeokit/viewer!ViewObject.enabled} ````true````.
 */
var _state$a = /*#__PURE__*/_classPrivateFieldLooseKey("state");
var Edges = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Edges, _Component);
  /**
   * @private
   */
  function Edges(view, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _Component.call(this, view, options) || this;
    /**
     * The View to which this Edges belongs.
     */
    _this.view = void 0;
    /**
     * @private
     */
    Object.defineProperty(_assertThisInitialized(_this), _state$a, {
      writable: true,
      value: void 0
    });
    _this.view = view;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _state$a)[_state$a] = {
      renderModes: options.renderModes || [QualityRender],
      enabled: options.enabled !== false,
      edgeColor: new Float32Array(options.edgeColor || [0.2, 0.2, 0.2]),
      edgeAlpha: options.edgeAlpha !== undefined && options.edgeAlpha !== null ? options.edgeAlpha : 0.5,
      edgeWidth: options.edgeWidth !== undefined && options.edgeWidth !== null ? options.edgeWidth : 1
    };
    return _this;
  }
  /**
   * Sets which rendering modes in which to render edges.
   *
   * Accepted modes are {@link @xeokit/constants!QualityRender} and {@link @xeokit/constants!FastRender}.
   *
   * Default value is [{@link @xeokit/constants!QualityRender}].
   */
  var _proto = Edges.prototype;
  /**
   * @private
   */
  _proto.destroy = function destroy() {
    _Component.prototype.destroy.call(this);
  };
  _createClass(Edges, [{
    key: "renderModes",
    get:
    /**
     * Gets which rendering modes in which to render edges.
     *
     * Accepted modes are {@link @xeokit/constants!QualityRender} and {@link @xeokit/constants!FastRender}.
     *
     * Default value is [{@link @xeokit/constants!QualityRender}].
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$a)[_state$a].renderModes;
    }
    /**
     * Sets if edges of {@link ViewObject | ViewObjects} are visible.
     *
     * Default is ````true````.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _state$a)[_state$a].renderModes = value;
      this.view.redraw();
    }
  }, {
    key: "enabled",
    get:
    /**
     * Gets if edges of {@link ViewObject | ViewObjects} are visible.
     *
     * Default is ````true````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$a)[_state$a].enabled;
    }
    /**
     * Sets RGB edge color for {@link ViewObject | ViewObjects}.
     *
     * Default value is ````[0.2, 0.2, 0.2]````.
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$a)[_state$a].enabled === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$a)[_state$a].enabled = value;
      this.view.redraw();
    }
  }, {
    key: "edgeColor",
    get:
    /**
     * Gets RGB edge color for {@link ViewObject | ViewObjects}.
     *
     * Default value is ````[0.2, 0.2, 0.2]````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$a)[_state$a].edgeColor;
    }
    /**
     * Sets edge transparency for {@link ViewObject | ViewObjects}.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default value is ````1.0````.
     */,
    set: function set(value) {
      var edgeColor = _classPrivateFieldLooseBase(this, _state$a)[_state$a].edgeColor;
      if (value && edgeColor[0] === value[0] && edgeColor[1] === value[1] && edgeColor[2] === value[2]) {
        return;
      }
      edgeColor[0] = 0.2;
      edgeColor[1] = 0.2;
      edgeColor[2] = 0.2;
      this.view.redraw();
    }
  }, {
    key: "edgeAlpha",
    get:
    /**
     * Gets edge transparency for {@link ViewObject | ViewObjects}.
     *
     * A value of ````0.0```` indicates fully transparent, ````1.0```` is fully opaque.
     *
     * Default value is ````1.0````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$a)[_state$a].edgeAlpha;
    }
    /**
     * Sets edge width for {@link ViewObject | ViewObjects}.
     *
     * Default value is ````1.0```` pixels.
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$a)[_state$a].edgeAlpha === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$a)[_state$a].edgeAlpha = value;
      this.view.redraw();
    }
  }, {
    key: "edgeWidth",
    get:
    /**
     * Gets edge width for {@link ViewObject | ViewObjects}.
     *
     * This is not supported by WebGL implementations based on DirectX [2019].
     *
     * Default value is ````1.0```` pixels.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$a)[_state$a].edgeWidth;
    },
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$a)[_state$a].edgeWidth === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$a)[_state$a].edgeWidth = value;
      this.view.redraw();
    }
  }]);
  return Edges;
}(Component);

/**
 * Configures the size and shape of {@link @xeokit/viewer!ViewObject | ViewObjects} that represent clouds of points.
 *
 * ## Summary
 *
 * * Located at {@link View.pointsMaterial}.
 * * Supports round and square points.
 * * Optional perspective point scaling.
 */
var _state$9 = /*#__PURE__*/_classPrivateFieldLooseKey("state");
var PointsMaterial = /*#__PURE__*/function (_Component) {
  _inheritsLoose(PointsMaterial, _Component);
  /**
   * @private
   */
  function PointsMaterial(view, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _Component.call(this, view, options) || this;
    /**
     * The View to which this PointsMaterial belongs.
     */
    _this.view = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _state$9, {
      writable: true,
      value: void 0
    });
    _this.view = view;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _state$9)[_state$9] = {
      pointSize: options.pointSize !== undefined && options.pointSize !== null ? options.pointSize : 1,
      roundPoints: options.roundPoints !== false,
      perspectivePoints: options.perspectivePoints !== false,
      minPerspectivePointSize: options.minPerspectivePointSize !== undefined && options.minPerspectivePointSize !== null ? options.minPerspectivePointSize : 1,
      maxPerspectivePointSize: options.maxPerspectivePointSize !== undefined && options.maxPerspectivePointSize !== null ? options.maxPerspectivePointSize : 6,
      filterIntensity: !!options.filterIntensity,
      minIntensity: options.minIntensity !== undefined && options.minIntensity !== null ? options.minIntensity : 0,
      maxIntensity: options.maxIntensity !== undefined && options.maxIntensity !== null ? options.maxIntensity : 1
    };
    return _this;
  }
  /**
   * Sets point size.
   *
   * Default value is ````2.0```` pixels.
   */
  var _proto = PointsMaterial.prototype;
  /**
   * @private
   */
  _proto.destroy = function destroy() {
    _Component.prototype.destroy.call(this);
  };
  _createClass(PointsMaterial, [{
    key: "pointSize",
    get:
    /**
     * Gets point size.
     *
     * Default value is ````2.0```` pixels.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$9)[_state$9].pointSize;
    }
    /**
     * Sets if points are round or square.
     *
     * Default is ````true```` to set points round.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _state$9)[_state$9].pointSize = value;
      this.view.redraw();
    }
  }, {
    key: "roundPoints",
    get:
    /**
     * Gets if points are round or square.
     *
     * Default is ````true```` to set points round.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$9)[_state$9].roundPoints;
    }
    /**
     * Sets if rendered point size reduces with distance when {@link Camera.projection} is set to ````PerspectiveProjectionType````.
     *
     * Default is ````true````.
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$9)[_state$9].roundPoints === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$9)[_state$9].roundPoints = value;
      this.view.rebuild();
    }
  }, {
    key: "perspectivePoints",
    get:
    /**
     * Gets if rendered point size reduces with distance when {@link Camera.projection} is set to PerspectiveProjectionType.
     *
     * Default is ````false````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$9)[_state$9].perspectivePoints;
    }
    /**
     * Sets the minimum rendered size of points when {@link PointsMaterial.perspectivePoints} is ````true````.
     *
     * Default value is ````1.0```` pixels.
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$9)[_state$9].perspectivePoints === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$9)[_state$9].perspectivePoints = value;
      this.view.rebuild();
    }
  }, {
    key: "minPerspectivePointSize",
    get:
    /**
     * Gets the minimum rendered size of points when {@link PointsMaterial.perspectivePoints} is ````true````.
     *
     * Default value is ````1.0```` pixels.
     *
     * @type {Number}
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$9)[_state$9].minPerspectivePointSize;
    }
    /**
     * Sets the maximum rendered size of points when {@link PointsMaterial.perspectivePoints} is ````true````.
     *
     * Default value is ````6```` pixels.
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$9)[_state$9].minPerspectivePointSize === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$9)[_state$9].minPerspectivePointSize = value;
      this.view.rebuild();
    }
  }, {
    key: "maxPerspectivePointSize",
    get:
    /**
     * Gets the maximum rendered size of points when {@link PointsMaterial.perspectivePoints} is ````true````.
     *
     * Default value is ````6```` pixels.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$9)[_state$9].maxPerspectivePointSize;
    }
    /**
     * Sets if rendered point size reduces with distance when {@link Camera.projection} is set to ````PerspectiveProjectionType````.
     *
     * Default is ````false````.
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$9)[_state$9].maxPerspectivePointSize === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$9)[_state$9].maxPerspectivePointSize = value;
      this.view.rebuild();
    }
  }, {
    key: "filterIntensity",
    get:
    /**
     * Gets if rendered point size reduces with distance when {@link Camera.projection} is set to PerspectiveProjectionType.
     *
     * Default is ````false````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$9)[_state$9].filterIntensity;
    }
    /**
     * Sets the minimum rendered size of points when {@link PointsMaterial.perspectivePoints} is ````true````.
     *
     * Default value is ````0````.
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$9)[_state$9].filterIntensity === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$9)[_state$9].filterIntensity = value;
      this.view.rebuild();
    }
  }, {
    key: "minIntensity",
    get:
    /**
     * Gets the minimum rendered size of points when {@link PointsMaterial.filterIntensity} is ````true````.
     *
     * Default value is ````0````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$9)[_state$9].minIntensity;
    }
    /**
     * Sets the maximum rendered size of points when {@link PointsMaterial.filterIntensity} is ````true````.
     *
     * Default value is ````1````.
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$9)[_state$9].minIntensity === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$9)[_state$9].minIntensity = value;
      this.view.redraw();
    }
  }, {
    key: "maxIntensity",
    get:
    /**
     * Gets the maximum rendered size of points when {@link PointsMaterial.filterIntensity} is ````true````.
     *
     * Default value is ````1````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$9)[_state$9].maxIntensity;
    }
    /**
     * @private
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$9)[_state$9].maxIntensity === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$9)[_state$9].maxIntensity = value;
      this.view.redraw();
    }
  }, {
    key: "hash",
    get: function get() {
      var state = _classPrivateFieldLooseBase(this, _state$9)[_state$9];
      return state.pointSize + ";\n        " + state.roundPoints + ";\n        " + state.perspectivePoints + ";\n        " + state.minPerspectivePointSize + ";\n        " + state.maxPerspectivePointSize + ";\n        " + state.filterIntensity;
    }
  }]);
  return PointsMaterial;
}(Component);

/**
 * PerspectiveProjection projection configuration for a {@link @xeokit/viewer!Camera} .
 *
 * ## Summary
 *
 * * Located at {@link @xeokit/viewer!Camera.perspectiveProjection | Camera.perspectiveProjection}.
 * * Implicitly sets the left, right, top, bottom frustum planes using {@link @xeokit/viewer!PerspectiveProjection.fov | PerspectiveProjection.fov}.
 * * {@link @xeokit/viewer!PerspectiveProjection.near | PerspectiveProjection.near} and {@link @xeokit/viewer!PerspectiveProjection.far| PerspectiveProjection.far} specify the distances to the clipping planes.
 * * {@link @xeokit/viewer!PerspectiveProjection.onProjMatrix | PerspectiveProjection.onProjMatrix} will fire an event whenever {@link @xeokit/viewer!PerspectiveProjection.projMatrix | PerspectiveProjection.projMatrix} updates, which indicates that one or more other properties have updated.
 */
var _state$8 = /*#__PURE__*/_classPrivateFieldLooseKey("state");
var _inverseMatrixDirty$2 = /*#__PURE__*/_classPrivateFieldLooseKey("inverseMatrixDirty");
var _transposedProjMatrixDirty$3 = /*#__PURE__*/_classPrivateFieldLooseKey("transposedProjMatrixDirty");
var _onViewBoundary$1 = /*#__PURE__*/_classPrivateFieldLooseKey("onViewBoundary");
var PerspectiveProjection = /*#__PURE__*/function (_Component) {
  _inheritsLoose(PerspectiveProjection, _Component);
  /**
   * @private
   */
  function PerspectiveProjection(camera, cfg) {
    var _this;
    if (cfg === void 0) {
      cfg = {};
    }
    _this = _Component.call(this, camera, cfg) || this;
    /**
     * The Camera this PerspectiveProjection belongs to.
     */
    _this.camera = void 0;
    /**
     * Emits an event each time {@link @xeokit/viewer!PerspectiveProjection.projMatrix | PerspectiveProjection.projMatrix} updates.
     *
     * @event
     */
    _this.onProjMatrix = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _state$8, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _inverseMatrixDirty$2, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _transposedProjMatrixDirty$3, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _onViewBoundary$1, {
      writable: true,
      value: void 0
    });
    _this.camera = camera;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _state$8)[_state$8] = {
      near: cfg.near || 0.1,
      far: cfg.far || 2000.0,
      fov: cfg.fov || 60.0,
      fovAxis: cfg.fovAxis || "min",
      projMatrix: createMat4(),
      inverseProjMatrix: createMat4(),
      transposedProjMatrix: createMat4()
    };
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _inverseMatrixDirty$2)[_inverseMatrixDirty$2] = true;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _transposedProjMatrixDirty$3)[_transposedProjMatrixDirty$3] = true;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _onViewBoundary$1)[_onViewBoundary$1] = _this.camera.view.onBoundary.subscribe(function () {
      _this.setDirty();
    });
    _this.onProjMatrix = new EventEmitter(new dist.EventDispatcher());
    return _this;
  }
  /**
   * Gets the PerspectiveProjection's field-of-view angle (FOV).
   *
   * Default value is ````60.0````.
   *
   * @returns {Number} Current field-of-view.
   */
  var _proto = PerspectiveProjection.prototype;
  /**
   * @private
   */
  _proto.clean = function clean() {
    var WIDTH_INDEX = 2;
    var HEIGHT_INDEX = 3;
    var boundary = this.camera.view.boundary;
    var aspect = boundary[WIDTH_INDEX] / boundary[HEIGHT_INDEX];
    var fovAxis = _classPrivateFieldLooseBase(this, _state$8)[_state$8].fovAxis;
    var fov = _classPrivateFieldLooseBase(this, _state$8)[_state$8].fov;
    if (fovAxis === "x" || fovAxis === "min" && aspect < 1 || fovAxis === "max" && aspect > 1) {
      fov = fov / aspect;
    }
    fov = Math.min(fov, 120);
    perspectiveMat4(fov * (Math.PI / 180.0), aspect, _classPrivateFieldLooseBase(this, _state$8)[_state$8].near, _classPrivateFieldLooseBase(this, _state$8)[_state$8].far, _classPrivateFieldLooseBase(this, _state$8)[_state$8].projMatrix);
    _classPrivateFieldLooseBase(this, _inverseMatrixDirty$2)[_inverseMatrixDirty$2] = true;
    _classPrivateFieldLooseBase(this, _transposedProjMatrixDirty$3)[_transposedProjMatrixDirty$3] = true;
    this.camera.view.redraw();
    this.onProjMatrix.dispatch(this, _classPrivateFieldLooseBase(this, _state$8)[_state$8].projMatrix);
  }
  /**
   * Un-projects the given View-space coordinates and Screen-space depth, using this PerspectiveProjection projection.
   *
   * @param canvasPos Inputs 2D View-space coordinates.
   * @param screenZ Inputs Screen-space Z coordinate.
   * @param screenPos Outputs 3D Screen/Clip-space coordinates.
   * @param viewPos Outputs un-projected 3D View-space coordinates.
   * @param worldPos Outputs un-projected 3D World-space coordinates.
   */;
  _proto.unproject = function unproject(canvasPos, screenZ, screenPos, viewPos, worldPos) {
    var canvasElement = this.camera.view.canvasElement;
    var halfViewWidth = canvasElement.offsetWidth / 2.0;
    var halfViewHeight = canvasElement.offsetHeight / 2.0;
    screenPos[0] = (canvasPos[0] - halfViewWidth) / halfViewWidth;
    screenPos[1] = (canvasPos[1] - halfViewHeight) / halfViewHeight;
    screenPos[2] = screenZ;
    screenPos[3] = 1.0;
    mulMat4v4(this.inverseProjMatrix, screenPos, viewPos);
    mulVec3Scalar(viewPos, 1.0 / viewPos[3]);
    viewPos[3] = 1.0;
    viewPos[1] *= -1;
    mulMat4v4(this.camera.inverseViewMatrix, viewPos, worldPos);
    return worldPos;
  }
  /** @private
   *
   */;
  _proto.destroy = function destroy() {
    _Component.prototype.destroy.call(this);
    this.camera.view.onBoundary.unsubscribe(_classPrivateFieldLooseBase(this, _onViewBoundary$1)[_onViewBoundary$1]);
    this.onProjMatrix.clear();
  };
  _createClass(PerspectiveProjection, [{
    key: "fov",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$8)[_state$8].fov;
    }
    /**
     * Sets the PerspectiveProjection's field-of-view angle (FOV).
     *
     * Default value is ````60.0````.
     *
     * @param value New field-of-view.
     */,
    set: function set(value) {
      if (value === _classPrivateFieldLooseBase(this, _state$8)[_state$8].fov) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$8)[_state$8].fov = value;
      this.setDirty();
    }
    /**
     * Gets the PerspectiveProjection's FOV axis.
     *
     * Options are ````"x"````, ````"y"```` or ````"min"````, to use the minimum axis.
     *
     * Default value is ````"min"````.
     *
     * @returns {String} The current FOV axis value.
     */
  }, {
    key: "fovAxis",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$8)[_state$8].fovAxis;
    }
    /**
     * Sets the PerspectiveProjection's FOV axis.
     *
     * Options are ````"x"````, ````"y"```` or ````"min"````, to use the minimum axis.
     *
     * Default value ````"min"````.
     *
     * @param value New FOV axis value.
     */,
    set: function set(value) {
      value = value || "min";
      if (_classPrivateFieldLooseBase(this, _state$8)[_state$8].fovAxis === value) {
        return;
      }
      if (value !== "x" && value !== "y" && value !== "min") {
        this.error("Unsupported value for 'fovAxis': " + value + " - defaulting to 'min'");
        value = "min";
      }
      _classPrivateFieldLooseBase(this, _state$8)[_state$8].fovAxis = value;
      this.setDirty();
    }
    /**
     * Gets the position of the PerspectiveProjection's near plane on the positive View-space Z-axis.
     *
     * Default value is ````0.1````.
     *
     * @returns The PerspectiveProjection's near plane position.
     */
  }, {
    key: "near",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$8)[_state$8].near;
    }
    /**
     * Sets the position of the PerspectiveProjection's near plane on the positive View-space Z-axis.
     *
     * Default value is ````0.1````.
     *
     * @param value New PerspectiveProjection near plane position.
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$8)[_state$8].near === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$8)[_state$8].near = value;
      this.setDirty();
    }
    /**
     * Gets the position of this PerspectiveProjection's far plane on the positive View-space Z-axis.
     *
     * @return {Number} The PerspectiveProjection's far plane position.
     */
  }, {
    key: "far",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$8)[_state$8].far;
    }
    /**
     * Sets the position of this PerspectiveProjection's far plane on the positive View-space Z-axis.
     *
     * @param value New PerspectiveProjection far plane position.
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$8)[_state$8].far === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$8)[_state$8].far = value;
      this.setDirty();
    }
    /**
     * Gets the PerspectiveProjection's projection transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @returns  The PerspectiveProjection's projection matrix.
     */
  }, {
    key: "projMatrix",
    get: function get() {
      if (this.dirty) {
        this.cleanIfDirty();
      }
      return _classPrivateFieldLooseBase(this, _state$8)[_state$8].projMatrix;
    }
    /**
     * Gets the inverse of {@link @xeokit/viewer!PerspectiveProjection.projMatrix | PerspectiveProjection.projMatrix}.
     *
     * @returns  The inverse of {@link @xeokit/viewer!PerspectiveProjection.projMatrix | PerspectiveProjection.projMatrix}.
     */
  }, {
    key: "inverseProjMatrix",
    get: function get() {
      if (this.dirty) {
        this.cleanIfDirty();
      }
      if (_classPrivateFieldLooseBase(this, _inverseMatrixDirty$2)[_inverseMatrixDirty$2]) {
        inverseMat4(_classPrivateFieldLooseBase(this, _state$8)[_state$8].projMatrix, _classPrivateFieldLooseBase(this, _state$8)[_state$8].inverseProjMatrix);
        _classPrivateFieldLooseBase(this, _inverseMatrixDirty$2)[_inverseMatrixDirty$2] = false;
      }
      return _classPrivateFieldLooseBase(this, _state$8)[_state$8].inverseProjMatrix;
    }
    /**
     * Gets the transpose of {@link @xeokit/viewer!PerspectiveProjection.projMatrix | PerspectiveProjection.projMatrix}.
     *
     * @returns  The transpose of {@link @xeokit/viewer!PerspectiveProjection.projMatrix | PerspectiveProjection.projMatrix}.
     */
  }, {
    key: "transposedProjMatrix",
    get: function get() {
      if (this.dirty) {
        this.cleanIfDirty();
      }
      if (_classPrivateFieldLooseBase(this, _transposedProjMatrixDirty$3)[_transposedProjMatrixDirty$3]) {
        transposeMat4(_classPrivateFieldLooseBase(this, _state$8)[_state$8].projMatrix, _classPrivateFieldLooseBase(this, _state$8)[_state$8].transposedProjMatrix);
        _classPrivateFieldLooseBase(this, _transposedProjMatrixDirty$3)[_transposedProjMatrixDirty$3] = false;
      }
      return _classPrivateFieldLooseBase(this, _state$8)[_state$8].transposedProjMatrix;
    }
  }]);
  return PerspectiveProjection;
}(Component);
/**
 * The type of this projection.
 */
PerspectiveProjection.type = PerspectiveProjectionType;

/**
 * Orthographic projection configuration for a {@link @xeokit/viewer!Camera} .
 *
 * * Located at {@link @xeokit/viewer!Camera.orthoProjection | Camera.orthoProjection}.
 * * Works like Blender's orthographic projection, where the positions of the left, right, top and bottom planes are implicitly
 * indicated with a single {@link @xeokit/viewer!OrthoProjection.scale | OrthoProjection.scale} property, which causes the frustum to be symmetrical on X and Y axis, large enough to
 * contain the number of units given by {@link @xeokit/viewer!OrthoProjection.scale | OrthoProjection.scale}.
 * * {@link @xeokit/viewer!OrthoProjection.near | OrthoProjection.near} and {@link @xeokit/viewer!OrthoProjection.far | OrthoProjection.far} indicated the distances to the clipping planes.
 * * {@link @xeokit/viewer!OrthoProjection.onProjMatrix | OrthoProjection.onProjMatrix} will fire an event whenever {@link @xeokit/viewer!OrthoProjection.projMatrix| OrthoProjection.projMatrix} updates, which indicates that one or more other properties have updated.
 */
var _state$7 = /*#__PURE__*/_classPrivateFieldLooseKey("state");
var _inverseMatrixDirty$1 = /*#__PURE__*/_classPrivateFieldLooseKey("inverseMatrixDirty");
var _transposedProjMatrixDirty$2 = /*#__PURE__*/_classPrivateFieldLooseKey("transposedProjMatrixDirty");
var _onViewBoundary = /*#__PURE__*/_classPrivateFieldLooseKey("onViewBoundary");
var OrthoProjection = /*#__PURE__*/function (_Component) {
  _inheritsLoose(OrthoProjection, _Component);
  /**
   * @private
   */
  function OrthoProjection(camera, cfg) {
    var _this;
    if (cfg === void 0) {
      cfg = {};
    }
    _this = _Component.call(this, camera, cfg) || this;
    /**
     * The Camera this OrthoProjection belongs to.
     */
    _this.camera = void 0;
    /**
     * Emits an event each time {@link @xeokit/viewer!OrthoProjection.projMatrix| OrthoProjection.projMatrix} updates.
     *
     * @event
     */
    _this.onProjMatrix = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _state$7, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _inverseMatrixDirty$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _transposedProjMatrixDirty$2, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _onViewBoundary, {
      writable: true,
      value: void 0
    });
    _this.camera = camera;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _state$7)[_state$7] = {
      near: cfg.near || 0.1,
      far: cfg.far || 2000.0,
      scale: cfg.scale || 1.0,
      projMatrix: createMat4(),
      inverseProjMatrix: createMat4(),
      transposedProjMatrix: createMat4()
    };
    _this.onProjMatrix = new EventEmitter(new dist.EventDispatcher());
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _inverseMatrixDirty$1)[_inverseMatrixDirty$1] = true;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _transposedProjMatrixDirty$2)[_transposedProjMatrixDirty$2] = true;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _onViewBoundary)[_onViewBoundary] = _this.camera.view.onBoundary.subscribe(function () {
      _this.setDirty();
    });
    return _this;
  }
  /**
   * Gets scale factor for this OrthoProjection's extents on X and Y axis.
   *
   * Clamps to minimum value of ````0.01```.
   *
   * Default value is ````1.0````
   *
   * returns New OrthoProjection scale value.
   */
  var _proto = OrthoProjection.prototype;
  /**
   * @private
   */
  _proto.clean = function clean() {
    var WIDTH_INDEX = 2;
    var HEIGHT_INDEX = 3;
    var view = this.camera.view;
    var scale = _classPrivateFieldLooseBase(this, _state$7)[_state$7].scale;
    var halfSize = 0.5 * scale;
    var boundary = view.boundary;
    var boundaryWidth = boundary[WIDTH_INDEX];
    var boundaryHeight = boundary[HEIGHT_INDEX];
    var aspect = boundaryWidth / boundaryHeight;
    var left;
    var right;
    var top;
    var bottom;
    if (boundaryWidth > boundaryHeight) {
      left = -halfSize;
      right = halfSize;
      top = halfSize / aspect;
      bottom = -halfSize / aspect;
    } else {
      left = -halfSize * aspect;
      right = halfSize * aspect;
      top = halfSize;
      bottom = -halfSize;
    }
    orthoMat4c(left, right, bottom, top, _classPrivateFieldLooseBase(this, _state$7)[_state$7].near, _classPrivateFieldLooseBase(this, _state$7)[_state$7].far, _classPrivateFieldLooseBase(this, _state$7)[_state$7].projMatrix);
    _classPrivateFieldLooseBase(this, _inverseMatrixDirty$1)[_inverseMatrixDirty$1] = true;
    _classPrivateFieldLooseBase(this, _transposedProjMatrixDirty$2)[_transposedProjMatrixDirty$2] = true;
    this.camera.view.redraw();
    this.onProjMatrix.dispatch(this, _classPrivateFieldLooseBase(this, _state$7)[_state$7].projMatrix);
  }
  /**
   * Un-projects the given View-space coordinates, using this OrthoProjection projection.
   *
   * @param canvasPos Inputs 2D View-space coordinates.
   * @param screenZ Inputs Screen-space Z coordinate.
   * @param screenPos Outputs 3D Screen/Clip-space coordinates.
   * @param viewPos Outputs un-projected 3D View-space coordinates.
   * @param worldPos Outputs un-projected 3D World-space coordinates.
   */;
  _proto.unproject = function unproject(canvasPos, screenZ, screenPos, viewPos, worldPos) {
    var canvas = this.camera.view.canvasElement;
    var halfViewWidth = canvas.offsetWidth / 2.0;
    var halfViewHeight = canvas.offsetHeight / 2.0;
    screenPos[0] = (canvasPos[0] - halfViewWidth) / halfViewWidth;
    screenPos[1] = (canvasPos[1] - halfViewHeight) / halfViewHeight;
    screenPos[2] = screenZ;
    screenPos[3] = 1.0;
    mulMat4v4(this.inverseProjMatrix, screenPos, viewPos);
    mulVec3Scalar(viewPos, 1.0 / viewPos[3]);
    viewPos[3] = 1.0;
    viewPos[1] *= -1;
    mulMat4v4(this.camera.inverseViewMatrix, viewPos, worldPos);
    return worldPos;
  }
  /** @private
   *
   */;
  _proto.destroy = function destroy() {
    _Component.prototype.destroy.call(this);
    this.camera.view.onBoundary.unsubscribe(_classPrivateFieldLooseBase(this, _onViewBoundary)[_onViewBoundary]);
    this.onProjMatrix.clear();
  };
  _createClass(OrthoProjection, [{
    key: "scale",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$7)[_state$7].scale;
    }
    /**
     * Sets scale factor for this OrthoProjection's extents on X and Y axis.
     *
     * Clamps to minimum value of ````0.01```.
     *
     * Default value is ````1.0````
     * @param value New scale value.
     */,
    set: function set(value) {
      if (value <= 0) {
        value = 0.01;
      }
      _classPrivateFieldLooseBase(this, _state$7)[_state$7].scale = value;
      this.setDirty();
    }
    /**
     * Gets the position of the OrthoProjection's near plane on the positive View-space Z-axis.
     *
     * Default value is ````0.1````.
     *
     * returns New OrthoProjection near plane position.
     */
  }, {
    key: "near",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$7)[_state$7].near;
    }
    /**
     * Sets the position of the OrthoProjection's near plane on the positive View-space Z-axis.
     *
     * Default value is ````0.1````.
     *
     * @param value New OrthoProjection near plane position.
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$7)[_state$7].near === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$7)[_state$7].near = value;
      this.setDirty();
    }
    /**
     * Gets the position of the OrthoProjection's far plane on the positive View-space Z-axis.
     *
     * Default value is ````10000.0````.
     *
     * returns New far ortho plane position.
     */
  }, {
    key: "far",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$7)[_state$7].far;
    }
    /**
     * Sets the position of the OrthoProjection's far plane on the positive View-space Z-axis.
     *
     * Default value is ````2000.0````.
     *
     * @param value New far ortho plane position.
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$7)[_state$7].far === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$7)[_state$7].far = value;
      this.setDirty();
    }
    /**
     * Gets the OrthoProjection's projection transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @returns  The OrthoProjection's projection matrix.
     */
  }, {
    key: "projMatrix",
    get: function get() {
      if (this.dirty) {
        this.cleanIfDirty();
      }
      return _classPrivateFieldLooseBase(this, _state$7)[_state$7].projMatrix;
    }
    /**
     * Gets the inverse of {@link @xeokit/viewer!OrthoProjection.projMatrix| OrthoProjection.projMatrix}.
     *
     * @returns  The inverse of {@link @xeokit/viewer!OrthoProjection.projMatrix| OrthoProjection.projMatrix}.
     */
  }, {
    key: "inverseProjMatrix",
    get: function get() {
      if (this.dirty) {
        this.cleanIfDirty();
      }
      if (_classPrivateFieldLooseBase(this, _inverseMatrixDirty$1)[_inverseMatrixDirty$1]) {
        inverseMat4(_classPrivateFieldLooseBase(this, _state$7)[_state$7].projMatrix, _classPrivateFieldLooseBase(this, _state$7)[_state$7].inverseProjMatrix);
        _classPrivateFieldLooseBase(this, _inverseMatrixDirty$1)[_inverseMatrixDirty$1] = false;
      }
      return _classPrivateFieldLooseBase(this, _state$7)[_state$7].inverseProjMatrix;
    }
    /**
     * Gets the transpose of {@link @xeokit/viewer!OrthoProjection.projMatrix| OrthoProjection.projMatrix}.
     *
     * @returns  The transpose of {@link @xeokit/viewer!OrthoProjection.projMatrix| OrthoProjection.projMatrix}.
     */
  }, {
    key: "transposedProjMatrix",
    get: function get() {
      if (this.dirty) {
        this.cleanIfDirty();
      }
      if (_classPrivateFieldLooseBase(this, _transposedProjMatrixDirty$2)[_transposedProjMatrixDirty$2]) {
        transposeMat4(_classPrivateFieldLooseBase(this, _state$7)[_state$7].projMatrix, _classPrivateFieldLooseBase(this, _state$7)[_state$7].transposedProjMatrix);
        _classPrivateFieldLooseBase(this, _transposedProjMatrixDirty$2)[_transposedProjMatrixDirty$2] = false;
      }
      return _classPrivateFieldLooseBase(this, _state$7)[_state$7].transposedProjMatrix;
    }
  }]);
  return OrthoProjection;
}(Component);
/**
 * The type of this projection.
 */
OrthoProjection.type = OrthoProjectionType;

/**
 *  FrustumProjection-based perspective projection configuration for a {@link @xeokit/viewer!Camera} .
 *
 * * Located at {@link Camera.frustumProjection}.
 * * Allows to explicitly set the positions of the left, right, top, bottom, near and far planes, which is useful for asymmetrical view volumes, such as for stereo viewing.
 * * {@link FrustumProjection.near} and {@link FrustumProjection.far} specify the distances to the clipping planes.
 * * {@link FrustumProjection.onProjMatrix} will fire an event whenever {@link FrustumProjection.projMatrix} updates, which indicates that one or more other properties have updated.
 */
var _state$6 = /*#__PURE__*/_classPrivateFieldLooseKey("state");
var _inverseMatrixDirty = /*#__PURE__*/_classPrivateFieldLooseKey("inverseMatrixDirty");
var _transposedProjMatrixDirty$1 = /*#__PURE__*/_classPrivateFieldLooseKey("transposedProjMatrixDirty");
var FrustumProjection = /*#__PURE__*/function (_Component) {
  _inheritsLoose(FrustumProjection, _Component);
  /**
   * @private
   */
  function FrustumProjection(camera, cfg) {
    var _this;
    if (cfg === void 0) {
      cfg = {};
    }
    _this = _Component.call(this, camera, cfg) || this;
    /**
     * The Camera this FrustumProjection belongs to.
     */
    _this.camera = void 0;
    /**
     * Emits an event each time {@link FrustumProjection.projMatrix} updates.
     *
     * @event
     */
    _this.onProjMatrix = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _state$6, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _inverseMatrixDirty, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _transposedProjMatrixDirty$1, {
      writable: true,
      value: void 0
    });
    _this.camera = camera;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _state$6)[_state$6] = {
      projMatrix: createMat4(),
      inverseProjMatrix: createMat4(),
      transposedProjMatrix: createMat4(),
      near: 0.1,
      far: 10000.0,
      left: cfg.left !== undefined && cfg.left !== null ? cfg.left : -1.0,
      right: cfg.right !== undefined && cfg.right !== null ? cfg.right : 1.0,
      bottom: cfg.bottom !== undefined && cfg.bottom !== null ? cfg.bottom : -1.0,
      top: cfg.top !== undefined && cfg.top !== null ? cfg.top : 1.0
    };
    _this.onProjMatrix = new EventEmitter(new dist.EventDispatcher());
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _inverseMatrixDirty)[_inverseMatrixDirty] = true;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _transposedProjMatrixDirty$1)[_transposedProjMatrixDirty$1] = true;
    return _this;
  }
  /**
   * Gets the position of the FrustumProjection's left plane on the View-space X-axis.
   *
   * @return {Number} Left frustum plane position.
   */
  var _proto = FrustumProjection.prototype;
  /**
   * @private
   */
  _proto.clean = function clean() {
    frustumMat4(_classPrivateFieldLooseBase(this, _state$6)[_state$6].left, _classPrivateFieldLooseBase(this, _state$6)[_state$6].right, _classPrivateFieldLooseBase(this, _state$6)[_state$6].bottom, _classPrivateFieldLooseBase(this, _state$6)[_state$6].top, _classPrivateFieldLooseBase(this, _state$6)[_state$6].near, _classPrivateFieldLooseBase(this, _state$6)[_state$6].far, _classPrivateFieldLooseBase(this, _state$6)[_state$6].projMatrix);
    _classPrivateFieldLooseBase(this, _inverseMatrixDirty)[_inverseMatrixDirty] = true;
    _classPrivateFieldLooseBase(this, _transposedProjMatrixDirty$1)[_transposedProjMatrixDirty$1] = true;
    this.camera.view.redraw();
    this.onProjMatrix.dispatch(this, _classPrivateFieldLooseBase(this, _state$6)[_state$6].projMatrix);
  }
  /**
   * Un-projects the given View-space coordinates, using this FrustumProjection projection.
   *
   * @param canvasPos Inputs 2D View-space coordinates.
   * @param screenZ Inputs Screen-space Z coordinate.
   * @param screenPos Outputs 3D Screen/Clip-space coordinates.
   * @param viewPos Outputs un-projected 3D View-space coordinates.
   * @param worldPos Outputs un-projected 3D World-space coordinates.
   */;
  _proto.unproject = function unproject(canvasPos, screenZ, screenPos, viewPos, worldPos) {
    var canvasElement = this.camera.view.canvasElement;
    var halfViewWidth = canvasElement.offsetWidth / 2.0;
    var halfViewHeight = canvasElement.offsetHeight / 2.0;
    screenPos[0] = (canvasPos[0] - halfViewWidth) / halfViewWidth;
    screenPos[1] = (canvasPos[1] - halfViewHeight) / halfViewHeight;
    screenPos[2] = screenZ;
    screenPos[3] = 1.0;
    mulMat4v4(this.inverseProjMatrix, screenPos, viewPos);
    mulVec3Scalar(viewPos, 1.0 / viewPos[3]);
    viewPos[3] = 1.0;
    viewPos[1] *= -1;
    mulMat4v4(this.camera.inverseViewMatrix, viewPos, worldPos);
    return worldPos;
  }
  /** @private
   *
   */;
  _proto.destroy = function destroy() {
    _Component.prototype.destroy.call(this);
    this.onProjMatrix.clear();
  };
  _createClass(FrustumProjection, [{
    key: "left",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$6)[_state$6].left;
    }
    /**
     * Sets the position of the FrustumProjection's left plane on the View-space X-axis.
     *
     * @param value New left frustum plane position.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _state$6)[_state$6].left = value;
      this.setDirty();
    }
    /**
     * Gets the position of the FrustumProjection's right plane on the View-space X-axis.
     *
     * @return {Number} Right frustum plane position.
     */
  }, {
    key: "right",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$6)[_state$6].right;
    }
    /**
     * Sets the position of the FrustumProjection's right plane on the View-space X-axis.
     *
     * @param value New right frustum plane position.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _state$6)[_state$6].right = value;
      this.setDirty();
    }
    /**
     * Gets the position of the FrustumProjection's top plane on the View-space Y-axis.
     *
     * @return {Number} Top frustum plane position.
     */
  }, {
    key: "top",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$6)[_state$6].top;
    }
    /**
     * Sets the position of the FrustumProjection's top plane on the View-space Y-axis.
     *
     * @param value New top frustum plane position.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _state$6)[_state$6].top = value;
      this.setDirty();
    }
    /**
     * Gets the position of the FrustumProjection's bottom plane on the View-space Y-axis.
     *
     * @return {Number} Bottom frustum plane position.
     */
  }, {
    key: "bottom",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$6)[_state$6].bottom;
    }
    /**
     * Sets the position of the FrustumProjection's bottom plane on the View-space Y-axis.
     *
     * @param value New bottom frustum plane position.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _state$6)[_state$6].bottom = value;
      this.setDirty();
    }
    /**
     * Gets the position of the FrustumProjection's near plane on the positive View-space Z-axis.
     *
     * Default value is ````0.1````.
     *
     * @return {Number} Near frustum plane position.
     */
  }, {
    key: "near",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$6)[_state$6].near;
    }
    /**
     * Sets the position of the FrustumProjection's near plane on the positive View-space Z-axis.
     *
     * Default value is ````0.1````.
     *
     * @param value New FrustumProjection near plane position.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _state$6)[_state$6].near = value;
      this.setDirty();
    }
    /**
     * Gets the position of the FrustumProjection's far plane on the positive View-space Z-axis.
     *
     * Default value is ````10000.0````.
     *
     * @return {Number} Far frustum plane position.
     */
  }, {
    key: "far",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$6)[_state$6].far;
    }
    /**
     * Sets the position of the FrustumProjection's far plane on the positive View-space Z-axis.
     *
     * Default value is ````10000.0````.
     *
     * @param value New far frustum plane position.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _state$6)[_state$6].far = value;
      this.setDirty();
    }
    /**
     * Gets the FrustumProjection's projection transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @returns The FrustumProjection's projection matrix
     */
  }, {
    key: "projMatrix",
    get: function get() {
      if (this.dirty) {
        this.cleanIfDirty();
      }
      return _classPrivateFieldLooseBase(this, _state$6)[_state$6].projMatrix;
    }
    /**
     * Gets the inverse of {@link FrustumProjection.projMatrix}.
     *
     * @returns  The inverse orthographic projection projMatrix.
     */
  }, {
    key: "inverseProjMatrix",
    get: function get() {
      if (this.dirty) {
        this.cleanIfDirty();
      }
      if (_classPrivateFieldLooseBase(this, _inverseMatrixDirty)[_inverseMatrixDirty]) {
        inverseMat4(_classPrivateFieldLooseBase(this, _state$6)[_state$6].projMatrix, _classPrivateFieldLooseBase(this, _state$6)[_state$6].inverseProjMatrix);
        _classPrivateFieldLooseBase(this, _inverseMatrixDirty)[_inverseMatrixDirty] = false;
      }
      return _classPrivateFieldLooseBase(this, _state$6)[_state$6].inverseProjMatrix;
    }
    /**
     * Gets the transpose of {@link FrustumProjection.projMatrix}.
     *
     * @returns The transpose of {@link FrustumProjection.projMatrix}.
     */
  }, {
    key: "transposedProjMatrix",
    get: function get() {
      if (this.dirty) {
        this.cleanIfDirty();
      }
      if (_classPrivateFieldLooseBase(this, _transposedProjMatrixDirty$1)[_transposedProjMatrixDirty$1]) {
        transposeMat4(_classPrivateFieldLooseBase(this, _state$6)[_state$6].projMatrix, _classPrivateFieldLooseBase(this, _state$6)[_state$6].transposedProjMatrix);
        _classPrivateFieldLooseBase(this, _transposedProjMatrixDirty$1)[_transposedProjMatrixDirty$1] = false;
      }
      return _classPrivateFieldLooseBase(this, _state$6)[_state$6].transposedProjMatrix;
    }
  }]);
  return FrustumProjection;
}(Component);
/**
 * The type of this projection.
 */
FrustumProjection.type = FrustumProjectionType;

/**
 * Configures a custom projection for a {@link @xeokit/viewer!Camera} .
 *
 * * Located at {@link Camera.customProjection}.
 * * {@link CustomProjection.onProjMatrix} will fire an event whenever {@link CustomProjection.projMatrix} updates, which indicates that one or more other properties have updated.
 */
var _state$5 = /*#__PURE__*/_classPrivateFieldLooseKey("state");
var _inverseProjMatrixDirty = /*#__PURE__*/_classPrivateFieldLooseKey("inverseProjMatrixDirty");
var _transposedProjMatrixDirty = /*#__PURE__*/_classPrivateFieldLooseKey("transposedProjMatrixDirty");
var CustomProjection = /*#__PURE__*/function (_Component) {
  _inheritsLoose(CustomProjection, _Component);
  /**
   * @private
   */
  function CustomProjection(camera, cfg) {
    var _this;
    if (cfg === void 0) {
      cfg = {};
    }
    _this = _Component.call(this, camera, cfg) || this;
    /**
     * The Camera this CustomProjection belongs to.
     */
    _this.camera = void 0;
    /**
     * Emits an event each time {@link CustomProjection.projMatrix} updates.
     *
     * @event
     */
    _this.onProjMatrix = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _state$5, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _inverseProjMatrixDirty, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _transposedProjMatrixDirty, {
      writable: true,
      value: void 0
    });
    _this.camera = camera;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _state$5)[_state$5] = {
      projMatrix: createMat4(cfg.projMatrix || identityMat4()),
      inverseProjMatrix: createMat4(),
      transposedProjMatrix: createMat4()
    };
    _this.onProjMatrix = new EventEmitter(new dist.EventDispatcher());
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _inverseProjMatrixDirty)[_inverseProjMatrixDirty] = true;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _transposedProjMatrixDirty)[_transposedProjMatrixDirty] = false;
    return _this;
  }
  /**
   * Gets the CustomProjection's projection transform matrix.
   *
   * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
   *
   * @return  New value for the CustomProjection's matrix.
   */
  var _proto = CustomProjection.prototype;
  /**
   * Un-projects the given View-space coordinates, using this CustomProjection.
   *
   * @param canvasPos Inputs 2D View-space coordinates.
   * @param screenZ Inputs Screen-space Z coordinate.
   * @param screenPos Outputs 3D Screen/Clip-space coordinates.
   * @param viewPos Outputs un-projected 3D View-space coordinates.
   * @param worldPos Outputs un-projected 3D World-space coordinates.
   */
  _proto.unproject = function unproject(canvasPos, screenZ, screenPos, viewPos, worldPos) {
    var canvasElement = this.camera.view.canvasElement;
    var halfViewWidth = canvasElement.offsetWidth / 2.0;
    var halfViewHeight = canvasElement.offsetHeight / 2.0;
    screenPos[0] = (canvasPos[0] - halfViewWidth) / halfViewWidth;
    screenPos[1] = (canvasPos[1] - halfViewHeight) / halfViewHeight;
    screenPos[2] = screenZ;
    screenPos[3] = 1.0;
    mulMat4v4(this.inverseProjMatrix, screenPos, viewPos);
    mulVec3Scalar(viewPos, 1.0 / viewPos[3]);
    viewPos[3] = 1.0;
    viewPos[1] *= -1;
    mulMat4v4(this.camera.inverseViewMatrix, viewPos, worldPos);
    return worldPos;
  }
  /** @private
   *
   */;
  _proto.destroy = function destroy() {
    _Component.prototype.destroy.call(this);
    this.onProjMatrix.clear();
  };
  _createClass(CustomProjection, [{
    key: "projMatrix",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$5)[_state$5].projMatrix;
    }
    /**
     * Sets the CustomProjection's projection transform matrix.
     *
     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.
     *
     * @param projMatrix New value for the CustomProjection's matrix.
     */,
    set: function set(projMatrix) {
      // @ts-ignore
      _classPrivateFieldLooseBase(this, _state$5)[_state$5].projMatrix.set(projMatrix);
      _classPrivateFieldLooseBase(this, _inverseProjMatrixDirty)[_inverseProjMatrixDirty] = true;
      _classPrivateFieldLooseBase(this, _transposedProjMatrixDirty)[_transposedProjMatrixDirty] = true;
      this.setDirty();
      this.camera.view.redraw();
      this.onProjMatrix.dispatch(this, _classPrivateFieldLooseBase(this, _state$5)[_state$5].projMatrix);
    }
    /**
     * Gets the inverse of {@link CustomProjection.projMatrix}.
     *
     * @returns The inverse of {@link CustomProjection.projMatrix}.
     */
  }, {
    key: "inverseProjMatrix",
    get: function get() {
      if (this.dirty) {
        this.cleanIfDirty();
      }
      if (_classPrivateFieldLooseBase(this, _inverseProjMatrixDirty)[_inverseProjMatrixDirty]) {
        inverseMat4(_classPrivateFieldLooseBase(this, _state$5)[_state$5].projMatrix, _classPrivateFieldLooseBase(this, _state$5)[_state$5].inverseProjMatrix);
        _classPrivateFieldLooseBase(this, _inverseProjMatrixDirty)[_inverseProjMatrixDirty] = false;
      }
      return _classPrivateFieldLooseBase(this, _state$5)[_state$5].inverseProjMatrix;
    }
    /**
     * Gets the transpose of {@link CustomProjection.projMatrix}.
     *
     * @returns The transpose of {@link CustomProjection.projMatrix}.
     */
  }, {
    key: "transposedProjMatrix",
    get: function get() {
      if (this.dirty) {
        this.cleanIfDirty();
      }
      if (_classPrivateFieldLooseBase(this, _transposedProjMatrixDirty)[_transposedProjMatrixDirty]) {
        transposeMat4(_classPrivateFieldLooseBase(this, _state$5)[_state$5].projMatrix, _classPrivateFieldLooseBase(this, _state$5)[_state$5].transposedProjMatrix);
        _classPrivateFieldLooseBase(this, _transposedProjMatrixDirty)[_transposedProjMatrixDirty] = false;
      }
      return _classPrivateFieldLooseBase(this, _state$5)[_state$5].transposedProjMatrix;
    }
  }]);
  return CustomProjection;
}(Component);
/**
 * The type of this projection.
 */
CustomProjection.type = CustomProjectionType;

var tempVec3$2 = createVec3();
var tempVec3b$3 = createVec3();
var tempVec3c$3 = createVec3();
var tempVec3d$1 = createVec3();
var tempVec3e = createVec3();
var tempVec3f = createVec3();
var tempMat = createMat4();
var tempMatb = createMat4();
var eyeLookVec = createVec3();
var eyeLookVecNorm = createVec3();
var eyeLookOffset = createVec3();
var offsetEye = createVec3();
/**
 * Controls the viewpoint and projection for a {@link @xeokit/viewer!View}.
 *
 * ## Summary
 *
 * * Located at {@link View.camera}
 * * Views are located at {@link Viewer.views}
 * * Controls camera viewing and projection transforms
 * * Provides methods to pan, zoom and orbit
 * * Dynamically configurable World-space axis
 * * Has {@link PerspectiveProjection}, {@link OrthoProjection} and {@link FrustumProjection} and {@link CustomProjection}, which you can dynamically switch between
 * * Switchable gimbal lock
 * * Can be flown to look at targets using the View's {@link CameraFlightAnimation}
 * * Can be animated along a path using a {@link CameraPathAnimation}
 *
 * ## Getting a View's Camera
 *
 * Let's create a {@link @xeokit/viewer!Viewer} with a single {@link @xeokit/viewer!View}, from which we'll get a Camera:
 *
 * ````javascript
 * const viewer = new Viewer();
 *
 * const view = new View(viewer, {
 *      canvasId: "myCanvas1"
 * });
 *
 * const camera = view.camera;
 * ````
 *
 * ## Setting the Camera Position
 *
 * Get and set the Camera's absolute position:
 *
 * ````javascript
 * camera.eye = [-10,0,0];
 * camera.look = [-10,0,0];
 * camera.up = [0,1,0];
 * ````
 *
 * ## Camera View and Projection Matrices
 *
 * The Camera's *view matrix* transforms coordinates from World-space to View-space:
 *
 * ````javascript
 * var viewMatrix = camera.viewMatrix;
 * ````
 *
 * {@link Camera.onViewMatrix} fires whenever {@link Camera.viewMatrix} updates:
 *
 * ````javascript
 * camera.onViewMatrix.subscribe((camera, matrix) => { ... });
 * ````
 *
 * ## Rotating the Camera
 *
 * Orbiting the {@link @xeokit/viewer!Camera.look | Camera.look} position:
 *
 * ````javascript
 * camera.orbitYaw(20.0);
 * camera.orbitPitch(10.0);
 * ````
 *
 * Perform a *first-person* rotation, in which we rotate {@link @xeokit/viewer!Camera.look | Camera.look} and {@link @xeokit/viewer!Camera.up | Camera.up} about {@link @xeokit/viewer!Camera.eye | Camera.eye}:
 *
 * ````javascript
 * camera.yaw(5.0);
 * camera.pitch(-10.0);
 * ````
 *
 * ## Panning the Camera
 *
 * Pan along the Camera's local axis (ie. left/right, up/down, forward/backward):
 *
 * ````javascript
 * camera.pan([-20, 0, 10]);
 * ````
 *
 * ## Zooming the Camera
 *
 * Zoom to vary distance between {@link @xeokit/viewer!Camera.eye | Camera.eye} and {@link @xeokit/viewer!Camera.look | Camera.look}:
 *
 * ````javascript
 * camera.zoom(-5); // Move five units closer
 * ````
 *
 * Get the current distance between {@link @xeokit/viewer!Camera.eye | Camera.eye} and {@link @xeokit/viewer!Camera.look | Camera.look}:
 *
 * ````javascript
 * var distance = camera.eyeLookDist;
 * ````
 *
 * ## Projection
 *
 * The Camera has a Component to manage each projection type, which are: {@link PerspectiveProjection}, {@link OrthoProjection}
 * and {@link FrustumProjection} and {@link CustomProjection}.
 *
 * You can configure those components at any time, regardless of which is currently active:
 *
 * The Camera has a {@link PerspectiveProjection} to manage perspective
 * ````javascript
 *
 * // Set some properties on PerspectiveProjection
 * camera.perspectiveProjection.near = 0.4;
 * camera.perspectiveProjection.fov = 45;
 *
 * // Set some properties on OrthoProjection
 * camera.orthoProjection.near = 0.8;
 * camera.orthoProjection.far = 1000;
 *
 * // Set some properties on FrustumProjection
 * camera.frustumProjection.left = -1.0;
 * camera.frustumProjection.right = 1.0;
 * camera.frustumProjection.far = 1000.0;
 *
 * // Set the matrix property on CustomProjection
 * camera.customProjection.projMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
 *
 * // Switch between the projection types
 * Camera.projectionType = PerspectiveProjectionType; // Switch to perspective
 * Camera.projectionType = FrustumProjectiontype; // Switch to frustum
 * Camera.projectionType = OrthoProjectionType; // Switch to ortho
 * Camera.projectionType = CustomProjectionType; // Switch to custom
 * ````
 *
 * Camera provides the projection matrix for the currently active projection in {@link Camera.projMatrix}.
 *
 * Get the projection matrix:
 *
 * ````javascript
 * var projMatrix = camera.projMatrix;
 * ````
 *
 * Listen for projection matrix updates:
 *
 * ````javascript
 * camera.onProjMatrix((camera, matrix) => { ... });
 * ````
 *
 * ## Configuring World up direction
 *
 * We can dynamically configure the directions of the World-space coordinate system.
 *
 * Setting the +Y axis as World "up", +X as right and -Z as forwards (convention in some modeling software):
 *
 * ````javascript
 * camera.worldAxis = [
 *     1, 0, 0,    // Right
 *     0, 1, 0,    // Up
 *     0, 0,-1     // Forward
 * ];
 * ````
 *
 * Setting the +Z axis as World "up", +X as right and -Y as "up" (convention in most CAD and BIM viewers):
 *
 * ````javascript
 * camera.worldAxis = [
 *     1, 0, 0, // Right
 *     0, 0, 1, // Up
 *     0,-1, 0  // Forward
 * ];
 * ````
 *
 * The Camera has read-only convenience properties that provide each axis individually:
 *
 * ````javascript
 * var worldRight = camera.worldRight;
 * var worldForward = camera.worldForward;
 * var worldUp = camera.worldUp;
 * ````
 *
 * ## Gimbal locking
 *
 * By default, the Camera locks yaw rotation to pivot about the World-space "up" axis. We can dynamically lock and unlock that at any time:
 *
 * ````javascript
 * camera.gimbalLock = false; // Yaw rotation now happens about Camera's local Y-axis
 * camera.gimbalLock = true; // Yaw rotation now happens about World's "up" axis
 * ````
 *
 * See: <a href="https://en.wikipedia.org/wiki/Gimbal_lock">https://en.wikipedia.org/wiki/Gimbal_lock</a>
 */
var _state$4 = /*#__PURE__*/_classPrivateFieldLooseKey("state");
var _frustum = /*#__PURE__*/_classPrivateFieldLooseKey("frustum");
var _activeProjection = /*#__PURE__*/_classPrivateFieldLooseKey("activeProjection");
var Camera = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Camera, _Component);
  /**
   * @private
   */
  function Camera(view, cfg) {
    var _this;
    if (cfg === void 0) {
      cfg = {};
    }
    _this = _Component.call(this, view, cfg) || this;
    /**
     * The View to which this Camera belongs.
     *
     * @property view
     * @type {View}
     * @final
     */
    _this.view = void 0;
    /**
     * The perspective projection.
     *
     * The Camera uses this while {@link Camera.projectionType} equals {@link PerspectiveProjectionType}.
     */
    _this.perspectiveProjection = void 0;
    /**
     * The orthographic projection.
     *
     * The Camera uses this while {@link Camera.projectionType} equals {@link @xeokit/constants!OrthoProjectionType}.
     */
    _this.orthoProjection = void 0;
    /**
     * The frustum projection.
     *
     * The Camera uses this while {@link Camera.projectionType} equals {@link @xeokit/constants!FrustumProjectionType}.
     */
    _this.frustumProjection = void 0;
    /**
     * The custom projection.
     *
     * The Camera uses this while {@link Camera.projectionType} equals {@link @xeokit/constants!CustomProjectionType}.
     */
    _this.customProjection = void 0;
    /**
     * Emits an event each time {@link Camera.projectionType} updates.
     *
     * ````javascript
     * myView.camera.onProjectionType.subscribe((camera, projType) => { ... });
     * ````
     *
     * @event
     */
    _this.onProjectionType = void 0;
    /**
     * Emits an event each time {@link Camera.viewMatrix} updates.
     *
     * ````javascript
     * myView.camera.onViewMatrix.subscribe((camera, viewMatrix) => { ... });
     * ````
     *
     * @event
     */
    _this.onViewMatrix = void 0;
    /**
     * Emits an event each time {@link Camera.projMatrix} updates.
     *
     * ````javascript
     * myView.camera.onProjMatrix.subscribe((camera, projMatrix) => { ... });
     * ````
     *
     * @event
     */
    _this.onProjMatrix = void 0;
    /**
     * Emits an event each time {@link Camera.worldAxis} updates.
     *
     * ````javascript
     * myView.camera.onWorldAxis.subscribe((camera, worldAxis) => { ... });
     * ````
     *
     * @event
     */
    _this.onWorldAxis = void 0;
    /**
     * Emits an event each time {@link Camera.frustum} updates.
     *
     * ````javascript
     * myView.camera.onFrustum.subscribe((camera, frustum) => { ... });
     * ````
     *
     * @event
     */
    _this.onFrustum = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _state$4, {
      writable: true,
      value: void 0
    });
    /**
     * The viewing frustum.
     */
    Object.defineProperty(_assertThisInitialized(_this), _frustum, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _activeProjection, {
      writable: true,
      value: void 0
    });
    _this.onProjectionType = new EventEmitter(new dist.EventDispatcher());
    _this.onViewMatrix = new EventEmitter(new dist.EventDispatcher());
    _this.onProjMatrix = new EventEmitter(new dist.EventDispatcher());
    _this.onWorldAxis = new EventEmitter(new dist.EventDispatcher());
    _this.onFrustum = new EventEmitter(new dist.EventDispatcher());
    _this.view = view;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _state$4)[_state$4] = {
      eye: createVec3(cfg.eye || [0, 0, 10]),
      look: createVec3(cfg.look || [0, 0, 0]),
      up: createVec3(cfg.up || [0, 1, 0]),
      worldUp: createVec3([0, 1, 0]),
      worldRight: createVec3([1, 0, 0]),
      worldForward: createVec3([0, 0, -1]),
      worldAxis: new Float32Array(cfg.worldAxis || [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      gimbalLock: cfg.gimbalLock !== false,
      constrainPitch: cfg.constrainPitch === true,
      projectionType: cfg.projectionType || PerspectiveProjectionType,
      deviceMatrix: cfg.deviceMatrix ? createMat4(cfg.deviceMatrix) : identityMat4(),
      hasDeviceMatrix: !!cfg.deviceMatrix,
      viewMatrix: createMat4(),
      viewNormalMatrix: createMat4(),
      inverseViewMatrix: createMat4()
    };
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _frustum)[_frustum] = new Frustum3();
    _this.perspectiveProjection = new PerspectiveProjection(_assertThisInitialized(_this));
    _this.orthoProjection = new OrthoProjection(_assertThisInitialized(_this));
    _this.frustumProjection = new FrustumProjection(_assertThisInitialized(_this));
    _this.customProjection = new CustomProjection(_assertThisInitialized(_this));
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _activeProjection)[_activeProjection] = _this.perspectiveProjection;
    _this.perspectiveProjection.onProjMatrix.subscribe(function () {
      if (_classPrivateFieldLooseBase(_assertThisInitialized(_this), _state$4)[_state$4].projectionType === PerspectiveProjectionType) {
        _this.onProjMatrix.dispatch(_assertThisInitialized(_this), _this.perspectiveProjection.projMatrix);
      }
    });
    _this.orthoProjection.onProjMatrix.subscribe(function () {
      if (_classPrivateFieldLooseBase(_assertThisInitialized(_this), _state$4)[_state$4].projectionType === OrthoProjectionType) {
        _this.onProjMatrix.dispatch(_assertThisInitialized(_this), _this.orthoProjection.projMatrix);
      }
    });
    _this.frustumProjection.onProjMatrix.subscribe(function () {
      if (_classPrivateFieldLooseBase(_assertThisInitialized(_this), _state$4)[_state$4].projectionType === FrustumProjectionType) {
        _this.onProjMatrix.dispatch(_assertThisInitialized(_this), _this.frustumProjection.projMatrix);
      }
    });
    _this.customProjection.onProjMatrix.subscribe(function () {
      if (_classPrivateFieldLooseBase(_assertThisInitialized(_this), _state$4)[_state$4].projectionType === CustomProjectionType) {
        _this.onProjMatrix.dispatch(_assertThisInitialized(_this), _this.customProjection.projMatrix);
      }
    });
    return _this;
  }
  /**
   * Gets the currently active projection for this Camera.
   *
   * The currently active project is selected with {@link Camera.projectionType}.
   *
   * @returns {PerspectiveProjection|OrthoProjection|FrustumProjection|CustomProjection} The currently active projection is active.
   */
  var _proto = Camera.prototype;
  _proto.clean = function clean() {
    var state = _classPrivateFieldLooseBase(this, _state$4)[_state$4];
    // In ortho mode, build the view matrix with an eye position that's translated
    // well back from look, so that the front sectionPlane plane doesn't unexpectedly cut
    // the front off the view (not a problem with perspective, since objects close enough
    // to be clipped by the front plane are usually too big to see anything of their cross-sections).
    var eye;
    if (this.projectionType === OrthoProjectionType) {
      subVec3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].eye, _classPrivateFieldLooseBase(this, _state$4)[_state$4].look, eyeLookVec);
      normalizeVec3(eyeLookVec, eyeLookVecNorm);
      mulVec3Scalar(eyeLookVecNorm, 1000.0, eyeLookOffset);
      addVec3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].look, eyeLookOffset, offsetEye);
      eye = offsetEye;
    } else {
      eye = _classPrivateFieldLooseBase(this, _state$4)[_state$4].eye;
    }
    if (state.hasDeviceMatrix) {
      lookAtMat4v(eye, _classPrivateFieldLooseBase(this, _state$4)[_state$4].look, _classPrivateFieldLooseBase(this, _state$4)[_state$4].up, tempMatb);
      mulMat4(state.deviceMatrix, tempMatb, state.viewMatrix);
    } else {
      lookAtMat4v(eye, _classPrivateFieldLooseBase(this, _state$4)[_state$4].look, _classPrivateFieldLooseBase(this, _state$4)[_state$4].up, state.viewMatrix);
    }
    inverseMat4(_classPrivateFieldLooseBase(this, _state$4)[_state$4].viewMatrix, _classPrivateFieldLooseBase(this, _state$4)[_state$4].inverseViewMatrix);
    transposeMat4(_classPrivateFieldLooseBase(this, _state$4)[_state$4].inverseViewMatrix, _classPrivateFieldLooseBase(this, _state$4)[_state$4].viewNormalMatrix);
    this.view.redraw();
    setFrustum3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].viewMatrix, _classPrivateFieldLooseBase(this, _activeProjection)[_activeProjection].projMatrix, _classPrivateFieldLooseBase(this, _frustum)[_frustum]);
    this.onViewMatrix.dispatch(this, _classPrivateFieldLooseBase(this, _state$4)[_state$4].viewMatrix);
    this.onFrustum.dispatch(this, _classPrivateFieldLooseBase(this, _frustum)[_frustum]);
  }
  /**
   * Rotates {@link @xeokit/viewer!Camera.eye | Camera.eye} about {@link @xeokit/viewer!Camera.look | Camera.look}, around the {@link @xeokit/viewer!Camera.up | Camera.up} vector
   *
   * @param angleInc Angle of rotation in degrees
   */;
  _proto.orbitYaw = function orbitYaw(angleInc) {
    var lookEyeVec = subVec3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].eye, _classPrivateFieldLooseBase(this, _state$4)[_state$4].look, tempVec3$2);
    rotationMat4v(angleInc * 0.0174532925, _classPrivateFieldLooseBase(this, _state$4)[_state$4].gimbalLock ? _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldUp : _classPrivateFieldLooseBase(this, _state$4)[_state$4].up, tempMat);
    lookEyeVec = transformPoint3(tempMat, lookEyeVec, tempVec3b$3);
    this.eye = addVec3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].look, lookEyeVec, tempVec3c$3); // Set eye position as 'look' plus 'eye' vector
    this.up = transformPoint3(tempMat, _classPrivateFieldLooseBase(this, _state$4)[_state$4].up, tempVec3d$1); // Rotate 'up' vector
  }
  /**
   * Rotates {@link @xeokit/viewer!Camera.eye | Camera.eye} about {@link @xeokit/viewer!Camera.look | Camera.look} around the right axis (orthogonal to {@link @xeokit/viewer!Camera.up | Camera.up} and "look").
   *
   * @param angleInc Angle of rotation in degrees
   */;
  _proto.orbitPitch = function orbitPitch(angleInc) {
    if (_classPrivateFieldLooseBase(this, _state$4)[_state$4].constrainPitch) {
      angleInc = dotVec3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].up, _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldUp) / DEGTORAD;
      if (angleInc < 1) {
        return;
      }
    }
    var eye2 = subVec3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].eye, _classPrivateFieldLooseBase(this, _state$4)[_state$4].look, tempVec3$2);
    var left = cross3Vec3(normalizeVec3(eye2, tempVec3b$3), normalizeVec3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].up, tempVec3c$3));
    rotationMat4v(angleInc * 0.0174532925, left, tempMat);
    eye2 = transformPoint3(tempMat, eye2, tempVec3d$1);
    this.up = transformPoint3(tempMat, _classPrivateFieldLooseBase(this, _state$4)[_state$4].up, tempVec3e);
    this.eye = addVec3(eye2, _classPrivateFieldLooseBase(this, _state$4)[_state$4].look, tempVec3f);
  }
  /**
   * Rotates {@link @xeokit/viewer!Camera.look | Camera.look} about {@link @xeokit/viewer!Camera.eye | Camera.eye}, around the {@link @xeokit/viewer!Camera.up | Camera.up} vector.
   *
   * @param angleInc Angle of rotation in degrees
   */;
  _proto.yaw = function yaw(angleInc) {
    var look2 = subVec3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].look, _classPrivateFieldLooseBase(this, _state$4)[_state$4].eye, tempVec3$2);
    rotationMat4v(angleInc * 0.0174532925, _classPrivateFieldLooseBase(this, _state$4)[_state$4].gimbalLock ? _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldUp : _classPrivateFieldLooseBase(this, _state$4)[_state$4].up, tempMat);
    look2 = transformPoint3(tempMat, look2, tempVec3b$3);
    this.look = addVec3(look2, _classPrivateFieldLooseBase(this, _state$4)[_state$4].eye, tempVec3c$3);
    if (_classPrivateFieldLooseBase(this, _state$4)[_state$4].gimbalLock) {
      this.up = transformPoint3(tempMat, _classPrivateFieldLooseBase(this, _state$4)[_state$4].up, tempVec3d$1);
    }
  }
  /**
   * Rotates {@link @xeokit/viewer!Camera.look | Camera.look} about {@link @xeokit/viewer!Camera.eye | Camera.eye}, around the right axis (orthogonal to {@link @xeokit/viewer!Camera.up | Camera.up} and "look").
    * @param angleInc Angle of rotation in degrees
   */;
  _proto.pitch = function pitch(angleInc) {
    if (_classPrivateFieldLooseBase(this, _state$4)[_state$4].constrainPitch) {
      angleInc = dotVec3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].up, _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldUp) / DEGTORAD;
      if (angleInc < 1) {
        return;
      }
    }
    var look2 = subVec3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].look, _classPrivateFieldLooseBase(this, _state$4)[_state$4].eye, tempVec3$2);
    var left = cross3Vec3(normalizeVec3(look2, tempVec3b$3), normalizeVec3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].up, tempVec3c$3));
    rotationMat4v(angleInc * 0.0174532925, left, tempMat);
    this.up = transformPoint3(tempMat, _classPrivateFieldLooseBase(this, _state$4)[_state$4].up, tempVec3f);
    look2 = transformPoint3(tempMat, look2, tempVec3d$1);
    this.look = addVec3(look2, _classPrivateFieldLooseBase(this, _state$4)[_state$4].eye, tempVec3e);
  }
  /**
   * Pans the Camera along its local X, Y and Z axis.
   *
   * @param pan The pan vector
   */;
  _proto.pan = function pan(_pan) {
    var eye2 = subVec3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].eye, _classPrivateFieldLooseBase(this, _state$4)[_state$4].look, tempVec3$2);
    var vec = [0, 0, 0];
    var v;
    if (_pan[0] !== 0) {
      var left = cross3Vec3(normalizeVec3(eye2, []), normalizeVec3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].up, tempVec3b$3));
      v = mulVec3Scalar(left, _pan[0]);
      vec[0] += v[0];
      vec[1] += v[1];
      vec[2] += v[2];
    }
    if (_pan[1] !== 0) {
      v = mulVec3Scalar(normalizeVec3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].up, tempVec3c$3), _pan[1]);
      vec[0] += v[0];
      vec[1] += v[1];
      vec[2] += v[2];
    }
    if (_pan[2] !== 0) {
      v = mulVec3Scalar(normalizeVec3(eye2, tempVec3d$1), _pan[2]);
      vec[0] += v[0];
      vec[1] += v[1];
      vec[2] += v[2];
    }
    this.eye = addVec3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].eye, vec, tempVec3e);
    this.look = addVec3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].look, vec, tempVec3f);
  }
  /**
   * Increments/decrements the Camera's zoom factor, which is the distance between {@link @xeokit/viewer!Camera.eye | Camera.eye} and {@link @xeokit/viewer!Camera.look | Camera.look}.
   *
   * @param delta Zoom factor increment.
   */;
  _proto.zoom = function zoom(delta) {
    var vec = subVec3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].eye, _classPrivateFieldLooseBase(this, _state$4)[_state$4].look, tempVec3$2);
    var lenLook = Math.abs(lenVec3(vec));
    var newLenLook = Math.abs(lenLook + delta);
    if (newLenLook < 0.5) {
      return;
    }
    var dir = normalizeVec3(vec, tempVec3c$3);
    this.eye = addVec3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].look, mulVec3Scalar(dir, newLenLook), tempVec3d$1);
  }
  /**
   * @private
   */;
  _proto.destroy = function destroy() {
    _Component.prototype.destroy.call(this);
    this.onProjectionType.clear();
    this.onViewMatrix.clear();
    this.onProjMatrix.clear();
    this.onWorldAxis.clear();
  };
  _createClass(Camera, [{
    key: "project",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _activeProjection)[_activeProjection];
    }
    /**
     * Gets the position of the Camera's eye.
     *
     * Default vale is ````[0,0,10]````.
     *
     * @type {Number[]} New eye position.
     */
  }, {
    key: "eye",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$4)[_state$4].eye;
    }
    /**
     * Sets the position of the Camera's eye.
     *
     * Default value is ````[0,0,10]````.
     *
     * @emits "eye" event on change, with the value of this property.
     * @type {Number[]} New eye position.
     */,
    set: function set(eye) {
      // @ts-ignore
      _classPrivateFieldLooseBase(this, _state$4)[_state$4].eye.set(eye);
      this.setDirty(); // Ensure matrix built on next "tick"
    }
    /**
     * Gets the position of this Camera's point-of-interest.
     *
     * Default value is ````[0,0,0]````.
     *
     * @returns {Number[]} Camera look position.
     */
  }, {
    key: "look",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$4)[_state$4].look;
    }
    /**
     * Sets the position of this Camera's point-of-interest.
     *
     * Default value is ````[0,0,0]````.
     *
     * @param look Camera look position.
     */,
    set: function set(look) {
      // @ts-ignore
      _classPrivateFieldLooseBase(this, _state$4)[_state$4].look.set(look);
      this.setDirty(); // Ensure matrix built on next "tick"
    }
    /**
     * Gets the direction of this Camera's {@link @xeokit/viewer!Camera.up | Camera.up} vector.
     *
     * @returns {Number[]} Direction of "up".
     */
  }, {
    key: "up",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$4)[_state$4].up;
    }
    /**
     * Sets the direction of this Camera's {@link @xeokit/viewer!Camera.up | Camera.up} vector.
     *
     * @param up Direction of "up".
     */,
    set: function set(up) {
      // @ts-ignore
      _classPrivateFieldLooseBase(this, _state$4)[_state$4].up.set(up);
      this.setDirty();
    }
    /**
     * Gets the direction of World-space "up".
     *
     * This is set by {@link Camera.worldAxis}.
     *
     * Default value is ````[0,1,0]````.
     *
     * @returns {Number[]} The "up" vector.
     */
  }, {
    key: "worldUp",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldUp;
    }
    /**
     * Gets the direction of World-space "right".
     *
     * This is set by {@link Camera.worldAxis}.
     *
     * Default value is ````[1,0,0]````.
     *
     * @returns {Number[]} The "up" vector.
     */
  }, {
    key: "worldRight",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldRight;
    }
    /**
     * Gets the direction of World-space "forwards".
     *
     * This is set by {@link Camera.worldAxis}.
     *
     * Default value is ````[0,0,1]````.
     *
     * @returns {Number[]} The "up" vector.
     */
  }, {
    key: "worldForward",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldForward;
    }
    /**
     * Gets whether to prevent camera from being pitched upside down.
     *
     * The camera is upside down when the angle between {@link @xeokit/viewer!Camera.up | Camera.up} and {@link Camera.worldUp} is less than one degree.
     *
     * Default value is ````false````.
     *
     * @returns {Boolean} ````true```` if pitch rotation is currently constrained.
     */
  }, {
    key: "constrainPitch",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$4)[_state$4].constrainPitch;
    }
    /**
     * Sets whether to prevent camera from being pitched upside down.
     *
     * The camera is upside down when the angle between {@link @xeokit/viewer!Camera.up | Camera.up} and {@link Camera.worldUp} is less than one degree.
     *
     * Default value is ````false````.
     *
     * @param value Set ````true```` to contrain pitch rotation.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _state$4)[_state$4].constrainPitch = value;
    }
    /**
     * Gets whether to lock yaw rotation to pivot about the World-space "up" axis.
     *
     * @returns {Boolean} Returns ````true```` if gimbal is locked.
     */
  }, {
    key: "gimbalLock",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$4)[_state$4].gimbalLock;
    }
    /**
     * Sets whether to lock yaw rotation to pivot about the World-space "up" axis.
     *
     * @params {Boolean} gimbalLock Set true to lock gimbal.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _state$4)[_state$4].gimbalLock = value;
    }
    /**
     * Gets the up, right and forward axis of the World coordinate system.
     *
     * Has format: ````[rightX, rightY, rightZ, upX, upY, upZ, forwardX, forwardY, forwardZ]````
     *
     * Default axis is ````[1, 0, 0, 0, 1, 0, 0, 0, 1]````
     *
     * @returns {Number[]} The current World coordinate axis.
     */
  }, {
    key: "worldAxis",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldAxis;
    }
    /**
     * Sets the up, right and forward axis of the World coordinate system.
     *
     * Has format: ````[rightX, rightY, rightZ, upX, upY, upZ, forwardX, forwardY, forwardZ]````
     *
     * Default axis is ````[1, 0, 0, 0, 1, 0, 0, 0, 1]````
     *
     * @param axis The new Wworld coordinate axis.
     */,
    set: function set(axis) {
      var state = _classPrivateFieldLooseBase(this, _state$4)[_state$4];
      // @ts-ignore
      state.worldAxis.set(axis);
      state.worldRight[0] = state.worldAxis[0];
      state.worldRight[1] = state.worldAxis[1];
      state.worldRight[2] = state.worldAxis[2];
      state.worldUp[0] = state.worldAxis[3];
      state.worldUp[1] = state.worldAxis[4];
      state.worldUp[2] = state.worldAxis[5];
      state.worldForward[0] = state.worldAxis[6];
      state.worldForward[1] = state.worldAxis[7];
      state.worldForward[2] = state.worldAxis[8];
      this.onWorldAxis.dispatch(this, state.worldAxis);
    }
    /**
     * Gets an optional matrix to premultiply into {@link Camera.projMatrix} matrix.
     *
     * @returns {Number[]} The matrix.
     */
  }, {
    key: "deviceMatrix",
    get: function get() {
      // @ts-ignore
      return _classPrivateFieldLooseBase(this, _state$4)[_state$4].deviceMatrix;
    }
    /**
     * Sets an optional matrix to premultiply into {@link Camera.projMatrix} matrix.
     *
     * This is intended to be used for stereo rendering with WebVR etc.
     *
     * @param matrix The matrix.
     */,
    set: function set(matrix) {
      // @ts-ignore
      _classPrivateFieldLooseBase(this, _state$4)[_state$4].deviceMatrix.set(matrix || [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      _classPrivateFieldLooseBase(this, _state$4)[_state$4].hasDeviceMatrix = !!matrix;
      this.setDirty();
    }
    /**
     * Gets if the World-space X-axis is "up".
     * @returns {boolean}
     */
  }, {
    key: "xUp",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldUp[0] > _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldUp[1] && _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldUp[0] > _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldUp[2];
    }
    /**
     * Gets if the World-space Y-axis is "up".
     * @returns {boolean}
     */
  }, {
    key: "yUp",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldUp[1] > _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldUp[0] && _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldUp[1] > _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldUp[2];
    }
    /**
     * Gets if the World-space Z-axis is "up".
     * @returns {boolean}
     */
  }, {
    key: "zUp",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldUp[2] > _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldUp[0] && _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldUp[2] > _classPrivateFieldLooseBase(this, _state$4)[_state$4].worldUp[1];
    }
    /**
     * Gets distance from {@link @xeokit/viewer!Camera.look | Camera.look} to {@link @xeokit/viewer!Camera.eye | Camera.eye}.
     *
     * @returns {Number} The distance.
     */
  }, {
    key: "eyeLookDist",
    get: function get() {
      return lenVec3(subVec3(_classPrivateFieldLooseBase(this, _state$4)[_state$4].look, _classPrivateFieldLooseBase(this, _state$4)[_state$4].eye, tempVec3$2));
    }
    /**
     * Gets the Camera's viewing transformation matrix.
     *
     * @returns {Number[]} The viewing transform matrix.
     */
  }, {
    key: "viewMatrix",
    get: function get() {
      if (this.dirty) {
        this.cleanIfDirty();
      }
      return _classPrivateFieldLooseBase(this, _state$4)[_state$4].viewMatrix;
    }
    /**
     * Gets the inverse of the Camera's viewing transform matrix.
     *
     * @returns {Number[]} The inverse viewing transform matrix.
     */
  }, {
    key: "inverseViewMatrix",
    get: function get() {
      if (this.dirty) {
        this.cleanIfDirty();
      }
      return _classPrivateFieldLooseBase(this, _state$4)[_state$4].inverseViewMatrix;
    }
    /**
     * Gets the Camera's projection transformation projMatrix.
     *
     * @returns {Number[]} The projection matrix.
     */
  }, {
    key: "projMatrix",
    get: function get() {
      // @ts-ignore
      return _classPrivateFieldLooseBase(this, _activeProjection)[_activeProjection].projMatrix;
    }
    /**
     * Gets the Camera's 3D World-space viewing frustum.
     *
     * @returns {Frustum3} The frustum.
     */
  }, {
    key: "frustum",
    get: function get() {
      if (this.dirty) {
        this.cleanIfDirty();
      }
      return _classPrivateFieldLooseBase(this, _frustum)[_frustum];
    }
    /**
     * Gets the active projection type.
     *
     * Possible values are ````PerspectiveProjectionType````, ````OrthoProjectionType````, ````"frustum"```` and ````"customProjection"````.
     *
     * Default value is ````PerspectiveProjectionType````.
     *
     * @returns {number} Identifies the active projection type.
     */
  }, {
    key: "projectionType",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$4)[_state$4].projectionType;
    }
    /**
     * Sets the active projection type.
     *
     * Accepted values are ````PerspectiveProjectionType````, ````OrthoProjectionType````, ````"frustum"```` and ````"customProjection"````.
     *
     * Default value is ````PerspectiveProjectionType````.
     *
     * @param value Identifies the active projection type.
     */,
    set: function set(value) {
      value = value || PerspectiveProjectionType;
      if (_classPrivateFieldLooseBase(this, _state$4)[_state$4].projectionType === value) {
        return;
      }
      if (value === PerspectiveProjectionType) {
        _classPrivateFieldLooseBase(this, _activeProjection)[_activeProjection] = this.perspectiveProjection;
      } else if (value === OrthoProjectionType) {
        _classPrivateFieldLooseBase(this, _activeProjection)[_activeProjection] = this.orthoProjection;
      } else if (value === FrustumProjectionType) {
        _classPrivateFieldLooseBase(this, _activeProjection)[_activeProjection] = this.frustumProjection;
      } else if (value === CustomProjectionType) {
        _classPrivateFieldLooseBase(this, _activeProjection)[_activeProjection] = this.customProjection;
      } else {
        this.error("Unsupported value for 'projection': " + value + " defaulting to PerspectiveProjectionType");
        _classPrivateFieldLooseBase(this, _activeProjection)[_activeProjection] = this.perspectiveProjection;
        value = PerspectiveProjectionType;
      }
      // @ts-ignore
      _classPrivateFieldLooseBase(this, _activeProjection)[_activeProjection].clean();
      _classPrivateFieldLooseBase(this, _state$4)[_state$4].projectionType = value;
      this.clean();
      this.onProjectionType.dispatch(this, _classPrivateFieldLooseBase(this, _state$4)[_state$4].projectionType);
      this.onProjMatrix.dispatch(this, _classPrivateFieldLooseBase(this, _activeProjection)[_activeProjection].projMatrix);
    }
  }]);
  return Camera;
}(Component);

var tickEvent = {
  viewerId: "",
  time: 0,
  startTime: 0,
  prevTime: 0,
  deltaTime: 0
};
var _viewersRenderInfo = /*#__PURE__*/_classPrivateFieldLooseKey("viewersRenderInfo");
var _viewerIDMap = /*#__PURE__*/_classPrivateFieldLooseKey("viewerIDMap");
var _taskQueue = /*#__PURE__*/_classPrivateFieldLooseKey("taskQueue");
var _taskBudget = /*#__PURE__*/_classPrivateFieldLooseKey("taskBudget");
var _lastTime = /*#__PURE__*/_classPrivateFieldLooseKey("lastTime");
var _elapsedTime = /*#__PURE__*/_classPrivateFieldLooseKey("elapsedTime");
var _runTasks = /*#__PURE__*/_classPrivateFieldLooseKey("runTasks");
var _runTasksUntil = /*#__PURE__*/_classPrivateFieldLooseKey("runTasksUntil");
var _fireTickEvents = /*#__PURE__*/_classPrivateFieldLooseKey("fireTickEvents");
var _renderViewers = /*#__PURE__*/_classPrivateFieldLooseKey("renderViewers");
var Scheduler = /*#__PURE__*/function () {
  /**
   * @private
   */
  function Scheduler() {
    var _this = this;
    Object.defineProperty(this, _renderViewers, {
      value: _renderViewers2
    });
    Object.defineProperty(this, _fireTickEvents, {
      value: _fireTickEvents2
    });
    Object.defineProperty(this, _runTasksUntil, {
      value: _runTasksUntil2
    });
    Object.defineProperty(this, _runTasks, {
      value: _runTasks2
    });
    this.viewers = void 0;
    Object.defineProperty(this, _viewersRenderInfo, {
      writable: true,
      value: {}
    });
    // @ts-ignore
    Object.defineProperty(this, _viewerIDMap, {
      writable: true,
      value: new Map$1()
    });
    // Ensures unique viewer IDs
    Object.defineProperty(this, _taskQueue, {
      writable: true,
      value: new Queue()
    });
    // Task queue, which is pumped on each frame; tasks are pushed to it with calls to xeokit.schedule
    Object.defineProperty(this, _taskBudget, {
      writable: true,
      value: 10
    });
    // Millisecs we're allowed to spend on tasks in each frame
    Object.defineProperty(this, _lastTime, {
      writable: true,
      value: 0
    });
    Object.defineProperty(this, _elapsedTime, {
      writable: true,
      value: 0
    });
    this.viewers = {};
    var frame = function frame() {
      var time = Date.now();
      if (_classPrivateFieldLooseBase(_this, _lastTime)[_lastTime] > 0) {
        _classPrivateFieldLooseBase(_this, _elapsedTime)[_elapsedTime] = time - _classPrivateFieldLooseBase(_this, _lastTime)[_lastTime];
      }
      _classPrivateFieldLooseBase(_this, _runTasks)[_runTasks](time);
      _classPrivateFieldLooseBase(_this, _fireTickEvents)[_fireTickEvents](time);
      _classPrivateFieldLooseBase(_this, _renderViewers)[_renderViewers]();
      _classPrivateFieldLooseBase(_this, _lastTime)[_lastTime] = time;
      requestAnimationFrame(frame);
    };
    requestAnimationFrame(frame);
  }
  var _proto = Scheduler.prototype;
  _proto.registerViewer = function registerViewer(viewer) {
    if (viewer.id) {
      if (this.viewers[viewer.id]) {
        console.error("[ERROR] Viewer " + inQuotes(viewer.id) + " already exists");
        return;
      }
    } else {
      // Auto-generated ID
      // @ts-ignore
      // noinspection JSConstantReassignment
      viewer.id = _classPrivateFieldLooseBase(this, _viewerIDMap)[_viewerIDMap].addItem({});
    }
    this.viewers[viewer.id] = viewer;
    // const ticksPerOcclusionTest = viewer.ticksPerOcclusionTest;
    // const ticksPerRender = viewer.ticksPerRender;
    _classPrivateFieldLooseBase(this, _viewersRenderInfo)[_viewersRenderInfo][viewer.id] = {
      // ticksPerOcclusionTest: ticksPerOcclusionTest,
      // ticksPerRender: ticksPerRender,
      // renderCountdown: ticksPerRender
    };
  };
  _proto.deregisterViewer = function deregisterViewer(viewer) {
    if (!this.viewers[viewer.id]) {
      return;
    }
    _classPrivateFieldLooseBase(this, _viewerIDMap)[_viewerIDMap].removeItem(viewer.id);
    delete this.viewers[viewer.id];
    delete _classPrivateFieldLooseBase(this, _viewersRenderInfo)[_viewersRenderInfo][viewer.id];
  };
  _proto.scheduleTask = function scheduleTask(callback, scope) {
    _classPrivateFieldLooseBase(this, _taskQueue)[_taskQueue].push(callback);
    _classPrivateFieldLooseBase(this, _taskQueue)[_taskQueue].push(scope);
  };
  _proto.getNumTasks = function getNumTasks() {
    return _classPrivateFieldLooseBase(this, _taskQueue)[_taskQueue].length;
  };
  return Scheduler;
}();
function _runTasks2(time) {
  _classPrivateFieldLooseBase(this, _runTasksUntil)[_runTasksUntil](time + _classPrivateFieldLooseBase(this, _taskBudget)[_taskBudget]);
  this.getNumTasks();
  _classPrivateFieldLooseBase(this, _taskBudget)[_taskBudget];
}
function _runTasksUntil2(until) {
  if (until === void 0) {
    until = -1;
  }
  var time = new Date().getTime();
  var tasksRun = 0;
  while (_classPrivateFieldLooseBase(this, _taskQueue)[_taskQueue].length > 0 && (until < 0 || time < until)) {
    var callback = _classPrivateFieldLooseBase(this, _taskQueue)[_taskQueue].shift();
    var scope = _classPrivateFieldLooseBase(this, _taskQueue)[_taskQueue].shift();
    if (scope) {
      callback.call(scope);
    } else {
      callback();
    }
    time = new Date().getTime();
    tasksRun++;
  }
  return tasksRun;
}
function _fireTickEvents2(time) {
  tickEvent.time = time;
  for (var id in scheduler.viewers) {
    if (this.viewers.hasOwnProperty(id)) {
      var viewer = this.viewers[id];
      tickEvent.viewerId = id;
      tickEvent.startTime = viewer.startTime;
      tickEvent.deltaTime = tickEvent.prevTime != null ? tickEvent.time - tickEvent.prevTime : 0;
      viewer.onTick.dispatch(viewer, tickEvent);
    }
  }
  tickEvent.prevTime = time;
}
function _renderViewers2() {
  for (var id in this.viewers) {
    if (this.viewers.hasOwnProperty(id)) {
      var viewer = this.viewers[id];
      var renderInfo = _classPrivateFieldLooseBase(this, _viewersRenderInfo)[_viewersRenderInfo][id];
      if (!renderInfo) {
        renderInfo = _classPrivateFieldLooseBase(this, _viewersRenderInfo)[_viewersRenderInfo][id] = {}; // FIXME
      }
      // const ticksPerOcclusionTest = viewer.ticksPerOcclusionTest;
      // if (renderInfo.ticksPerOcclusionTest !== ticksPerOcclusionTest) {
      //     renderInfo.ticksPerOcclusionTest = ticksPerOcclusionTest;
      //     renderInfo.renderCountdown = ticksPerOcclusionTest;
      // }
      // if (--viewer.occlusionTestCountdown <= 0) {
      //     viewer.doOcclusionTest();
      //     viewer.occlusionTestCountdown = ticksPerOcclusionTest;
      // }
      //
      // ticksPerRender = viewer.ticksPerRender;
      // if (renderInfo.ticksPerRender !== ticksPerRender) {
      //     renderInfo.ticksPerRender = ticksPerRender;
      //     renderInfo.renderCountdown = ticksPerRender;
      // }
      // if (--renderInfo.renderCountdown === 0) {
      viewer.render({});
      //     renderInfo.renderCountdown = ticksPerRender;
      // }
    }
  }
}

var scheduler = new Scheduler();

var tempVec3$1 = createVec3();
var newLook = createVec3();
var newEye = createVec3();
var newUp = createVec3();
var newLookEyeVec = createVec3();
/**
 * Animates its {@link View |View's} {@link @xeokit/viewer!Camera}  to look at specified objects, boundaries or locations.
 *
 * ## Summary
 *
 * * Belongs to a {@link @xeokit/viewer!View}, and is located at {@link View.cameraFlight}
 * * Controls the View's {@link @xeokit/viewer!Camera} , which is located at {@link View.camera}
 * * Navigates the Camera to look at a {@link ViewerObject} or boundary
 * * Navigates the Camera to an explicit position given as ````eye````, ````look```` and ````up```` vectors
 * * Jumps or flies the Camera
 * * Smoothly transitions between projections
 */
var _duration = /*#__PURE__*/_classPrivateFieldLooseKey("duration");
var _look = /*#__PURE__*/_classPrivateFieldLooseKey("look1");
var _eye = /*#__PURE__*/_classPrivateFieldLooseKey("eye1");
var _up = /*#__PURE__*/_classPrivateFieldLooseKey("up1");
var _look2 = /*#__PURE__*/_classPrivateFieldLooseKey("look2");
var _eye2 = /*#__PURE__*/_classPrivateFieldLooseKey("eye2");
var _up2 = /*#__PURE__*/_classPrivateFieldLooseKey("up2");
var _orthoScale = /*#__PURE__*/_classPrivateFieldLooseKey("orthoScale1");
var _orthoScale2 = /*#__PURE__*/_classPrivateFieldLooseKey("orthoScale2");
var _fit = /*#__PURE__*/_classPrivateFieldLooseKey("fit");
var _trail = /*#__PURE__*/_classPrivateFieldLooseKey("trail");
var _flying = /*#__PURE__*/_classPrivateFieldLooseKey("flying");
var _flyEyeLookUp = /*#__PURE__*/_classPrivateFieldLooseKey("flyEyeLookUp");
var _flyingEye = /*#__PURE__*/_classPrivateFieldLooseKey("flyingEye");
var _flyingLook = /*#__PURE__*/_classPrivateFieldLooseKey("flyingLook");
var _callback = /*#__PURE__*/_classPrivateFieldLooseKey("callback");
var _callbackScope = /*#__PURE__*/_classPrivateFieldLooseKey("callbackScope");
var _time = /*#__PURE__*/_classPrivateFieldLooseKey("time1");
var _time2 = /*#__PURE__*/_classPrivateFieldLooseKey("time2");
var _flyingEyeLookUp = /*#__PURE__*/_classPrivateFieldLooseKey("flyingEyeLookUp");
var _fitFOV = /*#__PURE__*/_classPrivateFieldLooseKey("fitFOV");
var _projection = /*#__PURE__*/_classPrivateFieldLooseKey("projection2");
var _projMatrix = /*#__PURE__*/_classPrivateFieldLooseKey("projMatrix1");
var _projMatrix2 = /*#__PURE__*/_classPrivateFieldLooseKey("projMatrix2");
var _jumpTo = /*#__PURE__*/_classPrivateFieldLooseKey("jumpTo");
var _update = /*#__PURE__*/_classPrivateFieldLooseKey("update");
var _ease = /*#__PURE__*/_classPrivateFieldLooseKey("ease");
var _easeInCubic = /*#__PURE__*/_classPrivateFieldLooseKey("easeInCubic");
var _easeOutExpo = /*#__PURE__*/_classPrivateFieldLooseKey("easeOutExpo");
var CameraFlightAnimation = /*#__PURE__*/function (_Component) {
  _inheritsLoose(CameraFlightAnimation, _Component);
  /**
   @private
   */
  function CameraFlightAnimation(view, cfg) {
    var _this;
    _this = _Component.call(this, view, cfg) || this;
    Object.defineProperty(_assertThisInitialized(_this), _update, {
      value: _update2
    });
    Object.defineProperty(_assertThisInitialized(_this), _jumpTo, {
      value: _jumpTo2
    });
    /**
     * The View that owns this CameraFlightAnimation.
     */
    _this.view = void 0;
    /**
     * The Camera controlled by this CameraFlightAnimation.
     */
    _this.camera = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _duration, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _look, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _eye, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _up, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _look2, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _eye2, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _up2, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _orthoScale, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _orthoScale2, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _fit, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _trail, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _flying, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _flyEyeLookUp, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _flyingEye, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _flyingLook, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _callback, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _callbackScope, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _time, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _time2, {
      writable: true,
      value: void 0
    });
    _this.easing = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _flyingEyeLookUp, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _fitFOV, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _projection, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _projMatrix, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _projMatrix2, {
      writable: true,
      value: void 0
    });
    /**
     * Emits an event each time the animation starts.
     *
     * @event
     */
    _this.onStarted = void 0;
    /**
     * Emits an event each time the animation stops.
     *
     * @event
     */
    _this.onStopped = void 0;
    /**
     * Emits an event each time the animation stops.
     *
     * @event
     */
    _this.onCancelled = void 0;
    _this.view = view;
    _this.camera = view.camera;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _look)[_look] = createVec3();
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _eye)[_eye] = createVec3();
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _up)[_up] = createVec3();
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _look2)[_look2] = createVec3();
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _eye2)[_eye2] = createVec3();
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _up2)[_up2] = createVec3();
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _orthoScale)[_orthoScale] = 1;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _orthoScale2)[_orthoScale2] = 1;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _flying)[_flying] = false;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _flyEyeLookUp)[_flyEyeLookUp] = false;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _flyingEye)[_flyingEye] = false;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _flyingLook)[_flyingLook] = false;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _callback)[_callback] = null;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _callbackScope)[_callbackScope] = null;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _time)[_time] = null;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _time2)[_time2] = null;
    _this.easing = true;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _trail)[_trail] = false;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _fit)[_fit] = true;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _duration)[_duration] = 500;
    _this.onStarted = new EventEmitter(new dist.EventDispatcher());
    _this.onStopped = new EventEmitter(new dist.EventDispatcher());
    _this.onCancelled = new EventEmitter(new dist.EventDispatcher());
    return _this;
  }
  /**
   * Flies the {@link @xeokit/viewer!Camera}  to a target.
   *
   *  * When the target is a boundary, the {@link @xeokit/viewer!Camera}  will fly towards the target and stop when the target fills most of the canvas.
   *  * When the target is an explicit {@link @xeokit/viewer!Camera}  position, given as ````eye````, ````look```` and ````up````, then CameraFlightAnimation will interpolate the {@link @xeokit/viewer!Camera}  to that target and stop there.
   *
   * @param {Object|Component} [params=Scene] Either a parameters object or a {@link @xeokit/core!Component} subtype that has
   * an AABB. Defaults to the {@link @xeokit/scene!Scene}, which causes the {@link @xeokit/viewer!Camera}  to fit the Scene in view.
   * @param [params.arc=0] Factor in range ````[0..1]```` indicating how much the {@link @xeokit/viewer!Camera.eye | Camera.eye} position
   * will swing away from its {@link @xeokit/viewer!Camera.look | Camera.look} position as it flies to the target.
   * @param {Number|String|Component} [params.component] ID or instance of a component to fly to. Defaults to the entire {@link @xeokit/scene!Scene}.
   * @param [params.aabb] World-space axis-aligned bounding box (AABB) target to fly to.
   * @param [params.eye] Position to fly the eye position to.
   * @param [params.look] Position to fly the look position to.
   * @param [params.up] Position to fly the up vector to.
   * @param [params.projection] Projection type to transition into as we fly. Can be any of the values of {@link Camera.projectionType}.
   * @param [params.fit=true] Whether to fit the target to the view volume. Overrides {@link CameraFlightAnimation.fit}.
   * @param [params.fitFOV] How much of field-of-view, in degrees, that a target {@link ViewerObject} or its AABB should
   * fill the canvas on arrival. Overrides {@link CameraFlightAnimation.fitFOV}.
   * @param [params.duration] Flight duration in seconds.  Overrides {@link CameraFlightAnimation.duration}.
   * @param [params.orthoScale] Animate the Camera's orthographic scale to this target value. See {@link Ortho.scale}.
   * @param {Function} [callback] Callback fired on arrival.
   * @param {Object} [scope] Optional scope for callback.
   */
  var _proto = CameraFlightAnimation.prototype;
  _proto.flyTo = function flyTo(params, callback) {
    if (params === void 0) {
      params = {};
    }
    if (_classPrivateFieldLooseBase(this, _flying)[_flying]) {
      this.stop();
    }
    _classPrivateFieldLooseBase(this, _flying)[_flying] = false;
    _classPrivateFieldLooseBase(this, _flyingEye)[_flyingEye] = false;
    _classPrivateFieldLooseBase(this, _flyingLook)[_flyingLook] = false;
    _classPrivateFieldLooseBase(this, _flyingEyeLookUp)[_flyingEyeLookUp] = false;
    _classPrivateFieldLooseBase(this, _callback)[_callback] = callback;
    var camera = this.camera;
    var flyToProjection = !!params.projection && params.projection !== camera.projectionType;
    _classPrivateFieldLooseBase(this, _eye)[_eye][0] = camera.eye[0];
    _classPrivateFieldLooseBase(this, _eye)[_eye][1] = camera.eye[1];
    _classPrivateFieldLooseBase(this, _eye)[_eye][2] = camera.eye[2];
    _classPrivateFieldLooseBase(this, _look)[_look][0] = camera.look[0];
    _classPrivateFieldLooseBase(this, _look)[_look][1] = camera.look[1];
    _classPrivateFieldLooseBase(this, _look)[_look][2] = camera.look[2];
    _classPrivateFieldLooseBase(this, _up)[_up][0] = camera.up[0];
    _classPrivateFieldLooseBase(this, _up)[_up][1] = camera.up[1];
    _classPrivateFieldLooseBase(this, _up)[_up][2] = camera.up[2];
    _classPrivateFieldLooseBase(this, _orthoScale)[_orthoScale] = camera.orthoProjection.scale;
    _classPrivateFieldLooseBase(this, _orthoScale2)[_orthoScale2] = params.orthoScale || _classPrivateFieldLooseBase(this, _orthoScale)[_orthoScale];
    var aabb;
    var eye;
    var look;
    var up;
    if (params.aabb) {
      aabb = params.aabb;
    } else if (params.eye && params.look || params.up) {
      // @ts-ignore
      eye = params.eye;
      // @ts-ignore
      look = params.look;
      // @ts-ignore
      up = params.up;
    } else if (params.eye) {
      eye = params.eye;
    } else if (params.look) {
      look = params.look;
    } else {
      if (!flyToProjection) {
        aabb = this.view.aabb;
      }
    }
    var poi = params.poi;
    // @ts-ignore
    if (aabb) {
      if (aabb[3] < aabb[0] || aabb[4] < aabb[1] || aabb[5] < aabb[2]) {
        // Don't fly to an inverted boundary
        return;
      }
      if (aabb[3] === aabb[0] && aabb[4] === aabb[1] && aabb[5] === aabb[2]) {
        // Don't fly to an empty boundary
        return;
      }
      aabb = aabb.slice();
      var aabbCenter = getAABB3Center(aabb);
      _classPrivateFieldLooseBase(this, _look2)[_look2] = poi || aabbCenter;
      var eyeLookVec = subVec3(_classPrivateFieldLooseBase(this, _eye)[_eye], _classPrivateFieldLooseBase(this, _look)[_look], tempVec3$1);
      var eyeLookVecNorm = normalizeVec3(eyeLookVec);
      var diag = poi ? getAABB3DiagPoint(aabb, poi) : getAABB3Diag(aabb);
      var fitFOV = params.fitFOV || _classPrivateFieldLooseBase(this, _fitFOV)[_fitFOV];
      var sca = Math.abs(diag / Math.tan(fitFOV * DEGTORAD));
      _classPrivateFieldLooseBase(this, _orthoScale2)[_orthoScale2] = diag * 1.1;
      _classPrivateFieldLooseBase(this, _eye2)[_eye2][0] = _classPrivateFieldLooseBase(this, _look2)[_look2][0] + eyeLookVecNorm[0] * sca;
      _classPrivateFieldLooseBase(this, _eye2)[_eye2][1] = _classPrivateFieldLooseBase(this, _look2)[_look2][1] + eyeLookVecNorm[1] * sca;
      _classPrivateFieldLooseBase(this, _eye2)[_eye2][2] = _classPrivateFieldLooseBase(this, _look2)[_look2][2] + eyeLookVecNorm[2] * sca;
      _classPrivateFieldLooseBase(this, _up2)[_up2][0] = _classPrivateFieldLooseBase(this, _up)[_up][0];
      _classPrivateFieldLooseBase(this, _up2)[_up2][1] = _classPrivateFieldLooseBase(this, _up)[_up][1];
      _classPrivateFieldLooseBase(this, _up2)[_up2][2] = _classPrivateFieldLooseBase(this, _up)[_up][2];
      _classPrivateFieldLooseBase(this, _flyingEyeLookUp)[_flyingEyeLookUp] = true;
      // @ts-ignore
    } else if (eye || look || up) {
      // @ts-ignore
      _classPrivateFieldLooseBase(this, _flyingEyeLookUp)[_flyingEyeLookUp] = !!eye && !!look && !!up;
      // @ts-ignore
      _classPrivateFieldLooseBase(this, _flyingEye)[_flyingEye] = !!eye && !look;
      // @ts-ignore
      _classPrivateFieldLooseBase(this, _flyingLook)[_flyingLook] = !!look && !eye;
      // @ts-ignore
      if (eye) {
        _classPrivateFieldLooseBase(this, _eye2)[_eye2][0] = eye[0];
        _classPrivateFieldLooseBase(this, _eye2)[_eye2][1] = eye[1];
        _classPrivateFieldLooseBase(this, _eye2)[_eye2][2] = eye[2];
      }
      // @ts-ignore
      if (look) {
        _classPrivateFieldLooseBase(this, _look2)[_look2][0] = look[0];
        _classPrivateFieldLooseBase(this, _look2)[_look2][1] = look[1];
        _classPrivateFieldLooseBase(this, _look2)[_look2][2] = look[2];
      }
      // @ts-ignore
      if (up) {
        _classPrivateFieldLooseBase(this, _up2)[_up2][0] = up[0];
        _classPrivateFieldLooseBase(this, _up2)[_up2][1] = up[1];
        _classPrivateFieldLooseBase(this, _up2)[_up2][2] = up[2];
      }
    }
    if (flyToProjection) {
      if (params.projection === OrthoProjectionType && camera.projectionType !== OrthoProjectionType) {
        _classPrivateFieldLooseBase(this, _projection)[_projection] = OrthoProjectionType;
        _classPrivateFieldLooseBase(this, _projMatrix)[_projMatrix] = camera.projMatrix.slice();
        _classPrivateFieldLooseBase(this, _projMatrix2)[_projMatrix2] = camera.orthoProjection.projMatrix.slice();
        camera.projectionType = CustomProjectionType;
      }
      if (params.projection === PerspectiveProjectionType && camera.projectionType !== PerspectiveProjectionType) {
        _classPrivateFieldLooseBase(this, _projection)[_projection] = PerspectiveProjectionType;
        _classPrivateFieldLooseBase(this, _projMatrix)[_projMatrix] = camera.projMatrix.slice();
        _classPrivateFieldLooseBase(this, _projMatrix2)[_projMatrix2] = camera.perspectiveProjection.projMatrix.slice();
        camera.projectionType = CustomProjectionType;
      }
    } else {
      // @ts-ignore
      _classPrivateFieldLooseBase(this, _projection)[_projection] = null;
    }
    this.onStarted.dispatch(this, null);
    _classPrivateFieldLooseBase(this, _time)[_time] = Date.now();
    _classPrivateFieldLooseBase(this, _time2)[_time2] = _classPrivateFieldLooseBase(this, _time)[_time] + (params.duration ? params.duration * 1000 : _classPrivateFieldLooseBase(this, _duration)[_duration]);
    _classPrivateFieldLooseBase(this, _flying)[_flying] = true; // False as soon as we stop
    scheduler.scheduleTask(_classPrivateFieldLooseBase(this, _update)[_update], this);
  }
  /**
   * Jumps the {@link @xeokit/viewer!View}'s {@link @xeokit/viewer!Camera}  to the given target.
   *
   * * When the target is a boundary, this CameraFlightAnimation will position the {@link @xeokit/viewer!Camera}  at where the target fills most of the canvas.
   * * When the target is an explicit {@link @xeokit/viewer!Camera}  position, given as ````eye````, ````look```` and ````up```` vectors, then this CameraFlightAnimation will jump the {@link @xeokit/viewer!Camera}  to that target.
   *
   * @param {*|Component} params  Either a parameters object or a {@link @xeokit/core!Component} subtype that has a World-space AABB.
   * @param [params.arc=0]  Factor in range [0..1] indicating how much the {@link @xeokit/viewer!Camera.eye | Camera.eye} will swing away from its {@link @xeokit/viewer!Camera.look | Camera.look} as it flies to the target.
   * @param {Number|String|Component} [params.component] ID or instance of a component to fly to.
   * @param [params.aabb]  World-space axis-aligned bounding box (AABB) target to fly to.
   * @param [params.eye] Position to fly the eye position to.
   * @param [params.look]  Position to fly the look position to.
   * @param [params.up] Position to fly the up vector to.
   * @param [params.projection] Projection type to transition into. Can be any of the values of {@link Camera.projectionType}.
   * @param [params.fitFOV] How much of field-of-view, in degrees, that a target {@link ViewerObject} or its AABB should fill the canvas on arrival. Overrides {@link CameraFlightAnimation.fitFOV}.
   * @param [params.fit] Whether to fit the target to the view volume. Overrides {@link CameraFlightAnimation.fit}.
   */;
  _proto.jumpTo = function jumpTo(params) {
    _classPrivateFieldLooseBase(this, _jumpTo)[_jumpTo](params);
  };
  /**
   * Stops an earlier {@link CameraFlightAnimation.flyTo}, fires arrival callback, then "stopped" event.
   */
  _proto.stop = function stop() {
    if (!_classPrivateFieldLooseBase(this, _flying)[_flying]) {
      return;
    }
    _classPrivateFieldLooseBase(this, _flying)[_flying] = false;
    _classPrivateFieldLooseBase(this, _time)[_time] = null;
    _classPrivateFieldLooseBase(this, _time2)[_time2] = null;
    if (_classPrivateFieldLooseBase(this, _projection)[_projection]) {
      this.camera.projectionType = _classPrivateFieldLooseBase(this, _projection)[_projection];
    }
    var callback = _classPrivateFieldLooseBase(this, _callback)[_callback];
    if (callback) {
      _classPrivateFieldLooseBase(this, _callback)[_callback] = null;
      callback();
    }
    this.onStopped.dispatch(this, null);
  }
  /**
   * Cancels a flight in progress, without calling the arrival callback.
   */;
  _proto.cancel = function cancel() {
    if (!_classPrivateFieldLooseBase(this, _flying)[_flying]) {
      return;
    }
    _classPrivateFieldLooseBase(this, _flying)[_flying] = false;
    _classPrivateFieldLooseBase(this, _time)[_time] = null;
    _classPrivateFieldLooseBase(this, _time2)[_time2] = null;
    if (_classPrivateFieldLooseBase(this, _callback)[_callback]) {
      _classPrivateFieldLooseBase(this, _callback)[_callback] = null;
    }
    this.onCancelled.dispatch(this, null);
  }
  /**
   * Sets the flight duration in seconds.
   *
   * Stops any flight currently in progress.
   *
   * Default value is ````0.5````.
   */;
  /**
   * @private
   */
  _proto.destroy = function destroy() {
    this.stop();
    _Component.prototype.destroy.call(this);
    this.onStarted.clear();
    this.onStopped.clear();
    this.onCancelled.clear();
  };
  _createClass(CameraFlightAnimation, [{
    key: "duration",
    get:
    /**
     * Gets the flight duration in seconds.
     *
     * Default value is ````0.5````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _duration)[_duration] / 1000.0;
    }
    /**
     * When flying to a {@link @xeokit/scene!SceneModel | SceneModel}, {@link ViewerObject} or boundary, indicates if the CameraFlightAnimation always adjusts
     * the distance of {@link @xeokit/viewer!Camera.eye | Camera.eye} from {@link @xeokit/viewer!Camera.look | Camera.look} to ensure that the target always fits in view.
     *
     * When false, the eye will remain fixed at its current distance from the look position.
     *
     * Default value is ````true````.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _duration)[_duration] = value ? value * 1000.0 : 500;
      this.stop();
    }
  }, {
    key: "fit",
    get:
    /**
     * When flying to a {@link @xeokit/scene!SceneModel | SceneModel}, {@link ViewerObject} or boundary, indicates if the CameraFlightAnimation always adjusts
     * the distance of {@link @xeokit/viewer!Camera.eye | Camera.eye} from {@link @xeokit/viewer!Camera.look | Camera.look} to ensure that the target always fits in view.
     *
     * When false, the eye will remain fixed at its current distance from the look position.
     *
     * Default value is ````true````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _fit)[_fit];
    }
    /**
     * Sets how much of the perspective field-of-view, in degrees, that a target {@link ViewerObject.aabb} should
     * fill the canvas when calling {@link CameraFlightAnimation.flyTo} or {@link CameraFlightAnimation.jumpTo}.
     *
     * Default value is ````45````.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _fit)[_fit] = value;
    }
  }, {
    key: "fitFOV",
    get:
    /**
     * Gets how much of the perspective field-of-view, in degrees, that a target {@link ViewerObject.aabb} should
     * fill the canvas when calling {@link CameraFlightAnimation.flyTo} or {@link CameraFlightAnimation.jumpTo}.
     *
     * Default value is ````45````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _fitFOV)[_fitFOV];
    }
    /**
     * Indicates if this CameraFlightAnimation will orient the {@link @xeokit/viewer!Camera}
     * in the direction that it is flying.
     *
     * Default value is ````false````.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _fitFOV)[_fitFOV] = value;
    }
  }, {
    key: "trail",
    get:
    /**
     * Indicates if this CameraFlightAnimation will orient the {@link @xeokit/viewer!Camera}
     * in the direction that it is flying.
     *
     * Default value is ````false````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _trail)[_trail];
    },
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _trail)[_trail] = value;
    }
  }]);
  return CameraFlightAnimation;
}(Component);
function _jumpTo2(params) {
  if (_classPrivateFieldLooseBase(this, _flying)[_flying]) {
    this.stop();
  }
  var camera = this.camera;
  var aabb;
  var newEye;
  var newLook;
  var newUp;
  if (params.aabb) {
    // Boundary3D
    aabb = params.aabb;
  } else if (params.eye || params.look || params.up) {
    // Camera pose
    newEye = params.eye;
    newLook = params.look;
    newUp = params.up;
  } else {
    aabb = this.view.aabb;
  }
  var poi = params.poi;
  // @ts-ignore
  if (aabb) {
    if (aabb[3] <= aabb[0] || aabb[4] <= aabb[1] || aabb[5] <= aabb[2]) {
      // Don't fly to an empty boundary
      return;
    }
    var diag = poi ? getAABB3DiagPoint(aabb, poi) : getAABB3Diag(aabb);
    // @ts-ignore
    newLook = poi || getAABB3Center(aabb, newLook);
    if (_classPrivateFieldLooseBase(this, _trail)[_trail]) {
      subVec3(camera.look, newLook, newLookEyeVec);
    } else {
      subVec3(camera.eye, camera.look, newLookEyeVec);
    }
    normalizeVec3(newLookEyeVec);
    var dist;
    var fit = params.fit !== undefined ? params.fit : _classPrivateFieldLooseBase(this, _fit)[_fit];
    if (fit) {
      dist = Math.abs(diag / Math.tan((params.fitFOV || _classPrivateFieldLooseBase(this, _fitFOV)[_fitFOV]) * DEGTORAD));
    } else {
      dist = lenVec3(subVec3(camera.eye, camera.look, tempVec3$1));
    }
    mulVec3Scalar(newLookEyeVec, dist);
    camera.eye = addVec3(newLook, newLookEyeVec, tempVec3$1);
    camera.look = newLook;
    this.camera.orthoProjection.scale = diag * 1.1;
    // @ts-ignore
  } else if (newEye || newLook || newUp) {
    // @ts-ignore
    if (newEye) {
      camera.eye = newEye;
    } // @ts-ignore
    if (newLook) {
      camera.look = newLook;
    } // @ts-ignore
    if (newUp) {
      camera.up = newUp;
    }
  }
  if (params.projection) {
    camera.projectionType = params.projection;
  }
}
function _update2() {
  if (!_classPrivateFieldLooseBase(this, _flying)[_flying]) {
    return;
  }
  var time = Date.now();
  // @ts-ignore
  var t = (time - _classPrivateFieldLooseBase(this, _time)[_time]) / (_classPrivateFieldLooseBase(this, _time2)[_time2] - _classPrivateFieldLooseBase(this, _time)[_time]);
  var stopping = t >= 1;
  if (t > 1) {
    t = 1;
  }
  var tFlight = this.easing ? _classPrivateFieldLooseBase(CameraFlightAnimation, _ease)[_ease](t, 0, 1, 1) : t;
  var camera = this.camera;
  if (_classPrivateFieldLooseBase(this, _flyingEye)[_flyingEye] || _classPrivateFieldLooseBase(this, _flyingLook)[_flyingLook]) {
    if (_classPrivateFieldLooseBase(this, _flyingEye)[_flyingEye]) {
      subVec3(camera.eye, camera.look, newLookEyeVec);
      camera.eye = lerpVec3(tFlight, 0, 1, _classPrivateFieldLooseBase(this, _eye)[_eye], _classPrivateFieldLooseBase(this, _eye2)[_eye2], newEye);
      camera.look = subVec3(newEye, newLookEyeVec, newLook);
    } else if (_classPrivateFieldLooseBase(this, _flyingLook)[_flyingLook]) {
      camera.look = lerpVec3(tFlight, 0, 1, _classPrivateFieldLooseBase(this, _look)[_look], _classPrivateFieldLooseBase(this, _look2)[_look2], newLook);
      camera.up = lerpVec3(tFlight, 0, 1, _classPrivateFieldLooseBase(this, _up)[_up], _classPrivateFieldLooseBase(this, _up2)[_up2], newUp);
    }
  } else if (_classPrivateFieldLooseBase(this, _flyingEyeLookUp)[_flyingEyeLookUp]) {
    camera.eye = lerpVec3(tFlight, 0, 1, _classPrivateFieldLooseBase(this, _eye)[_eye], _classPrivateFieldLooseBase(this, _eye2)[_eye2], newEye);
    camera.look = lerpVec3(tFlight, 0, 1, _classPrivateFieldLooseBase(this, _look)[_look], _classPrivateFieldLooseBase(this, _look2)[_look2], newLook);
    camera.up = lerpVec3(tFlight, 0, 1, _classPrivateFieldLooseBase(this, _up)[_up], _classPrivateFieldLooseBase(this, _up2)[_up2], newUp);
  }
  if (_classPrivateFieldLooseBase(this, _projection)[_projection]) {
    var tProj = _classPrivateFieldLooseBase(this, _projection)[_projection] === OrthoProjectionType ? _classPrivateFieldLooseBase(CameraFlightAnimation, _easeOutExpo)[_easeOutExpo](t, 0, 1, 1) : _classPrivateFieldLooseBase(CameraFlightAnimation, _easeInCubic)[_easeInCubic](t, 0, 1, 1);
    camera.customProjection.projMatrix = lerpMat4(tProj, 0, 1, _classPrivateFieldLooseBase(this, _projMatrix)[_projMatrix], _classPrivateFieldLooseBase(this, _projMatrix2)[_projMatrix2]);
  } else {
    camera.orthoProjection.scale = _classPrivateFieldLooseBase(this, _orthoScale)[_orthoScale] + t * (_classPrivateFieldLooseBase(this, _orthoScale2)[_orthoScale2] - _classPrivateFieldLooseBase(this, _orthoScale)[_orthoScale]);
  }
  if (stopping) {
    camera.orthoProjection.scale = _classPrivateFieldLooseBase(this, _orthoScale2)[_orthoScale2];
    this.stop();
    return;
  }
  scheduler.scheduleTask(_classPrivateFieldLooseBase(this, _update)[_update], this); // Keep flying
}
function _ease2(t, b, c, d) {
  t /= d;
  return -c * t * (t - 2) + b;
}
function _easeInCubic2(t, b, c, d) {
  t /= d;
  return c * t * t * t + b;
}
function _easeOutExpo2(t, b, c, d) {
  return c * (-Math.pow(2, -10 * t / d) + 1) + b;
}
Object.defineProperty(CameraFlightAnimation, _easeOutExpo, {
  value: _easeOutExpo2
});
Object.defineProperty(CameraFlightAnimation, _easeInCubic, {
  value: _easeInCubic2
});
Object.defineProperty(CameraFlightAnimation, _ease, {
  value: _ease2
});

/**
 * Results of a snapshot attempted with {@link View.getSnapshot}.
 */
var SnapshotResult = /*#__PURE__*/function () {
  function SnapshotResult() {
    this.reset();
  }
  /**
   * @private
   */
  var _proto = SnapshotResult.prototype;
  _proto.reset = function reset() {};
  return SnapshotResult;
}();

//  /**
//      * Gets the scale of the canvas back buffer relative to the CSS-defined size of the canvas.
//      *
//      * This is a kdtree3 way to trade off rendering quality for speed. If the canvas size is defined in CSS, then
//      * setting this to a value between ````[0..1]```` (eg ````0.5````) will render into a smaller back buffer, giving
//      * a performance boost.
//      *
//      * @returns  The resolution scale.
//      */
// get resolutionScale(): number {
//     return this.#resolutionScale;
// }
//
// /**
//  * Sets the scale of the canvas back buffer relative to the CSS-defined size of the canvas.
//  *
//  * This is a kdtree3 way to trade off rendering quality for speed. If the canvas size is defined in CSS, then
//  * setting this to a value between ````[0..1]```` (eg ````0.5````) will render into a smaller back buffer, giving
//  * a performance boost.
//  *
//  * @param resolutionScale The resolution scale.
//  */
// set resolutionScale(resolutionScale: number) {
//     resolutionScale = resolutionScale || 1.0;
//     if (resolutionScale === this.#resolutionScale) {
//         return;
//     }
//     this.#resolutionScale = resolutionScale;
//     const canvasElement = this.canvasElement;
//     canvasElement.width = Math.round(
//         canvasElement.clientWidth * this.#resolutionScale
//     );
//     canvasElement.height = Math.round(
//         canvasElement.clientHeight * this.#resolutionScale
//     );
//     this.redraw();
// }
/**
 * Configures the appearance of {@link @xeokit/viewer!ViewObject | ViewObjects} when canvas resolution scaling is applied.
 *
 * ## Summary
 *
 * * Located at {@link View.resolutionScale}.
 */
var _state$3 = /*#__PURE__*/_classPrivateFieldLooseKey("state");
var ResolutionScale = /*#__PURE__*/function (_Component) {
  _inheritsLoose(ResolutionScale, _Component);
  /**
   * @private
   */
  function ResolutionScale(view, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _Component.call(this, view, options) || this;
    /**
     * The View to which this ResolutionScale belongs.
     */
    _this.view = void 0;
    /**
     * @private
     */
    Object.defineProperty(_assertThisInitialized(_this), _state$3, {
      writable: true,
      value: void 0
    });
    _this.view = view;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _state$3)[_state$3] = {
      enabled: options.enabled !== false,
      renderModes: options.renderModes || [FastRender],
      resolutionScale: options.resolutionScale || 1
    };
    return _this;
  }
  /**
   * Sets if resolution scaling is enabled.
   *
   * Default is ````true````.
   */
  var _proto = ResolutionScale.prototype;
  /**
   * @private
   */
  _proto.destroy = function destroy() {
    _Component.prototype.destroy.call(this);
  };
  _createClass(ResolutionScale, [{
    key: "enabled",
    get:
    /**
     * Gets if resolution scaling is enabled.
     *
     * Default is ````true````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$3)[_state$3].enabled;
    }
    /**
     * Sets which rendering modes in which to apply ResolutionScale.
     *
     * Accepted modes are {@link @xeokit/constants!QualityRender} and {@link @xeokit/constants!FastRender}.
     *
     * Default value is [{@link @xeokit/constants!FastRender}].
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$3)[_state$3].enabled === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$3)[_state$3].enabled = value;
      this.view.redraw();
    }
  }, {
    key: "renderModes",
    get:
    /**
     * Gets which rendering modes in which to apply ResolutionScale.
     *
     * Accepted modes are {@link @xeokit/constants!QualityRender} and {@link @xeokit/constants!FastRender}.
     *
     * Default value is [{@link @xeokit/constants!FastRender}].
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$3)[_state$3].renderModes;
    }
    /**
     * Sets the scale when ResolutionScale is applied.
     *
     * Default is ````1.0````.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _state$3)[_state$3].renderModes = value;
      this.view.redraw();
    }
  }, {
    key: "resolutionScale",
    get:
    /**
     * Gets the scale when ResolutionScale is applied.
     *
     * Default is ````1.0````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$3)[_state$3].resolutionScale;
    },
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _state$3)[_state$3].resolutionScale === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state$3)[_state$3].resolutionScale = value;
      this.view.redraw();
    }
  }]);
  return ResolutionScale;
}(Component);

/**
 * An independently-configurable view of the models in a {@link @xeokit/viewer!Viewer}.
 *
 * See {@link @xeokit/viewer} for usage.
 *
 * ## Overview
 *
 * A View is an independently-configurable view of the {@link RendererViewObject | ViewerObjects} existing within a Viewer, with
 * its own HTML canvas. A View automatically contains a {@link @xeokit/viewer!ViewObject} for each existing ViewerObject. ViewObjects
 * function as a kind of proxy for the ViewerObjects, through which we control their appearance
 * (show/hide/highlight etc.) within that particular View's canvas.
 *
 * Using Views, we can essentially have multiple canvases viewing the same model, each canvas perhaps showing a different subset
 * of the objects, with different visual effects, camera position etc.
 *
 * ## Quickstart
 *
 * * Create a View with {@link Viewer.createView}
 * * Control the View's viewpoint and projection with {@link View.camera}
 * * Create light sources with {@link View.createLightSource}
 * * Create slicing planes with {@link View createSectionPlane}
 * * Each View automatically has a {@link @xeokit/viewer!ViewObject} for every {@link RendererViewObject}
 * * Uses {@link @xeokit/view!ViewLayer | ViewLayers} to organize ViewObjects into layers
 * * Optionally uses ViewLayers to mask which ViewObjects are automatically maintained
 * * Control the visibility of ViewObjects with {@link View.setObjectsVisible}
 * * Emphasise ViewObjects with {@link View.setObjectsHighlighted}, {@link View.setObjectsSelected}, {@link View.setObjectsXRayed} and {@link View.setObjectsColorized}
 *
 * ## Examples
 *
 * Create a view in a given canvas, with three objects visible and a couple of object X-rayed (rendered translucent):
 *
 * ````javascript
 * const view1 = myViewer.createView({
 *      id: "myView",
 *      canvasId: "myView1"
 * });
 *
 * view1.camera.eye = [-3.933, 2.855, 27.018];
 * view1.camera.look = [4.400, 3.724, 8.899];
 * view1.camera.up = [-0.018, 0.999, 0.039];
 *
 * view1.setObjectsVisible(["myObject1", "myObject2", "myObject3", ...], true);
 * view1.setObjectsXRayed(["myObject1", "myObject", ...], true);
 * ````
 *
 * Create a second view, using a different canvas, that shows two objects visible, with one of them highlighted:
 *
 * ```` javascript
 * const view2 = myViewer.createView({
 *      id: "myView2",
 *      canvasId: "myView2"
 * });
 *
 * view2.camera.eye = [-1.4, 1.5, 15.8];
 * view2.camera.look = [4.0, 3.7, 1.8];
 * view2.camera.up = [0.0, 0.9, 0.0];
 *
 * view2.setObjectsVisible(["myObject1", "myObject3", ...], true);
 * view2.setObjectsHighlighted(["myObject3", ...], true);
 * ````
 */
var _onTick$4 = /*#__PURE__*/_classPrivateFieldLooseKey("onTick");
var _renderMode = /*#__PURE__*/_classPrivateFieldLooseKey("renderMode");
var _backgroundColor = /*#__PURE__*/_classPrivateFieldLooseKey("backgroundColor");
var _backgroundColorFromAmbientLight = /*#__PURE__*/_classPrivateFieldLooseKey("backgroundColorFromAmbientLight");
var _numObjects = /*#__PURE__*/_classPrivateFieldLooseKey("numObjects");
var _objectIds = /*#__PURE__*/_classPrivateFieldLooseKey("objectIds");
var _numVisibleObjects = /*#__PURE__*/_classPrivateFieldLooseKey("numVisibleObjects");
var _visibleObjectIds = /*#__PURE__*/_classPrivateFieldLooseKey("visibleObjectIds");
var _numXRayedObjects = /*#__PURE__*/_classPrivateFieldLooseKey("numXRayedObjects");
var _xrayedObjectIds = /*#__PURE__*/_classPrivateFieldLooseKey("xrayedObjectIds");
var _numHighlightedObjects = /*#__PURE__*/_classPrivateFieldLooseKey("numHighlightedObjects");
var _highlightedObjectIds = /*#__PURE__*/_classPrivateFieldLooseKey("highlightedObjectIds");
var _numSelectedObjects = /*#__PURE__*/_classPrivateFieldLooseKey("numSelectedObjects");
var _selectedObjectIds = /*#__PURE__*/_classPrivateFieldLooseKey("selectedObjectIds");
var _numColorizedObjects = /*#__PURE__*/_classPrivateFieldLooseKey("numColorizedObjects");
var _colorizedObjectIds = /*#__PURE__*/_classPrivateFieldLooseKey("colorizedObjectIds");
var _numOpacityObjects = /*#__PURE__*/_classPrivateFieldLooseKey("numOpacityObjects");
var _opacityObjectIds = /*#__PURE__*/_classPrivateFieldLooseKey("opacityObjectIds");
var _qualityRender = /*#__PURE__*/_classPrivateFieldLooseKey("qualityRender");
var _lightsHash = /*#__PURE__*/_classPrivateFieldLooseKey("lightsHash");
var _sectionPlanesHash = /*#__PURE__*/_classPrivateFieldLooseKey("sectionPlanesHash");
var _createViewObjectsForSceneModel = /*#__PURE__*/_classPrivateFieldLooseKey("createViewObjectsForSceneModel");
var _registerSectionPlane = /*#__PURE__*/_classPrivateFieldLooseKey("registerSectionPlane");
var _deregisterSectionPlane = /*#__PURE__*/_classPrivateFieldLooseKey("deregisterSectionPlane");
var _destroyViewObjectsForSceneModel = /*#__PURE__*/_classPrivateFieldLooseKey("destroyViewObjectsForSceneModel");
var View = /*#__PURE__*/function (_Component) {
  _inheritsLoose(View, _Component);
  /**
   * @private
   */
  function View(options) {
    var _this;
    _this = _Component.call(this, null, options) || this;
    Object.defineProperty(_assertThisInitialized(_this), _destroyViewObjectsForSceneModel, {
      value: _destroyViewObjectsForSceneModel2
    });
    Object.defineProperty(_assertThisInitialized(_this), _deregisterSectionPlane, {
      value: _deregisterSectionPlane2
    });
    Object.defineProperty(_assertThisInitialized(_this), _registerSectionPlane, {
      value: _registerSectionPlane2
    });
    Object.defineProperty(_assertThisInitialized(_this), _createViewObjectsForSceneModel, {
      value: _createViewObjectsForSceneModel2
    });
    /**
     * The index of this View in {@link Viewer.viewList}.
     * @private
     */
    _this.viewIndex = void 0;
    /**
     * Manages the Camera for this View.
     */
    _this.camera = void 0;
    /**
     * The HTML canvas.
     */
    _this.canvasElement = void 0;
    /**
     * Indicates if this View is transparent.
     */
    _this.transparent = void 0;
    /**
     * Boundary of the canvas in absolute browser window coordinates.
     * Format is ````[xmin, ymin, xwidth, ywidth]````.
     */
    _this.boundary = void 0;
    /**
     * Whether the logarithmic depth buffer is enabled for this View.
     */
    _this.logarithmicDepthBufferEnabled = void 0;
    /**
     * Configures Scalable Ambient Obscurance (SAO) for this View.
     */
    _this.sao = void 0;
    /**
     * Flies or jumps the View's {@link @xeokit/viewer!Camera}  to given positions.
     */
    _this.cameraFlight = void 0;
    /**
     * Manages measurement units, origin and scale for this View.
     */
    _this.metrics = void 0;
    /**
     * Configures the X-rayed appearance of {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     */
    _this.xrayMaterial = void 0;
    /**
     * Configures the highlighted appearance of {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     */
    _this.highlightMaterial = void 0;
    /**
     * Configures the appearance of {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     */
    _this.selectedMaterial = void 0;
    /**
     * Configures the appearance of edges belonging to {@link @xeokit/viewer!ViewObject} in this View.
     */
    _this.edges = void 0;
    /**
     * Configures resolution scaling for this View.
     */
    _this.resolutionScale = void 0;
    /**
     * Configures the appearance of point primitives belonging to {@link @xeokit/viewer!ViewObject | ViewObjects} in this View .
     */
    _this.pointsMaterial = void 0;
    /**
     * Configures the appearance of lines belonging to {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     */
    _this.linesMaterial = void 0;
    /**
     * Map of the all {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     *
     * Each {@link @xeokit/viewer!ViewObject} is mapped here by {@link @xeokit/viewer!ViewObject.id}.
     *
     * The View automatically ensures that there is a {@link @xeokit/viewer!ViewObject} here for
     * each {@link RendererViewObject} in the {@link @xeokit/viewer!Viewer}
     */
    _this.objects = void 0;
    /**
     * Map of the currently visible {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     *
     * A ViewObject is visible when {@link @xeokit/viewer!ViewObject.visible} is true.
     *
     * Each {@link @xeokit/viewer!ViewObject} is mapped here by {@link @xeokit/viewer!ViewObject.id}.
     */
    _this.visibleObjects = void 0;
    /**
     * Map of currently x-rayed {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     *
     * A ViewObject is x-rayed when {@link @xeokit/viewer!ViewObject.xrayed} is true.
     *
     * Each {@link @xeokit/viewer!ViewObject} is mapped here by {@link @xeokit/viewer!ViewObject.id}.
     */
    _this.xrayedObjects = void 0;
    /**
     * Map of currently highlighted {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     *
     * A ViewObject is highlighted when {@link @xeokit/viewer!ViewObject.highlighted} is true.
     *
     * Each {@link @xeokit/viewer!ViewObject} is mapped here by {@link @xeokit/viewer!ViewObject.id}.
     */
    _this.highlightedObjects = void 0;
    /**
     * Map of currently selected {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     *
     * A ViewObject is selected when {@link @xeokit/viewer!ViewObject.selected} is true.
     *
     * Each {@link @xeokit/viewer!ViewObject} is mapped here by {@link @xeokit/viewer!ViewObject.id}.
     */
    _this.selectedObjects = void 0;
    /**
     * Map of currently colorized {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     *
     * Each {@link @xeokit/viewer!ViewObject} is mapped here by {@link @xeokit/viewer!ViewObject.id}.
     */
    _this.colorizedObjects = void 0;
    /**
     * Map of {@link @xeokit/viewer!ViewObject | ViewObjects} in this View whose opacity has been updated.
     *
     * Each {@link @xeokit/viewer!ViewObject} is mapped here by {@link @xeokit/viewer!ViewObject.id}.
     */
    _this.opacityObjects = void 0;
    /**
     * Map of {@link SectionPlane}s in this View.
     *
     * Each {@link SectionPlane} is mapped here by {@link SectionPlane.id}.
     */
    _this.sectionPlanes = void 0;
    /**
     * List of {@link SectionPlane}s in this View.
     */
    _this.sectionPlanesList = [];
    /**
     * Map of light sources in this View.
     */
    _this.lights = void 0;
    /**
     * List of light sources in this View.
     */
    _this.lightsList = [];
    _this.gammaOutput = void 0;
    /**
     * Map of the all {@link @xeokit/viewer!ViewLayer}s in this View.
     *
     * Each {@link @xeokit/viewer!ViewLayer} is mapped here by {@link @xeokit/view!ViewLayer.id}.
     */
    _this.layers = void 0;
    /**
     * Whether the View will automatically create {@link @xeokit/view!ViewLayer | ViewLayers} on-demand
     * as {@link RendererViewObject | ViewerObjects} are created.
     *
     * When ````true```` (default), the View will automatically create {@link @xeokit/view!ViewLayer | ViewLayers} as needed for each new
     * {@link RendererViewObject.layerId} encountered, including a "default" ViewLayer for ViewerObjects that have no
     * layerId. This default setting therefore ensures that a ViewObject is created in the View for every SceneObject that is created.
     *
     * If you set this ````false````, however, then the View will only create {@link @xeokit/viewer!ViewObject | ViewObjects} for {@link RendererViewObject | ViewerObjects} that have
     * a {@link RendererViewObject.layerId} that matches the ID of a {@link @xeokit/viewer!ViewLayer} that you have explicitly created previously with {@link View.createLayer}.
     *
     * Setting this parameter false enables Views to contain only the ViewObjects that they actually need to show, i.e. to represent only
     * ViewerObjects that they need to view. This enables a View to avoid wastefully creating and maintaining ViewObjects for ViewerObjects
     * that it never needs to show.
     */
    _this.autoLayers = void 0;
    /**
     * Emits an event each time the canvas boundary changes.
     *
     * @event
     */
    _this.onBoundary = void 0;
    /**
     * Emits an event each time the visibility of a {@link @xeokit/viewer!ViewObject} changes in this View.
     *
     * ViewObjects are shown and hidden with {@link View.setObjectsVisible}, {@link @xeokit/view!ViewLayer.setObjectsVisible} or {@link @xeokit/viewer!ViewObject.visible}.
     *
     * @event
     */
    _this.onObjectVisibility = void 0;
    /**
     * Emits an event each time the X-ray state of a {@link @xeokit/viewer!ViewObject} changes in this View.
     *
     * ViewObjects are X-rayed with {@link View.setObjectsXRayed}, {@link @xeokit/view!ViewLayer.setObjectsXRayed} or {@link @xeokit/viewer!ViewObject.xrayed}.
     *
     * @event
     */
    _this.onObjectXRayed = void 0;
    /**
     * Emits an event each time a {@link @xeokit/viewer!ViewLayer} is created in this View.
     *
     * Layers are created explicitly with {@link View.createLayer}, or implicitly with {@link View.createModel} and {@link CreateModelParams.layerId}.
     *
     * @event
     */
    _this.onLayerCreated = void 0;
    /**
     * Emits an event each time a {@link @xeokit/viewer!ViewLayer} in this View is destroyed.
     *
     * ViewLayers are destroyed explicitly with {@link @xeokit/view!ViewLayer.destroy}, or implicitly when they become empty and {@link View.autoLayers} is false.
     *
     * @event
     */
    _this.onLayerDestroyed = void 0;
    /**
     * Emits an event each time a {@link SectionPlane} is created in this View.
     *
     * @event
     */
    _this.onSectionPlaneCreated = void 0;
    /**
     * Emits an event each time a {@link SectionPlane} in this View is destroyed.
     *
     * @event
     */
    _this.onSectionPlaneDestroyed = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _onTick$4, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _renderMode, {
      writable: true,
      value: QualityRender
    });
    Object.defineProperty(_assertThisInitialized(_this), _backgroundColor, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _backgroundColorFromAmbientLight, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _numObjects, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _objectIds, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _numVisibleObjects, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _visibleObjectIds, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _numXRayedObjects, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _xrayedObjectIds, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _numHighlightedObjects, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _highlightedObjectIds, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _numSelectedObjects, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _selectedObjectIds, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _numColorizedObjects, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _colorizedObjectIds, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _numOpacityObjects, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _opacityObjectIds, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _qualityRender, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _lightsHash, {
      writable: true,
      value: null
    });
    Object.defineProperty(_assertThisInitialized(_this), _sectionPlanesHash, {
      writable: true,
      value: null
    });
    _this.viewer = options.viewer;
    var canvas = options.canvasElement || document.getElementById(options.canvasId);
    if (!(canvas instanceof HTMLCanvasElement)) {
      throw "Mandatory View config expected: valid canvasId or canvasElement";
    }
    _this.canvasElement = canvas;
    _this.viewIndex = 0;
    _this.objects = {};
    _this.visibleObjects = {};
    _this.xrayedObjects = {};
    _this.highlightedObjects = {};
    _this.selectedObjects = {};
    _this.colorizedObjects = {};
    _this.opacityObjects = {};
    _this.sectionPlanes = {};
    _this.sectionPlanesList = [];
    _this.lights = {};
    _this.lightsList = [];
    _this.layers = {};
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _numObjects)[_numObjects] = 0;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _objectIds)[_objectIds] = null;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _numVisibleObjects)[_numVisibleObjects] = 0;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _visibleObjectIds)[_visibleObjectIds] = null;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _numXRayedObjects)[_numXRayedObjects] = 0;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _xrayedObjectIds)[_xrayedObjectIds] = null;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _numHighlightedObjects)[_numHighlightedObjects] = 0;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _highlightedObjectIds)[_highlightedObjectIds] = null;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _numSelectedObjects)[_numSelectedObjects] = 0;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _selectedObjectIds)[_selectedObjectIds] = null;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _numColorizedObjects)[_numColorizedObjects] = 0;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _colorizedObjectIds)[_colorizedObjectIds] = null;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _numOpacityObjects)[_numOpacityObjects] = 0;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _opacityObjectIds)[_opacityObjectIds] = null;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _qualityRender)[_qualityRender] = !!options.qualityRender;
    _this.gammaOutput = true;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _sectionPlanesHash)[_sectionPlanesHash] = null;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _lightsHash)[_lightsHash] = null;
    // this.canvas = new View(this, {
    //     canvas: canvas,
    //     transparent: !!options.transparent,
    //     backgroundColor: options.backgroundColor,
    //     backgroundColorFromAmbientLight: !!options.backgroundColorFromAmbientLight,
    //     premultipliedAlpha: !!options.premultipliedAlpha
    // });
    //
    // this.canvas.onBoundary.subscribe(() => {
    //     this.redraw();
    // });
    _this.onBoundary = new EventEmitter(new dist.EventDispatcher());
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _backgroundColor)[_backgroundColor] = createVec3([options.backgroundColor ? options.backgroundColor[0] : 1, options.backgroundColor ? options.backgroundColor[1] : 1, options.backgroundColor ? options.backgroundColor[2] : 1]);
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _backgroundColorFromAmbientLight)[_backgroundColorFromAmbientLight] = !!options.backgroundColorFromAmbientLight;
    _this.transparent = !!options.transparent;
    _this.canvasElement.width = _this.canvasElement.clientWidth;
    _this.canvasElement.height = _this.canvasElement.clientHeight;
    _this.boundary = [_this.canvasElement.offsetLeft, _this.canvasElement.offsetTop, _this.canvasElement.clientWidth, _this.canvasElement.clientHeight];
    _this.resolutionScale = new ResolutionScale(_assertThisInitialized(_this), {
      enabled: true,
      renderModes: [FastRender],
      resolutionScale: 0.5
    });
    // Publish canvasElement size and position changes on each scene tick
    var lastWindowWidth = 0;
    var lastWindowHeight = 0;
    var lastViewWidth = 0;
    var lastViewHeight = 0;
    var lastViewOffsetLeft = 0;
    var lastViewOffsetTop = 0;
    var lastParent = null;
    var lastResolutionScale = null;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _onTick$4)[_onTick$4] = _this.viewer.onTick.subscribe(function () {
      var canvasElement = _this.canvasElement;
      var newResolutionScale = _this.resolutionScale.resolutionScale !== lastResolutionScale;
      var newWindowSize = window.innerWidth !== lastWindowWidth || window.innerHeight !== lastWindowHeight;
      var newViewSize = canvasElement.clientWidth !== lastViewWidth || canvasElement.clientHeight !== lastViewHeight;
      var newViewPos = canvasElement.offsetLeft !== lastViewOffsetLeft || canvasElement.offsetTop !== lastViewOffsetTop;
      var parent = canvasElement.parentElement;
      var newParent = parent !== lastParent;
      if (newResolutionScale || newWindowSize || newViewSize || newViewPos || newParent) {
        //   this._spinner._adjustPosition();
        if (newResolutionScale || newViewSize || newViewPos) {
          var newWidth = canvasElement.clientWidth;
          var newHeight = canvasElement.clientHeight;
          if (newResolutionScale || newViewSize) {
            //////////////////////////////////////////////////////////////////////////////////////
            // TODO: apply resolutionscale properly
            //////////////////////////////////////////////////////////////////////////////////////
            canvasElement.width = Math.round(canvasElement.clientWidth * _this.resolutionScale.resolutionScale);
            canvasElement.height = Math.round(canvasElement.clientHeight * _this.resolutionScale.resolutionScale);
          }
          var boundary = _this.boundary;
          boundary[0] = canvasElement.offsetLeft;
          boundary[1] = canvasElement.offsetTop;
          boundary[2] = newWidth;
          boundary[3] = newHeight;
          if (!newResolutionScale || newViewSize) {
            _this.onBoundary.dispatch(_assertThisInitialized(_this), boundary);
          }
          lastViewWidth = newWidth;
          lastViewHeight = newHeight;
        }
        if (newWindowSize) {
          lastWindowWidth = window.innerWidth;
          lastWindowHeight = window.innerHeight;
        }
        if (newViewPos) {
          lastViewOffsetLeft = canvasElement.offsetLeft;
          lastViewOffsetTop = canvasElement.offsetTop;
        }
        lastParent = parent;
      }
    });
    _this.camera = new Camera(_assertThisInitialized(_this));
    _this.sao = new SAO(_assertThisInitialized(_this), {});
    _this.cameraFlight = new CameraFlightAnimation(_assertThisInitialized(_this), {
      duration: 0.5
    });
    _this.metrics = new Metrics(_assertThisInitialized(_this), {
      units: options.units,
      scale: options.scale,
      origin: options.origin
    });
    _this.xrayMaterial = new EmphasisMaterial(_assertThisInitialized(_this), {
      fill: true,
      fillColor: [0.9, 0.7, 0.6],
      fillAlpha: 0.4,
      edges: true,
      edgeColor: [0.5, 0.4, 0.4],
      edgeAlpha: 1.0,
      edgeWidth: 1
    });
    _this.highlightMaterial = new EmphasisMaterial(_assertThisInitialized(_this), {
      fill: true,
      fillColor: [1.0, 1.0, 0.0],
      fillAlpha: 0.5,
      edges: true,
      edgeColor: [0.5, 0.4, 0.4],
      edgeAlpha: 1.0,
      edgeWidth: 1
    });
    _this.selectedMaterial = new EmphasisMaterial(_assertThisInitialized(_this), {
      fill: true,
      fillColor: [0.0, 1.0, 0.0],
      fillAlpha: 0.5,
      edges: true,
      edgeColor: [0.4, 0.5, 0.4],
      edgeAlpha: 1.0,
      edgeWidth: 1
    });
    _this.edges = new Edges(_assertThisInitialized(_this), {
      edgeColor: [0.0, 0.0, 0.0],
      edgeAlpha: 1.0,
      edgeWidth: 1,
      enabled: true,
      renderModes: [QualityRender]
    });
    _this.pointsMaterial = new PointsMaterial(_assertThisInitialized(_this), {
      pointSize: 1,
      roundPoints: true,
      perspectivePoints: true,
      minPerspectivePointSize: 1,
      maxPerspectivePointSize: 6,
      filterIntensity: false,
      minIntensity: 0,
      maxIntensity: 1
    });
    _this.linesMaterial = new LinesMaterial(_assertThisInitialized(_this), {
      lineWidth: 1
    });
    _this.lights = {};
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _qualityRender)[_qualityRender] = !!options.qualityRender;
    _this.autoLayers = options.autoLayers !== false;
    _this.logarithmicDepthBufferEnabled = !!options.logarithmicDepthBufferEnabled;
    _this.onObjectVisibility = new EventEmitter(new dist.EventDispatcher());
    _this.onObjectXRayed = new EventEmitter(new dist.EventDispatcher());
    _this.onLayerCreated = new EventEmitter(new dist.EventDispatcher());
    _this.onLayerDestroyed = new EventEmitter(new dist.EventDispatcher());
    _this.onSectionPlaneCreated = new EventEmitter(new dist.EventDispatcher());
    _this.onSectionPlaneDestroyed = new EventEmitter(new dist.EventDispatcher());
    return _this;
  }
  /**
   * @private
   */
  var _proto = View.prototype;
  _proto.initViewObjects = function initViewObjects() {
    var _this2 = this;
    for (var id in this.viewer.scene.models) {
      _classPrivateFieldLooseBase(this, _createViewObjectsForSceneModel)[_createViewObjectsForSceneModel](this.viewer.scene.models[id]);
    }
    this.viewer.scene.onModelCreated.subscribe(function (scene, sceneModel) {
      _classPrivateFieldLooseBase(_this2, _createViewObjectsForSceneModel)[_createViewObjectsForSceneModel](sceneModel);
    });
    this.viewer.scene.onModelDestroyed.subscribe(function (scene, sceneModel) {
      _classPrivateFieldLooseBase(_this2, _destroyViewObjectsForSceneModel)[_destroyViewObjectsForSceneModel](sceneModel);
    });
  };
  /**
   * Sets which rendering mode this View is in.
   *
   * Supported rendering modes are:
   *
   * * {@link @xeokit/constants!FastRender | FastRender} - Fast rendering mode for smooth interactivity.
   * * {@link @xeokit/constants!QualityRender | QualityRender} - Quality rendering mode for maximum image fidelity.
   *
   * Default value is {@link @xeokit/constants!QualityRender | QualityRender}.
   *
   * @param renderMode The rendering mode
   * @returns *{@link @xeokit/core!SDKError}*
   * * Rendering mode not supported.
   */
  _proto.setRenderMode = function setRenderMode(renderMode) {
    if (renderMode !== QualityRender && renderMode !== FastRender) {
      return new SDKError("Failed to set render mode for View - unsupported mode - supported modes are FastRender and QualityRender");
    }
    _classPrivateFieldLooseBase(this, _renderMode)[_renderMode] = renderMode;
  }
  /**
   * Gets which rendering mode this View is in.
   *
   * Supported rendering modes are:
   *
   * * {@link @xeokit/constants!FastRender | FastRender} - Fast rendering mode for smooth interactivity.
   * * {@link @xeokit/constants!QualityRender | QualityRender} - Quality rendering mode for maximum image fidelity.
   *
   * Default value is {@link @xeokit/constants!QualityRender | QualityRender}.
   */;
  /**
   * @private
   */
  _proto.registerViewObject = function registerViewObject(viewObject) {
    this.objects[viewObject.id] = viewObject;
    _classPrivateFieldLooseBase(this, _numObjects)[_numObjects]++;
    _classPrivateFieldLooseBase(this, _objectIds)[_objectIds] = null; // Lazy regenerate
  }
  /**
   * @private
   */;
  _proto.deregisterViewObject = function deregisterViewObject(viewObject) {
    delete this.objects[viewObject.id];
    delete this.visibleObjects[viewObject.id];
    delete this.xrayedObjects[viewObject.id];
    delete this.highlightedObjects[viewObject.id];
    delete this.selectedObjects[viewObject.id];
    delete this.colorizedObjects[viewObject.id];
    delete this.opacityObjects[viewObject.id];
    _classPrivateFieldLooseBase(this, _numObjects)[_numObjects]--;
    _classPrivateFieldLooseBase(this, _objectIds)[_objectIds] = null; // Lazy regenerate
  }
  /**
   * @private
   */;
  _proto.objectVisibilityUpdated = function objectVisibilityUpdated(viewObject, visible, notify) {
    if (notify === void 0) {
      notify = true;
    }
    if (visible) {
      this.visibleObjects[viewObject.id] = viewObject;
      _classPrivateFieldLooseBase(this, _numVisibleObjects)[_numVisibleObjects]++;
    } else {
      delete this.visibleObjects[viewObject.id];
      _classPrivateFieldLooseBase(this, _numVisibleObjects)[_numVisibleObjects]--;
    }
    _classPrivateFieldLooseBase(this, _visibleObjectIds)[_visibleObjectIds] = null; // Lazy regenerate
    if (notify) {
      this.onObjectVisibility.dispatch(this, viewObject);
    }
  }
  /**
   * @private
   */;
  _proto.objectXRayedUpdated = function objectXRayedUpdated(viewObject, xrayed, notify) {
    if (notify === void 0) {
      notify = true;
    }
    if (xrayed) {
      this.xrayedObjects[viewObject.id] = viewObject;
      _classPrivateFieldLooseBase(this, _numXRayedObjects)[_numXRayedObjects]++;
    } else {
      delete this.xrayedObjects[viewObject.id];
      _classPrivateFieldLooseBase(this, _numXRayedObjects)[_numXRayedObjects]--;
    }
    _classPrivateFieldLooseBase(this, _xrayedObjectIds)[_xrayedObjectIds] = null; // Lazy regenerate
    if (notify) {
      this.onObjectXRayed.dispatch(this, viewObject);
    }
  }
  /**
   * @private
   */;
  _proto.objectHighlightedUpdated = function objectHighlightedUpdated(viewObject, highlighted) {
    if (highlighted) {
      this.highlightedObjects[viewObject.id] = viewObject;
      _classPrivateFieldLooseBase(this, _numHighlightedObjects)[_numHighlightedObjects]++;
    } else {
      delete this.highlightedObjects[viewObject.id];
      _classPrivateFieldLooseBase(this, _numHighlightedObjects)[_numHighlightedObjects]--;
    }
    _classPrivateFieldLooseBase(this, _highlightedObjectIds)[_highlightedObjectIds] = null; // Lazy regenerate
  }
  /**
   * @private
   */;
  _proto.objectSelectedUpdated = function objectSelectedUpdated(viewObject, selected) {
    if (selected) {
      this.selectedObjects[viewObject.id] = viewObject;
      _classPrivateFieldLooseBase(this, _numSelectedObjects)[_numSelectedObjects]++;
    } else {
      delete this.selectedObjects[viewObject.id];
      _classPrivateFieldLooseBase(this, _numSelectedObjects)[_numSelectedObjects]--;
    }
    _classPrivateFieldLooseBase(this, _selectedObjectIds)[_selectedObjectIds] = null; // Lazy regenerate
  }
  /**
   * @private
   */;
  _proto.objectColorizeUpdated = function objectColorizeUpdated(viewObject, colorized) {
    if (colorized) {
      this.colorizedObjects[viewObject.id] = viewObject;
      _classPrivateFieldLooseBase(this, _numColorizedObjects)[_numColorizedObjects]++;
    } else {
      delete this.colorizedObjects[viewObject.id];
      _classPrivateFieldLooseBase(this, _numColorizedObjects)[_numColorizedObjects]--;
    }
    _classPrivateFieldLooseBase(this, _colorizedObjectIds)[_colorizedObjectIds] = null; // Lazy regenerate
  }
  /**
   * @private
   */;
  _proto.objectOpacityUpdated = function objectOpacityUpdated(viewObject, opacityUpdated) {
    if (opacityUpdated) {
      this.opacityObjects[viewObject.id] = viewObject;
      _classPrivateFieldLooseBase(this, _numOpacityObjects)[_numOpacityObjects]++;
    } else {
      delete this.opacityObjects[viewObject.id];
      _classPrivateFieldLooseBase(this, _numOpacityObjects)[_numOpacityObjects]--;
    }
    _classPrivateFieldLooseBase(this, _opacityObjectIds)[_opacityObjectIds] = null; // Lazy regenerate
  }
  /**
   * Creates a {@link SectionPlane} in this View.
   *
   * @param sectionPlaneParams
   */;
  _proto.createSectionPlane = function createSectionPlane(sectionPlaneParams) {
    var _this3 = this;
    var id = sectionPlaneParams.id || createUUID();
    if (this.sectionPlanes[id]) {
      this.error("SectionPlane with ID \"" + id + "\" already exists - will randomly-generate ID");
      id = createUUID();
    }
    var sectionPlane = new SectionPlane(this, sectionPlaneParams);
    _classPrivateFieldLooseBase(this, _registerSectionPlane)[_registerSectionPlane](sectionPlane);
    sectionPlane.onDestroyed.one(function () {
      _classPrivateFieldLooseBase(_this3, _deregisterSectionPlane)[_deregisterSectionPlane](sectionPlane);
    });
    return sectionPlane;
  }
  /**
   * Destroys the {@link SectionPlane}s in this View.
   */;
  _proto.clearSectionPlanes = function clearSectionPlanes() {
    var objectIds = Object.keys(this.sectionPlanes);
    for (var i = 0, len = objectIds.length; i < len; i++) {
      this.sectionPlanes[objectIds[i]].destroy();
    }
    this.sectionPlanesList.length = 0;
    _classPrivateFieldLooseBase(this, _sectionPlanesHash)[_sectionPlanesHash] = null;
  }
  /**
   * @private
   */;
  _proto.getSectionPlanesHash = function getSectionPlanesHash() {
    if (_classPrivateFieldLooseBase(this, _sectionPlanesHash)[_sectionPlanesHash]) {
      return _classPrivateFieldLooseBase(this, _sectionPlanesHash)[_sectionPlanesHash];
    }
    if (this.sectionPlanesList.length === 0) {
      return _classPrivateFieldLooseBase(this, _sectionPlanesHash)[_sectionPlanesHash] = ";";
    }
    var hashParts = [];
    for (var i = 0, len = this.sectionPlanesList.length; i < len; i++) {
      hashParts.push("cp");
    }
    hashParts.push(";");
    _classPrivateFieldLooseBase(this, _sectionPlanesHash)[_sectionPlanesHash] = hashParts.join("");
    return _classPrivateFieldLooseBase(this, _sectionPlanesHash)[_sectionPlanesHash];
  }
  /**
   * @private
   */;
  _proto.registerLight = function registerLight(light) {
    this.lightsList.push(light);
    this.lights[light.id] = light;
    _classPrivateFieldLooseBase(this, _lightsHash)[_lightsHash] = null;
    this.rebuild();
  }
  /**
   * @private
   */;
  _proto.deregisterLight = function deregisterLight(light) {
    for (var i = 0, len = this.lightsList.length; i < len; i++) {
      if (this.lightsList[i].id === light.id) {
        this.lightsList.splice(i, 1);
        _classPrivateFieldLooseBase(this, _lightsHash)[_lightsHash] = null;
        delete this.lights[light.id];
        this.rebuild();
        return;
      }
    }
  }
  /**
   * Destroys the light sources in this View.
   */;
  _proto.clearLights = function clearLights() {
    var objectIds = Object.keys(this.lights);
    for (var i = 0, len = objectIds.length; i < len; i++) {
      this.lights[objectIds[i]].destroy();
    }
  }
  /**
   * @private
   */;
  _proto.getLightsHash = function getLightsHash() {
    if (_classPrivateFieldLooseBase(this, _lightsHash)[_lightsHash]) {
      return _classPrivateFieldLooseBase(this, _lightsHash)[_lightsHash];
    }
    if (this.lightsList.length === 0) {
      return _classPrivateFieldLooseBase(this, _lightsHash)[_lightsHash] = ";";
    }
    var hashParts = [];
    var lights = this.lightsList;
    for (var i = 0, len = lights.length; i < len; i++) {
      var light = lights[i];
      hashParts.push("/");
      hashParts.push(light.type);
      hashParts.push(light.space === "world" ? "w" : "v");
      if (light.castsShadow) {
        hashParts.push("sh");
      }
    }
    // if (this.lightMaps.length > 0) {
    //     hashParts.push("/lm");
    // }
    // if (this.reflectionMaps.length > 0) {
    //     hashParts.push("/rm");
    // }
    hashParts.push(";");
    _classPrivateFieldLooseBase(this, _lightsHash)[_lightsHash] = hashParts.join("");
    return _classPrivateFieldLooseBase(this, _lightsHash)[_lightsHash];
  }
  //createLight(lightParams) {
  //
  // }
  /**
   * @private
   */;
  _proto.rebuild = function rebuild() {
    this.viewer.renderer.needsRebuild(this.viewIndex);
  }
  /**
   * @private
   */;
  _proto.redraw = function redraw() {
    this.viewer.renderer.setImageDirty(this.viewIndex);
  }
  /**
   * @private
   */;
  _proto.getAmbientColorAndIntensity = function getAmbientColorAndIntensity() {
    return [0, 0, 0, 1];
  }
  /**
   * Updates the visibility of the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
   *
   * - Updates {@link @xeokit/viewer!ViewObject.visible} on the Objects with the given IDs.
   * - Updates {@link View.visibleObjects} and {@link View.numVisibleObjects}.
   *
   * @param {String[]} objectIds Array of {@link @xeokit/viewer!ViewObject.id} values.
   * @param visible Whether or not to cull.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsVisible = function setObjectsVisible(objectIds, visible) {
    return this.withObjects(objectIds, function (viewObject) {
      var changed = viewObject.visible !== visible;
      viewObject.visible = visible;
      return changed;
    });
  }
  /**
   * Updates the collidability of the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
   *
   * Updates {@link @xeokit/viewer!ViewObject.collidable} on the Objects with the given IDs.
   *
   * @param {String[]} objectIds Array of {@link @xeokit/viewer!ViewObject.id} values.
   * @param collidable Whether or not to cull.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsCollidable = function setObjectsCollidable(objectIds, collidable) {
    return this.withObjects(objectIds, function (viewObject) {
      var changed = viewObject.collidable !== collidable;
      viewObject.collidable = collidable;
      return changed;
    });
  }
  /**
   * Updates the culled status of the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
   *
   * Updates {@link @xeokit/viewer!ViewObject.culled} on the Objects with the given IDs.
   *
   * @param {String[]} objectIds Array of {@link @xeokit/viewer!ViewObject.id} values.
   * @param culled Whether or not to cull.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsCulled = function setObjectsCulled(objectIds, culled) {
    return this.withObjects(objectIds, function (viewObject) {
      var changed = viewObject.culled !== culled;
      viewObject.culled = culled;
      return changed;
    });
  }
  /**
   * Selects or deselects the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
   *
   * - Updates {@link @xeokit/viewer!ViewObject.selected} on the Objects with the given IDs.
   * - Updates {@link View.selectedObjects} and {@link View.numSelectedObjects}.
   *
   * @param  objectIds One or more {@link @xeokit/viewer!ViewObject.id} values.
   * @param selected Whether or not to select.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsSelected = function setObjectsSelected(objectIds, selected) {
    return this.withObjects(objectIds, function (viewObject) {
      var changed = viewObject.selected !== selected;
      viewObject.selected = selected;
      return changed;
    });
  }
  /**
   * Highlights or un-highlights the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
   *
   * - Updates {@link @xeokit/viewer!ViewObject.highlighted} on the Objects with the given IDs.
   * - Updates {@link View.highlightedObjects} and {@link View.numHighlightedObjects}.
   *
   * @param  objectIds One or more {@link @xeokit/viewer!ViewObject.id} values.
   * @param highlighted Whether or not to highlight.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsHighlighted = function setObjectsHighlighted(objectIds, highlighted) {
    return this.withObjects(objectIds, function (viewObject) {
      var changed = viewObject.highlighted !== highlighted;
      viewObject.highlighted = highlighted;
      return changed;
    });
  }
  /**
   * Applies or removes X-ray rendering for the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
   *
   * - Updates {@link @xeokit/viewer!ViewObject.xrayed} on the Objects with the given IDs.
   * - Updates {@link View.xrayedObjects} and {@link View.numXRayedObjects}.
   *
   * @param  objectIds One or more {@link @xeokit/viewer!ViewObject.id} values.
   * @param xrayed Whether or not to xray.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsXRayed = function setObjectsXRayed(objectIds, xrayed) {
    return this.withObjects(objectIds, function (viewObject) {
      var changed = viewObject.xrayed !== xrayed;
      if (changed) {
        viewObject.xrayed = xrayed;
      }
      return changed;
    });
  }
  /**
   * Colorizes the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
   *
   * - Updates {@link @xeokit/viewer!ViewObject.colorize} on the Objects with the given IDs.
   * - Updates {@link View.colorizedObjects} and {@link View.numColorizedObjects}.
   *
   * @param  objectIds One or more {@link @xeokit/viewer!ViewObject.id} values.
   * @param colorize - RGB colorize factors in range ````[0..1,0..1,0..1]````.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} changed opacity, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsColorized = function setObjectsColorized(objectIds, colorize) {
    return this.withObjects(objectIds, function (viewObject) {
      viewObject.colorize = colorize;
    });
  }
  /**
   * Sets the opacity of the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
   *
   * - Updates {@link @xeokit/viewer!ViewObject.opacity} on the Objects with the given IDs.
   * - Updates {@link View.opacityObjects} and {@link View.numOpacityObjects}.
   *
   * @param  objectIds - One or more {@link @xeokit/viewer!ViewObject.id} values.
   * @param opacity - Opacity factor in range ````[0..1]````.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} changed opacity, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsOpacity = function setObjectsOpacity(objectIds, opacity) {
    return this.withObjects(objectIds, function (viewObject) {
      var changed = viewObject.opacity !== opacity;
      if (changed) {
        viewObject.opacity = opacity;
      }
      return changed;
    });
  }
  /**
   * Sets the pickability of the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
   *
   * - Updates {@link @xeokit/viewer!ViewObject.pickable} on the Objects with the given IDs.
   * - Enables or disables the ability to pick the given Objects with {@link View.pick}.
   *
   * @param {String[]} objectIds Array of {@link @xeokit/viewer!ViewObject.id} values.
   * @param pickable Whether or not to set pickable.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsPickable = function setObjectsPickable(objectIds, pickable) {
    return this.withObjects(objectIds, function (viewObject) {
      var changed = viewObject.pickable !== pickable;
      if (changed) {
        viewObject.pickable = pickable;
      }
      return changed;
    });
  }
  /**
   * Sets the clippability of the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
   *
   * - Updates {@link @xeokit/viewer!ViewObject.clippable} on the Objects with the given IDs.
   * - Enables or disables the ability to clip the given Objects with {@link SectionPlane}.
   *
   * @param {String[]} objectIds Array of {@link @xeokit/viewer!ViewObject.id} values.
   * @param clippable Whether or not to set clippable.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */;
  _proto.setObjectsClippable = function setObjectsClippable(objectIds, clippable) {
    return this.withObjects(objectIds, function (viewObject) {
      var changed = viewObject.clippable !== clippable;
      if (changed) {
        viewObject.clippable = clippable;
      }
      return changed;
    });
  }
  /**
   * Iterates with a callback over the given {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
   *
   * @param objectIds One or more {@link @xeokit/viewer!ViewObject.id} values.
   * @param callback Callback to execute on each {@link @xeokit/viewer!ViewObject}.
   * @returns True if any {@link @xeokit/viewer!ViewObject | ViewObjects} were updated, else false if all updates were redundant and not applied.
   */;
  _proto.withObjects = function withObjects(objectIds, callback) {
    var changed = false;
    for (var i = 0, len = objectIds.length; i < len; i++) {
      var id = objectIds[i];
      var viewObject = this.objects[id];
      if (viewObject) {
        changed = callback(viewObject) || changed;
      }
    }
    return changed;
  }
  /**
   * Creates a {@link @xeokit/viewer!ViewLayer} in this View.
   *
   * The ViewLayer is then registered in {@link View.layers}.
   *
   * Since the ViewLayer is created explicitly by this method, the ViewLayer will persist until {@link @xeokit/view!ViewLayer.destroy}
   * is called, or the {@link @xeokit/viewer!View} itself is destroyed. If a ViewLayer with the given ID already exists, then the method
   * returns that existing ViewLayer. The method will also ensure that the existing ViewLayer likewise persists.
   *
   * @param viewLayerParams
   * @returns The new ViewLayer
   */;
  _proto.createLayer = function createLayer(viewLayerParams) {
    var _this4 = this;
    var viewLayer = this.layers[viewLayerParams.id];
    if (!viewLayer) {
      viewLayer = new ViewLayer({
        // Automatically creates ViewObjects
        id: viewLayerParams.id,
        view: this,
        viewer: this.viewer
      });
      this.layers[viewLayerParams.id] = viewLayer;
      this.onLayerCreated.dispatch(this, viewLayer);
      viewLayer.onDestroyed.one(function () {
        delete _this4.layers[viewLayer.id];
        _this4.onLayerDestroyed.dispatch(_this4, viewLayer);
      });
    }
    viewLayer.autoDestroy = false;
    return viewLayer;
  }
  /**
   * Attempts to pick a {@link ViewObject} in this View.
   *
   * @param pickParams
   * @param pickResult
   */;
  _proto.pick = function pick(pickParams, pickResult) {
    return null;
  }
  /**
   * Captures a snapshot image of this View.
   *
   * @param snapshotParams
   * @param snapshotResult
   */;
  _proto.getSnapshot = function getSnapshot(snapshotParams, snapshotResult) {
    return new SnapshotResult();
  };
  /**
   * Destroys this View.
   *
   * Causes {@link @xeokit/viewer!Viewer} to fire a "viewDestroyed" event.
   */
  _proto.destroy = function destroy() {
    this.viewer.onTick.unsubscribe(_classPrivateFieldLooseBase(this, _onTick$4)[_onTick$4]);
    _Component.prototype.destroy.call(this);
    this.onObjectVisibility.clear();
    this.onObjectXRayed.clear();
    this.onLayerCreated.clear();
    this.onLayerDestroyed.clear();
    this.onSectionPlaneCreated.clear();
    this.onSectionPlaneDestroyed.clear();
  };
  _createClass(View, [{
    key: "renderMode",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _renderMode)[_renderMode];
    }
    /**
     *
     */
  }, {
    key: "aabb",
    get: function get() {
      return this.viewer.scene.aabb;
    }
    /**
     * Gets the canvas clear color.
     *
     * Default value is ````[1, 1, 1]````.
     */
  }, {
    key: "backgroundColor",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _backgroundColor)[_backgroundColor];
    }
    /**
     * Sets the canvas clear color.
     *
     * Default value is ````[1, 1, 1]````.
     */,
    set: function set(value) {
      if (value) {
        _classPrivateFieldLooseBase(this, _backgroundColor)[_backgroundColor][0] = value[0];
        _classPrivateFieldLooseBase(this, _backgroundColor)[_backgroundColor][1] = value[1];
        _classPrivateFieldLooseBase(this, _backgroundColor)[_backgroundColor][2] = value[2];
      } else {
        _classPrivateFieldLooseBase(this, _backgroundColor)[_backgroundColor][0] = 1.0;
        _classPrivateFieldLooseBase(this, _backgroundColor)[_backgroundColor][1] = 1.0;
        _classPrivateFieldLooseBase(this, _backgroundColor)[_backgroundColor][2] = 1.0;
      }
      this.redraw();
    }
    /**
     * Gets whether the canvas clear color will be derived from {@link AmbientLight} or {@link View#backgroundColor}
     * when {@link View#transparent} is ```true```.
     *
     * When {@link View#transparent} is ```true``` and this is ````true````, then the canvas clear color will
     * be taken from the ambient light color.
     *
     * When {@link View#transparent} is ```true``` and this is ````false````, then the canvas clear color will
     * be taken from {@link View#backgroundColor}.
     *
     * Default value is ````true````.
     */
  }, {
    key: "backgroundColorFromAmbientLight",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _backgroundColorFromAmbientLight)[_backgroundColorFromAmbientLight];
    }
    /**
     * Sets if the canvas background color is derived from an {@link AmbientLight}.
     *
     * This only has effect when the canvas is not transparent. When not enabled, the background color
     * will be the canvas element's HTML/CSS background color.
     *
     * Default value is ````true````.
     */,
    set: function set(backgroundColorFromAmbientLight) {
      _classPrivateFieldLooseBase(this, _backgroundColorFromAmbientLight)[_backgroundColorFromAmbientLight] = backgroundColorFromAmbientLight !== false;
    }
    /**
     * Gets the gamma factor.
     */
  }, {
    key: "gammaFactor",
    get: function get() {
      // TODO
      return 1.0;
    }
    /**
     * Gets whether quality rendering is enabled for this View.
     *
     * Default is ````false````.
     */
  }, {
    key: "qualityRender",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _qualityRender)[_qualityRender];
    }
    /**
     * Sets whether quality rendering is enabled for this View.
     *
     * Default is ````false````.
     */,
    set: function set(value) {
      if (_classPrivateFieldLooseBase(this, _qualityRender)[_qualityRender] === value) {
        return;
      }
      _classPrivateFieldLooseBase(this, _qualityRender)[_qualityRender] = value;
      this.redraw();
    }
    /**
     * Gets the number of {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     */
  }, {
    key: "numObjects",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _numObjects)[_numObjects];
    }
    /**
     * Gets the IDs of the {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     */
  }, {
    key: "objectIds",
    get: function get() {
      if (!_classPrivateFieldLooseBase(this, _objectIds)[_objectIds]) {
        _classPrivateFieldLooseBase(this, _objectIds)[_objectIds] = Object.keys(this.objects);
      }
      return _classPrivateFieldLooseBase(this, _objectIds)[_objectIds];
    }
    /**
     * Gets the number of visible {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     */
  }, {
    key: "numVisibleObjects",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _numVisibleObjects)[_numVisibleObjects];
    }
    /**
     * Gets the IDs of the visible {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     */
  }, {
    key: "visibleObjectIds",
    get: function get() {
      if (!_classPrivateFieldLooseBase(this, _visibleObjectIds)[_visibleObjectIds]) {
        _classPrivateFieldLooseBase(this, _visibleObjectIds)[_visibleObjectIds] = Object.keys(this.visibleObjects);
      }
      return _classPrivateFieldLooseBase(this, _visibleObjectIds)[_visibleObjectIds];
    }
    /**
     * Gets the number of X-rayed {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     */
  }, {
    key: "numXRayedObjects",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _numXRayedObjects)[_numXRayedObjects];
    }
    /**
     * Gets the IDs of the X-rayed {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     */
  }, {
    key: "xrayedObjectIds",
    get: function get() {
      if (!_classPrivateFieldLooseBase(this, _xrayedObjectIds)[_xrayedObjectIds]) {
        _classPrivateFieldLooseBase(this, _xrayedObjectIds)[_xrayedObjectIds] = Object.keys(this.xrayedObjects);
      }
      return _classPrivateFieldLooseBase(this, _xrayedObjectIds)[_xrayedObjectIds];
    }
    /**
     * Gets the number of highlighted {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     */
  }, {
    key: "numHighlightedObjects",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _numHighlightedObjects)[_numHighlightedObjects];
    }
    /**
     * Gets the IDs of the highlighted {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     */
  }, {
    key: "highlightedObjectIds",
    get: function get() {
      if (!_classPrivateFieldLooseBase(this, _highlightedObjectIds)[_highlightedObjectIds]) {
        _classPrivateFieldLooseBase(this, _highlightedObjectIds)[_highlightedObjectIds] = Object.keys(this.highlightedObjects);
      }
      return _classPrivateFieldLooseBase(this, _highlightedObjectIds)[_highlightedObjectIds];
    }
    /**
     * Gets the number of selected {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     */
  }, {
    key: "numSelectedObjects",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _numSelectedObjects)[_numSelectedObjects];
    }
    /**
     * Gets the IDs of the selected {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     */
  }, {
    key: "selectedObjectIds",
    get: function get() {
      if (!_classPrivateFieldLooseBase(this, _selectedObjectIds)[_selectedObjectIds]) {
        _classPrivateFieldLooseBase(this, _selectedObjectIds)[_selectedObjectIds] = Object.keys(this.selectedObjects);
      }
      return _classPrivateFieldLooseBase(this, _selectedObjectIds)[_selectedObjectIds];
    }
    /**
     * Gets the number of colorized {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     */
  }, {
    key: "numColorizedObjects",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _numColorizedObjects)[_numColorizedObjects];
    }
    /**
     * Gets the IDs of the colorized {@link @xeokit/viewer!ViewObject | ViewObjects} in this View.
     */
  }, {
    key: "colorizedObjectIds",
    get: function get() {
      if (!_classPrivateFieldLooseBase(this, _colorizedObjectIds)[_colorizedObjectIds]) {
        _classPrivateFieldLooseBase(this, _colorizedObjectIds)[_colorizedObjectIds] = Object.keys(this.colorizedObjects);
      }
      return _classPrivateFieldLooseBase(this, _colorizedObjectIds)[_colorizedObjectIds];
    }
    /**
     * Gets the IDs of the {@link @xeokit/viewer!ViewObject | ViewObjects} in this View that have updated opacities.
     */
  }, {
    key: "opacityObjectIds",
    get: function get() {
      if (!_classPrivateFieldLooseBase(this, _opacityObjectIds)[_opacityObjectIds]) {
        _classPrivateFieldLooseBase(this, _opacityObjectIds)[_opacityObjectIds] = Object.keys(this.opacityObjects);
      }
      return _classPrivateFieldLooseBase(this, _opacityObjectIds)[_opacityObjectIds];
    }
    /**
     * Gets the number of {@link @xeokit/viewer!ViewObject | ViewObjects} in this View that have updated opacities.
     */
  }, {
    key: "numOpacityObjects",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _numOpacityObjects)[_numOpacityObjects];
    }
  }]);
  return View;
}(Component);
function _createViewObjectsForSceneModel2(sceneModel) {
  var _this5 = this;
  // The Renderer has a RendererViewObject for each object, through which a ViewObject can
  // push state changes into the Renderer for its object.
  // The RendererViewObject
  var sceneObjects = sceneModel.objects;
  var rendererViewObjects = this.viewer.renderer.rendererViewObjects;
  var _loop = function _loop() {
    var sceneObject = sceneObjects[id];
    var rendererViewObject = rendererViewObjects[id];
    //     const layerId = viewerObject.layerId || "default";
    var layerId = "default";
    var viewLayer = _this5.layers[layerId];
    if (!viewLayer) {
      if (!_this5.autoLayers) {
        return "continue";
      }
      viewLayer = new ViewLayer({
        id: layerId,
        view: _this5,
        viewer: _this5.viewer
      });
      _this5.layers[layerId] = viewLayer;
      viewLayer.onDestroyed.one(function () {
        delete _this5.layers[viewLayer.id];
        _this5.onLayerDestroyed.dispatch(_this5, viewLayer);
      });
      _this5.onLayerCreated.dispatch(_this5, viewLayer);
    }
    var viewObject = new ViewObject(viewLayer, sceneObject, rendererViewObject);
    viewLayer.registerViewObject(viewObject);
    _this5.registerViewObject(viewObject);
  };
  for (var id in sceneObjects) {
    var _ret = _loop();
    if (_ret === "continue") continue;
  }
}
function _registerSectionPlane2(sectionPlane) {
  this.sectionPlanesList.push(sectionPlane);
  this.sectionPlanes[sectionPlane.id] = sectionPlane;
  _classPrivateFieldLooseBase(this, _sectionPlanesHash)[_sectionPlanesHash] = null;
  this.rebuild();
  this.onSectionPlaneCreated.dispatch(this, sectionPlane);
}
function _deregisterSectionPlane2(sectionPlane) {
  for (var i = 0, len = this.sectionPlanesList.length; i < len; i++) {
    if (this.sectionPlanesList[i].id === sectionPlane.id) {
      this.sectionPlanesList.splice(i, 1);
      _classPrivateFieldLooseBase(this, _sectionPlanesHash)[_sectionPlanesHash] = null;
      delete this.sectionPlanes[sectionPlane.id];
      this.rebuild();
      this.onSectionPlaneDestroyed.dispatch(this, sectionPlane);
      return;
    }
  }
}
function _destroyViewObjectsForSceneModel2(sceneModel) {
  var objects = sceneModel.objects;
  for (var id in objects) {
    var object = objects[id];
    //     const layerId = object.layerId || "main";
    var layerId = "default";
    var viewLayer = this.layers[layerId];
    var viewObject = this.objects[object.id];
    this.deregisterViewObject(viewObject);
    if (viewLayer) {
      viewLayer.deregisterViewObject(viewObject);
      if (viewLayer.autoDestroy && viewLayer.numObjects === 0) {
        viewLayer.destroy();
      }
    }
  }
}

/**
 * A Browser-based 2D/3D model viewer.
 *
 * See {@link @xeokit/viewer} for usage.
 */
var _prefixMessageWithID = /*#__PURE__*/_classPrivateFieldLooseKey("prefixMessageWithID");
var _registerView = /*#__PURE__*/_classPrivateFieldLooseKey("registerView");
var _deregisterView = /*#__PURE__*/_classPrivateFieldLooseKey("deregisterView");
var Viewer = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Viewer, _Component);
  /**
   Creates a Viewer.
    @param params - Viewer configuration.
   @param params.scene - Contains model representations.
   @param params.renderer - Manages rendering of models.
   @param params.id - ID for this Viewer, automatically generated by default.
   @param params.units - The measurement unit type. Accepted values are ````"meters"````, ````"metres"````, , ````"centimeters"````, ````"centimetres"````, ````"millimeters"````,  ````"millimetres"````, ````"yards"````, ````"feet"```` and ````"inches"````.
   @param params.scale - The number of Real-space units in each World-space coordinate system unit.
   @param params.origin - The Real-space 3D origin, in current measurement units, at which the World-space coordinate origin ````[0,0,0]```` sits.
   @param params.localeService - Locale-based translation service.
    */
  function Viewer(params) {
    var _this;
    _this = _Component.call(this, null, {}) || this;
    Object.defineProperty(_assertThisInitialized(_this), _deregisterView, {
      value: _deregisterView2
    });
    Object.defineProperty(_assertThisInitialized(_this), _registerView, {
      value: _registerView2
    });
    Object.defineProperty(_assertThisInitialized(_this), _prefixMessageWithID, {
      value: _prefixMessageWithID2
    });
    /**
     * Indicates the capabilities of this Viewer.
     */
    _this.capabilities = void 0;
    /**
     * Emits an event each time a message is logged.
     *
     * @event
     */
    _this.onLog = void 0;
    /**
     * Emits an event each time a Viewer "tick" occurs (~10-60 times per second).
     *
     * @event
     */
    _this.onTick = void 0;
    /**
     * Emits an event each time a {@link @xeokit/viewer!View} is created.
     *
     * @event
     */
    _this.onViewCreated = void 0;
    /**
     * Emits an event each time a {@link @xeokit/viewer!View} is destroyed.
     *
     * @event
     */
    _this.onViewDestroyed = void 0;
    /**
     * The Viewer's scene representation.
     */
    _this.scene = void 0;
    /**
     * Map of all the Views in this Viewer.
     *
     * Each {@link @xeokit/viewer!View} is an independently configurable view of the Viewer's models, with its own canvas, camera position, section planes, lights, and object visual states.
     */
    _this.views = void 0;
    /**
     * List of all the Views in this Viewer.
     *
     * Each {@link @xeokit/viewer!View} is an independently configurable view of the Viewer's models, with its own canvas, camera position, section planes, lights, and object visual states.
     */
    _this.viewList = void 0;
    /**
     *  The number of {@link View | Views} belonging to this Viewer.
     */
    _this.numViews = void 0;
    /**
     The time that this Viewer was created.
     */
    _this.startTime = new Date().getTime();
    /**
     * @private
     */
    _this.renderer = void 0;
    _this.onLog = new EventEmitter(new dist.EventDispatcher());
    _this.onTick = new EventEmitter(new dist.EventDispatcher());
    _this.onViewCreated = new EventEmitter(new dist.EventDispatcher());
    _this.onViewDestroyed = new EventEmitter(new dist.EventDispatcher());
    _this.id = params.id || createUUID();
    _this.viewList = [];
    _this.numViews = 0;
    _this.views = {};
    _this.destroyed = false;
    _this.capabilities = {
      maxViews: 1,
      headless: false,
      astcSupported: false,
      etc1Supported: false,
      etc2Supported: false,
      dxtSupported: false,
      bptcSupported: false,
      pvrtcSupported: false
    };
    _this.scene = params.scene || new Scene();
    _this.renderer = params.renderer;
    _this.renderer.getCapabilities(_this.capabilities);
    _this.renderer.attachViewer(_assertThisInitialized(_this));
    scheduler.registerViewer(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * Creates a new {@link @xeokit/viewer!View} within this Viewer.
   *
   * * The maximum number of views you're allowed to create is provided in {@link Capabilities.maxViews}. This
   * will be determined by the {@link Renderer} implementation the Viewer is configured with.
   * * To destroy the View after use, call {@link View.destroy}.
   * * You must add a View to the Viewer before you can create or load content into the Viewer's Viewer.
   *
   * ### Usage
   *
   * ````javascript
   * const view1 = myViewer.createView({
   *      id: "myView",
   *      canvasId: "myView1"
   *  });
   *
   * if (view1 instanceof SDKError) {
   *      console.log(view1.message);
   * } else {
   *      view1.camera.eye = [-3.933, 2.855, 27.018];
   *      view1.camera.look = [4.400, 3.724, 8.899];
   *      view1.camera.up = [-0.018, 0.999, 0.039];
   *
   *      //...
   * }
   * ````
   *
   * @param params View configuration.
   * @returns *{@link View}*
   * * On success.
   * @returns *{@link @xeokit/core!SDKError}*
   * * If View already exists with the given ID.
   * * Attempted to create too many Views - see {@link Capabilities.maxViews | Capabilities.maxViews}.
   */
  var _proto = Viewer.prototype;
  _proto.createView = function createView(params) {
    var _this2 = this;
    if (this.viewList.length >= this.capabilities.maxViews) {
      return new SDKError("Attempted to create too many Views with View.createView() - maximum of " + this.capabilities.maxViews + " is allowed");
    }
    var viewId = params.id || createUUID();
    if (this.views[viewId]) {
      return new SDKError("View with ID \"" + viewId + "\" already exists");
    }
    // @ts-ignore
    var canvasElement = params.canvasElement || document.getElementById(params.canvasId);
    if (!(canvasElement instanceof HTMLCanvasElement)) {
      return new SDKError("Mandatory View config expected: valid canvasId or canvasElement");
    }
    var view = new View(apply({
      viewId: viewId,
      viewer: this
    }, params));
    _classPrivateFieldLooseBase(this, _registerView)[_registerView](view);
    // Renderer.attachView sets up internal Renderer resources
    // that are expected by Renderer.attachSceneModel
    {
      var result = this.renderer.attachView(view);
      if (result instanceof SDKError) {
        return result;
      } else {
        view.viewIndex = result;
      }
    }
    view.onDestroyed.one(function () {
      _classPrivateFieldLooseBase(_this2, _deregisterView)[_deregisterView](view);
      _this2.renderer.detachView(view.viewIndex);
      _this2.onViewDestroyed.dispatch(_this2, view);
    });
    // Renderer.attachSceneModel creates RendererViewObjects in Renderer.rendererViewObjects,
    // which are then expected by View.initViewObjects
    // TODO: assumes one View
    this.scene.onModelCreated.subscribe(function (scene, sceneModel) {
      _this2.renderer.attachSceneModel(sceneModel);
    });
    this.scene.onModelDestroyed.subscribe(function (scene, sceneModel) {
      _this2.renderer.detachSceneModel(sceneModel);
    });
    for (var id in this.scene.models) {
      this.renderer.attachSceneModel(this.scene.models[id]);
    }
    view.initViewObjects();
    this.onViewCreated.dispatch(this, view);
    this.log("View created: " + view.viewId);
    return view;
  }
  /**
   * Trigger redraw of all {@link View | Views} belonging to this Viewer.
   *
   * @private
   */;
  _proto.redraw = function redraw() {
    for (var viewId in this.views) {
      this.views[viewId].redraw();
    }
  }
  /**
   * Logs a console debugging message for this Viewer.
   *
   * The console message will have this format: *````[LOG] [<component type> <component id>: <message>````*
   *
   * @private
   * @param message - The message to log
   */;
  _proto.log = function log(message) {
    message = "[LOG] " + _classPrivateFieldLooseBase(this, _prefixMessageWithID)[_prefixMessageWithID](message);
    window.console.log(message);
  }
  /**
   * Logs a warning for this Viewer to the JavaScript console.
   *
   * The console message will have this format: *````[WARN] [<component type> =<component id>: <message>````*
   *
   * @private
   * @param message - The warning message to log
   */;
  _proto.warn = function warn(message) {
    message = "[WARN] " + _classPrivateFieldLooseBase(this, _prefixMessageWithID)[_prefixMessageWithID](message);
    window.console.warn(message);
  }
  /**
   * Logs an error for this Viewer to the JavaScript console.
   *
   * The console message will have this format: *````[ERROR] [<component type> =<component id>: <message>````*
   *
   * @private
   * @param message The error message to log
   */;
  _proto.error = function error(message) {
    message = "[ERROR] " + _classPrivateFieldLooseBase(this, _prefixMessageWithID)[_prefixMessageWithID](message);
    window.console.error(message);
  }
  /**
   * Destroys this Viewer and all {@link View | Views} and {@link Plugin}s we've created within it.
   */;
  _proto.destroy = function destroy() {
    if (this.destroyed) {
      return;
    }
    scheduler.deregisterViewer(this);
    for (var id in this.views) {
      this.views[id].destroy();
    }
    this.onTick.clear();
    this.onViewCreated.clear();
    this.onViewDestroyed.clear();
  }
  /**
   * @private
   * @param params
   */;
  _proto.render = function render(params) {
    for (var viewIndex = 0; viewIndex < this.viewList.length; viewIndex++) {
      this.renderer.render(viewIndex, {
        force: true
      });
    }
  };
  return Viewer;
}(Component);
function _prefixMessageWithID2(message) {
  return " [" + this.constructor.name + " \"" + inQuotes(this.id) + "\"]: " + message;
}
function _registerView2(view) {
  if (this.views[view.id]) {
    return;
  }
  this.views[view.id] = view;
  for (var viewIndex = 0;; viewIndex++) {
    if (!this.viewList[viewIndex]) {
      this.viewList[viewIndex] = view;
      this.numViews++;
      view.viewIndex = viewIndex;
      return;
    }
  }
}
function _deregisterView2(view) {
  if (!this.views[view.id]) {
    return;
  }
  delete this.views[view.id];
  delete this.viewList[view.viewIndex];
  this.numViews--;
}

/**
 * An ambient light source within a {@link @xeokit/viewer!View}.
 *
 * ## Summary
 *
 * * Has fixed color and intensity that illuminates all objects equally.
 * * {@link AmbientLight}s, {@link DirLight}s and {@link PointLight}s are registered by their {@link Component.id} on {@link View.lights}.
 */
var _state$2 = /*#__PURE__*/_classPrivateFieldLooseKey("state");
var AmbientLight = /*#__PURE__*/function (_Component) {
  _inheritsLoose(AmbientLight, _Component);
  /**
   * @param view Owner component. When destroyed, the owner will destroy this AmbientLight as well.
   * @param cfg AmbientLight configuration
   */
  function AmbientLight(view, cfg) {
    var _this;
    if (cfg === void 0) {
      cfg = {};
    }
    _this = _Component.call(this, view, cfg) || this;
    /**
     * The View to which this AmbientLight belongs.
     */
    _this.view = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _state$2, {
      writable: true,
      value: void 0
    });
    _this.view = view;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _state$2)[_state$2] = {
      type: "ambient",
      color: new Float32Array(cfg.color || [0.7, 0.7, 0.7]),
      intensity: cfg.intensity !== undefined && cfg.intensity !== null ? cfg.intensity : 1.0
    };
    _this.view.registerLight(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * Sets the RGB color of this AmbientLight.
   *
   * Default value is ````[0.7, 0.7, 0.7]````.
   *
   * @param color The AmbientLight's RGB color.
   */
  var _proto = AmbientLight.prototype;
  /**
   * Destroys this AmbientLight.
   */
  _proto.destroy = function destroy() {
    _Component.prototype.destroy.call(this);
    this.view.deregisterLight(this);
  };
  _createClass(AmbientLight, [{
    key: "color",
    get:
    /**
     * Gets the RGB color of this AmbientLight.
     *
     * Default value is ````[0.7, 0.7, 0.7]````.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$2)[_state$2].color;
    }
    /**
     * Sets the intensity of this AmbientLight.
     *
     * Default value is ````1.0```` for maximum intensity.
     *
     * @param intensity The AmbientLight's intensity.
     */,
    set: function set(color) {
      _classPrivateFieldLooseBase(this, _state$2)[_state$2].color.set(color);
      this.view.redraw();
    }
  }, {
    key: "intensity",
    get:
    /**
     * Gets the intensity of this AmbientLight.
     *
     * Default value is ````1.0```` for maximum intensity.
     *
     * @returns {Number} The AmbientLight's intensity.
     */
    function get() {
      return _classPrivateFieldLooseBase(this, _state$2)[_state$2].intensity;
    },
    set: function set(intensity) {
      _classPrivateFieldLooseBase(this, _state$2)[_state$2].intensity = intensity !== undefined ? intensity : 1.0;
      this.view.redraw();
    }
  }]);
  return AmbientLight;
}(Component);

/**
 * A directional light source within a {@link @xeokit/viewer!View}.
 *
 * ## Summary
 *
 * * Illuminates all objects equally from a given direction.
 * * Has an emission direction vector in {@link DirLight.dir}, but no position.
 * * Defined in either *World* or *View* coordinate space. When in World-space, {@link DirLight.dir} is relative to the
 * World coordinate system, and will appear to move as the {@link @xeokit/viewer!Camera}  moves. When in View-space, {@link DirLight.dir} is
 * relative to the View coordinate system, and will behave as if fixed to the viewer's head.
 * * {@link AmbientLight}s, {@link DirLight}s and {@link PointLight}s are registered by their {@link Component.id} on {@link View.lights}.
 */
var _state$1 = /*#__PURE__*/_classPrivateFieldLooseKey("state");
var DirLight = /*#__PURE__*/function (_Component) {
  _inheritsLoose(DirLight, _Component);
  /**
   * @param view View that owns this DirLight. When destroyed, the View will destroy this DirLight as well.
   * @param options The DirLight configuration
   * @param [options.id] Optional ID, unique among all components in the parent {@link @xeokit/scene!Scene}, generated automatically when omitted.
   * @param [options.dir=[1.0, 1.0, 1.0]]  A unit vector indicating the direction that the light is shining,  given in either World or View space, depending on the value of the ````space```` parameter.
   * @param [options.color=[0.7, 0.7, 0.8 ]] The color of this DirLight.
   * @param [options.intensity=1.0] The intensity of this DirLight, as a factor in range ````[0..1]````.
   * @param [options.space="view"] The coordinate system the DirLight is defined in - ````"view"```` or ````"space"````.
   */
  function DirLight(view, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _Component.call(this, view, options) || this;
    /**
     * The View to which this DirLight belongs.
     */
    _this.view = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _state$1, {
      writable: true,
      value: void 0
    });
    _this.view = view;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _state$1)[_state$1] = {
      type: "dir",
      dir: new Float32Array(options.dir || [1.0, 1.0, 1.0]),
      color: new Float32Array(options.color || [0.7, 0.7, 0.8]),
      intensity: options.intensity !== undefined && options.intensity !== null ? options.intensity : 1.0,
      space: options.space || "view"
    };
    _this.view.registerLight(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * Gets the direction in which the DirLight is shining.
   *
   * Default value is ````[1.0, 1.0, 1.0]````.
   *
   * @returns {Number[]} The direction vector.
   */
  var _proto = DirLight.prototype;
  /**
   * Destroys this DirLight.
   */
  _proto.destroy = function destroy() {
    _Component.prototype.destroy.call(this);
    this.view.deregisterLight(this);
    this.view.redraw();
  };
  _createClass(DirLight, [{
    key: "dir",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$1)[_state$1].dir;
    }
    /**
     * Sets the direction in which the DirLight is shining.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @param value The direction vector.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _state$1)[_state$1].dir.set(value);
      this.view.redraw();
    }
    /**
     * Gets the RGB color of this DirLight.
     *
     * Default value is ````[0.7, 0.7, 0.8]````.
     *
     * @returns {Number[]} The DirLight's RGB color.
     */
  }, {
    key: "color",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$1)[_state$1].color;
    }
    /**
     * Sets the RGB color of this DirLight.
     *
     * Default value is ````[0.7, 0.7, 0.8]````.
     *
     * @param color The DirLight's RGB color.
     */,
    set: function set(color) {
      _classPrivateFieldLooseBase(this, _state$1)[_state$1].color.set(color);
      this.view.redraw();
    }
    /**
     * Gets the intensity of this DirLight.
     *
     * Default value is ````1.0```` for maximum intensity.
     *
     * @returns {Number} The DirLight's intensity.
     */
  }, {
    key: "intensity",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state$1)[_state$1].intensity;
    }
    /**
     * Sets the intensity of this DirLight.
     *
     * Default intensity is ````1.0```` for maximum intensity.
     *
     * @param intensity The DirLight's intensity
     */,
    set: function set(intensity) {
      _classPrivateFieldLooseBase(this, _state$1)[_state$1].intensity = intensity;
      this.view.redraw();
    }
  }]);
  return DirLight;
}(Component);

/**
 * A positional light source within a {@link @xeokit/viewer!View}.
 *
 * ## Summary
 *
 * * Originates from a single point and spreads outward in all directions, with optional attenuation over distance.
 * * Has a position in {@link PointLight.pos}, but no direction.
 * * Defined in either *World* or *View* coordinate space. When in World-space, {@link PointLight.pos} is relative to
 * the World coordinate system, and will appear to move as the {@link @xeokit/viewer!Camera}  moves. When in View-space,
 * {@link PointLight.pos} is relative to the View coordinate system, and will behave as if fixed to the viewer's head.
 * * Has {@link PointLight.constantAttenuation}, {@link PointLight.linearAttenuation} and {@link PointLight.quadraticAttenuation}
 * factors, which indicate how intensity attenuates over distance.
 * * {@link AmbientLight}s, {@link PointLight}s and {@link PointLight}s are registered by their {@link Component.id} on {@link View.lights}.
 */
var _state = /*#__PURE__*/_classPrivateFieldLooseKey("state");
var PointLight = /*#__PURE__*/function (_Component) {
  _inheritsLoose(PointLight, _Component);
  /**
   * @param view View that owns this PointLight. When destroyed, the View will destroy this PointLight as well.
   * @param cfg The PointLight configuration
   * @param [cfg.id] Optional ID, unique among all components in the parent {@link @xeokit/scene!Scene}, generated automatically when omitted.
   * @param [cfg.pos=[ 1.0, 1.0, 1.0 ]] Position, in either World or View space, depending on the value of the **space** parameter.
   * @param [cfg.color=[0.7, 0.7, 0.8 ]] Color of this PointLight.
   * @param [cfg.intensity=1.0] Intensity of this PointLight, as a factor in range ````[0..1]````.
   * @param [cfg.constantAttenuation=0] Constant attenuation factor.
   * @param [cfg.linearAttenuation=0] Linear attenuation factor.
   * @param [cfg.quadraticAttenuation=0] Quadratic attenuation factor.
   * @param [cfg.space="view"] The coordinate system this PointLight is defined in - "view" or "world".
   * @param [cfg.castsShadow=false] Flag which indicates if this PointLight casts a castsShadow.
   */
  function PointLight(view, cfg) {
    var _this;
    if (cfg === void 0) {
      cfg = {};
    }
    _this = _Component.call(this, view, cfg) || this;
    /**
     * The View to which this PointLight belongs.
     */
    _this.view = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _state, {
      writable: true,
      value: void 0
    });
    _this.view = view;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _state)[_state] = {
      type: "point",
      pos: new Float64Array(cfg.pos || [1.0, 1.0, 1.0]),
      color: new Float32Array(cfg.color || [0.7, 0.7, 0.8]),
      intensity: 1.0,
      // @ts-ignore
      attenuation: new Float32Array([cfg.constantAttenuation, cfg.linearAttenuation, cfg.quadraticAttenuation]),
      space: cfg.space || "view"
    };
    _this.view.registerLight(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * Gets the position of this PointLight.
   *
   * This will be either World- or View-space, depending on the value of {@link PointLight.space}.
   *
   * Default value is ````[1.0, 1.0, 1.0]````.
   *
   * @returns {Number[]} The position.
   */
  var _proto = PointLight.prototype;
  /**
   * Destroys this PointLight.
   */
  _proto.destroy = function destroy() {
    _Component.prototype.destroy.call(this);
    this.view.deregisterLight(this);
    this.view.redraw();
  };
  _createClass(PointLight, [{
    key: "pos",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state)[_state].pos;
    }
    /**
     * Sets the position of this PointLight.
     *
     * This will be either World- or View-space, depending on the value of {@link PointLight.space}.
     *
     * Default value is ````[1.0, 1.0, 1.0]````.
     *
     * @param pos The position.
     */,
    set: function set(pos) {
      _classPrivateFieldLooseBase(this, _state)[_state].pos.set(pos || [1.0, 1.0, 1.0]);
      this.view.redraw();
    }
    /**
     * Gets the RGB color of this PointLight.
     *
     * Default value is ````[0.7, 0.7, 0.8]````.
     *
     * @returns {Number[]} The PointLight's RGB color.
     */
  }, {
    key: "color",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state)[_state].color;
    }
    /**
     * Sets the RGB color of this PointLight.
     *
     * Default value is ````[0.7, 0.7, 0.8]````.
     *
     * @param color The PointLight's RGB color.
     */,
    set: function set(color) {
      _classPrivateFieldLooseBase(this, _state)[_state].color.set(color || [0.7, 0.7, 0.8]);
      this.view.redraw();
    }
    /**
     * Gets the intensity of this PointLight.
     *
     * Default value is ````1.0```` for maximum intensity.
     *
     * @returns {Number} The PointLight's intensity.
     */
  }, {
    key: "intensity",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state)[_state].intensity;
    }
    /**
     * Sets the intensity of this PointLight.
     *
     * Default intensity is ````1.0```` for maximum intensity.
     *
     * @param intensity The PointLight's intensity
     */,
    set: function set(intensity) {
      if (intensity === _classPrivateFieldLooseBase(this, _state)[_state].intensity) {
        return;
      }
      _classPrivateFieldLooseBase(this, _state)[_state].intensity = intensity;
      this.view.redraw();
    }
    /**
     * Gets the constant attenuation factor for this PointLight.
     *
     * Default value is ````0````.
     *
     * @returns {Number} The constant attenuation factor.
     */
  }, {
    key: "constantAttenuation",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state)[_state].attenuation[0];
    }
    /**
     * Sets the constant attenuation factor for this PointLight.
     *
     * Default value is ````0````.
     *
     * @param value The constant attenuation factor.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _state)[_state].attenuation[0] = value;
      this.view.redraw();
    }
    /**
     * Gets the linear attenuation factor for this PointLight.
     *
     * Default value is ````0````.
     *
     * @returns {Number} The linear attenuation factor.
     */
  }, {
    key: "linearAttenuation",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state)[_state].attenuation[1];
    }
    /**
     * Sets the linear attenuation factor for this PointLight.
     *
     * Default value is ````0````.
     *
     * @param value The linear attenuation factor.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _state)[_state].attenuation[1] = value;
      this.view.redraw();
    }
    /**
     * Gets the quadratic attenuation factor for this PointLight.
     *
     * Default value is ````0````.
     *
     * @returns {Number} The quadratic attenuation factor.
     */
  }, {
    key: "quadraticAttenuation",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _state)[_state].attenuation[2];
    }
    /**
     * Sets the quadratic attenuation factor for this PointLight.
     *
     * Default value is ````0````.
     *
     * @param value The quadratic attenuation factor.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _state)[_state].attenuation[2] = value;
      this.view.redraw();
    }
  }]);
  return PointLight;
}(Component);

var _viewObject = /*#__PURE__*/_classPrivateFieldLooseKey("viewObject");
var _gotCanvasPos = /*#__PURE__*/_classPrivateFieldLooseKey("gotCanvasPos");
var _gotSnappedCanvasPos = /*#__PURE__*/_classPrivateFieldLooseKey("gotSnappedCanvasPos");
var _gotOrigin = /*#__PURE__*/_classPrivateFieldLooseKey("gotOrigin");
var _gotDirection = /*#__PURE__*/_classPrivateFieldLooseKey("gotDirection");
var _gotIndices = /*#__PURE__*/_classPrivateFieldLooseKey("gotIndices");
var _gotLocalPos = /*#__PURE__*/_classPrivateFieldLooseKey("gotLocalPos");
var _gotWorldPos = /*#__PURE__*/_classPrivateFieldLooseKey("gotWorldPos");
var _gotViewPos = /*#__PURE__*/_classPrivateFieldLooseKey("gotViewPos");
var _gotWorldNormal = /*#__PURE__*/_classPrivateFieldLooseKey("gotWorldNormal");
var _gotUV = /*#__PURE__*/_classPrivateFieldLooseKey("gotUV");
var _snappedToVertex = /*#__PURE__*/_classPrivateFieldLooseKey("snappedToVertex");
var _snappedToEdge = /*#__PURE__*/_classPrivateFieldLooseKey("snappedToEdge");
var _canvasPos = /*#__PURE__*/_classPrivateFieldLooseKey("canvasPos");
var _snappedCanvasPos = /*#__PURE__*/_classPrivateFieldLooseKey("snappedCanvasPos");
var _origin = /*#__PURE__*/_classPrivateFieldLooseKey("origin");
var _direction = /*#__PURE__*/_classPrivateFieldLooseKey("direction");
var _indices = /*#__PURE__*/_classPrivateFieldLooseKey("indices");
var _localPos = /*#__PURE__*/_classPrivateFieldLooseKey("localPos");
var _worldPos = /*#__PURE__*/_classPrivateFieldLooseKey("worldPos");
var _viewPos = /*#__PURE__*/_classPrivateFieldLooseKey("viewPos");
var _worldNormal = /*#__PURE__*/_classPrivateFieldLooseKey("worldNormal");
var _uv = /*#__PURE__*/_classPrivateFieldLooseKey("uv");
/**
 * Results of a pick attempted with {@link View.pick}.
 */
var PickResult = /*#__PURE__*/function () {
  function PickResult() {
    Object.defineProperty(this, _viewObject, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _gotCanvasPos, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _gotSnappedCanvasPos, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _gotOrigin, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _gotDirection, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _gotIndices, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _gotLocalPos, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _gotWorldPos, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _gotViewPos, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _gotWorldNormal, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _gotUV, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _snappedToVertex, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _snappedToEdge, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _canvasPos, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _snappedCanvasPos, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _origin, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _direction, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _indices, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _localPos, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _worldPos, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _viewPos, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _worldNormal, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _uv, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _viewObject)[_viewObject] = null;
    _classPrivateFieldLooseBase(this, _canvasPos)[_canvasPos] = new Int16Array([0, 0]);
    _classPrivateFieldLooseBase(this, _origin)[_origin] = new Float64Array([0, 0, 0]);
    _classPrivateFieldLooseBase(this, _direction)[_direction] = new Float64Array([0, 0, 0]);
    _classPrivateFieldLooseBase(this, _indices)[_indices] = new Int32Array(3);
    _classPrivateFieldLooseBase(this, _localPos)[_localPos] = new Float64Array([0, 0, 0]);
    _classPrivateFieldLooseBase(this, _worldPos)[_worldPos] = new Float64Array([0, 0, 0]);
    _classPrivateFieldLooseBase(this, _viewPos)[_viewPos] = new Float64Array([0, 0, 0]);
    _classPrivateFieldLooseBase(this, _worldNormal)[_worldNormal] = new Float64Array([0, 0, 0]);
    _classPrivateFieldLooseBase(this, _uv)[_uv] = new Float64Array([0, 0]);
    _classPrivateFieldLooseBase(this, _gotOrigin)[_gotOrigin] = false;
    _classPrivateFieldLooseBase(this, _gotDirection)[_gotDirection] = false;
    _classPrivateFieldLooseBase(this, _gotIndices)[_gotIndices] = false;
    _classPrivateFieldLooseBase(this, _gotCanvasPos)[_gotCanvasPos] = false;
    _classPrivateFieldLooseBase(this, _gotSnappedCanvasPos)[_gotSnappedCanvasPos] = false;
    _classPrivateFieldLooseBase(this, _gotLocalPos)[_gotLocalPos] = false;
    _classPrivateFieldLooseBase(this, _gotWorldPos)[_gotWorldPos] = false;
    _classPrivateFieldLooseBase(this, _gotViewPos)[_gotViewPos] = false;
    _classPrivateFieldLooseBase(this, _gotWorldNormal)[_gotWorldNormal] = false;
    _classPrivateFieldLooseBase(this, _gotUV)[_gotUV] = false;
    _classPrivateFieldLooseBase(this, _snappedToVertex)[_snappedToVertex] = false;
    _classPrivateFieldLooseBase(this, _snappedToEdge)[_snappedToEdge] = false;
    this.reset();
  }
  /**
   * The picked {@link @xeokit/viewer!ViewObject}.
   */
  var _proto = PickResult.prototype;
  /**
   * @private
   */
  _proto.reset = function reset() {
    _classPrivateFieldLooseBase(this, _viewObject)[_viewObject] = null;
    _classPrivateFieldLooseBase(this, _gotCanvasPos)[_gotCanvasPos] = false;
    _classPrivateFieldLooseBase(this, _gotSnappedCanvasPos)[_gotSnappedCanvasPos] = false;
    _classPrivateFieldLooseBase(this, _gotOrigin)[_gotOrigin] = false;
    _classPrivateFieldLooseBase(this, _gotDirection)[_gotDirection] = false;
    _classPrivateFieldLooseBase(this, _gotIndices)[_gotIndices] = false;
    _classPrivateFieldLooseBase(this, _gotLocalPos)[_gotLocalPos] = false;
    _classPrivateFieldLooseBase(this, _gotWorldPos)[_gotWorldPos] = false;
    _classPrivateFieldLooseBase(this, _gotViewPos)[_gotViewPos] = false;
    _classPrivateFieldLooseBase(this, _gotWorldNormal)[_gotWorldNormal] = false;
    _classPrivateFieldLooseBase(this, _gotUV)[_gotUV] = false;
    _classPrivateFieldLooseBase(this, _snappedToVertex)[_snappedToVertex] = false;
    _classPrivateFieldLooseBase(this, _snappedToEdge)[_snappedToEdge] = false;
  };
  _createClass(PickResult, [{
    key: "viewObject",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _viewObject)[_viewObject];
    }
    /**
     * @private
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _viewObject)[_viewObject] = value;
    }
    /**
     * Canvas coordinates when picking with a 2D pointer.
     */
  }, {
    key: "canvasPos",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _gotCanvasPos)[_gotCanvasPos] ? _classPrivateFieldLooseBase(this, _canvasPos)[_canvasPos] : undefined;
    }
    /**
     * @private
     */,
    set: function set(value) {
      if (value) {
        _classPrivateFieldLooseBase(this, _canvasPos)[_canvasPos][0] = value[0];
        _classPrivateFieldLooseBase(this, _canvasPos)[_canvasPos][1] = value[1];
        _classPrivateFieldLooseBase(this, _gotCanvasPos)[_gotCanvasPos] = true;
      } else {
        _classPrivateFieldLooseBase(this, _gotCanvasPos)[_gotCanvasPos] = false;
      }
    }
    /**
     * World-space 3D ray origin when raypicked.
     */
  }, {
    key: "origin",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _gotOrigin)[_gotOrigin] ? _classPrivateFieldLooseBase(this, _origin)[_origin] : null;
    }
    /**
     * @private
     */,
    set: function set(value) {
      if (value) {
        _classPrivateFieldLooseBase(this, _origin)[_origin][0] = value[0];
        _classPrivateFieldLooseBase(this, _origin)[_origin][1] = value[1];
        _classPrivateFieldLooseBase(this, _origin)[_origin][2] = value[2];
        _classPrivateFieldLooseBase(this, _gotOrigin)[_gotOrigin] = true;
      } else {
        _classPrivateFieldLooseBase(this, _gotOrigin)[_gotOrigin] = false;
      }
    }
    /**
     * World-space 3D ray direction when raypicked.
     */
  }, {
    key: "direction",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _gotDirection)[_gotDirection] ? _classPrivateFieldLooseBase(this, _direction)[_direction] : null;
    }
    /**
     * @private
     */,
    set: function set(value) {
      if (value) {
        _classPrivateFieldLooseBase(this, _direction)[_direction][0] = value[0];
        _classPrivateFieldLooseBase(this, _direction)[_direction][1] = value[1];
        _classPrivateFieldLooseBase(this, _direction)[_direction][2] = value[2];
        _classPrivateFieldLooseBase(this, _gotDirection)[_gotDirection] = true;
      } else {
        _classPrivateFieldLooseBase(this, _gotDirection)[_gotDirection] = false;
      }
    }
    /**
     * Picked triangle's vertex indices.
     * Only defined when an object and triangle was picked.
     */
  }, {
    key: "indices",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _viewObject)[_viewObject] !== null && _classPrivateFieldLooseBase(this, _gotIndices)[_gotIndices] ? _classPrivateFieldLooseBase(this, _indices)[_indices] : null;
    }
    /**
     * @private
     */,
    set: function set(value) {
      if (value) {
        _classPrivateFieldLooseBase(this, _indices)[_indices][0] = value[0];
        _classPrivateFieldLooseBase(this, _indices)[_indices][1] = value[1];
        _classPrivateFieldLooseBase(this, _indices)[_indices][2] = value[2];
        _classPrivateFieldLooseBase(this, _gotIndices)[_gotIndices] = true;
      } else {
        _classPrivateFieldLooseBase(this, _gotIndices)[_gotIndices] = false;
      }
    }
    /**
     * Picked Local-space point on surface.
     * Only defined when an object and a point on its surface was picked.
     */
  }, {
    key: "localPos",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _viewObject)[_viewObject] !== null && _classPrivateFieldLooseBase(this, _gotLocalPos)[_gotLocalPos] ? _classPrivateFieldLooseBase(this, _localPos)[_localPos] : null;
    }
    /**
     * @private
     */,
    set: function set(value) {
      if (value) {
        _classPrivateFieldLooseBase(this, _localPos)[_localPos][0] = value[0];
        _classPrivateFieldLooseBase(this, _localPos)[_localPos][1] = value[1];
        _classPrivateFieldLooseBase(this, _localPos)[_localPos][2] = value[2];
        _classPrivateFieldLooseBase(this, _gotLocalPos)[_gotLocalPos] = true;
      } else {
        _classPrivateFieldLooseBase(this, _gotLocalPos)[_gotLocalPos] = false;
      }
    }
    /**
     * Picked World-space point on surface.
     * Only defined when an object and a point on its surface was picked.
     */
  }, {
    key: "worldPos",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _viewObject)[_viewObject] && _classPrivateFieldLooseBase(this, _gotWorldPos)[_gotWorldPos] ? _classPrivateFieldLooseBase(this, _worldPos)[_worldPos] : null;
    }
    /**
     * @private
     */,
    set: function set(value) {
      if (value) {
        _classPrivateFieldLooseBase(this, _worldPos)[_worldPos][0] = value[0];
        _classPrivateFieldLooseBase(this, _worldPos)[_worldPos][1] = value[1];
        _classPrivateFieldLooseBase(this, _worldPos)[_worldPos][2] = value[2];
        _classPrivateFieldLooseBase(this, _gotWorldPos)[_gotWorldPos] = true;
      } else {
        _classPrivateFieldLooseBase(this, _gotWorldPos)[_gotWorldPos] = false;
      }
    }
    /**
     * Picked View-space point on surface.
     * Only defined when an object and a point on its surface was picked.
     */
  }, {
    key: "viewPos",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _viewObject)[_viewObject] && _classPrivateFieldLooseBase(this, _gotViewPos)[_gotViewPos] ? _classPrivateFieldLooseBase(this, _viewPos)[_viewPos] : null;
    }
    /**
     * @private
     */,
    set: function set(value) {
      if (value) {
        _classPrivateFieldLooseBase(this, _viewPos)[_viewPos][0] = value[0];
        _classPrivateFieldLooseBase(this, _viewPos)[_viewPos][1] = value[1];
        _classPrivateFieldLooseBase(this, _viewPos)[_viewPos][2] = value[2];
        _classPrivateFieldLooseBase(this, _gotViewPos)[_gotViewPos] = true;
      } else {
        _classPrivateFieldLooseBase(this, _gotViewPos)[_gotViewPos] = false;
      }
    }
    /**
     * Normal vector at picked position on surface.
     * Only defined when an object and a point on its surface was picked.
     */
  }, {
    key: "worldNormal",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _viewObject)[_viewObject] !== null && _classPrivateFieldLooseBase(this, _gotWorldNormal)[_gotWorldNormal] ? _classPrivateFieldLooseBase(this, _worldNormal)[_worldNormal] : null;
    }
    /**
     * @private
     */,
    set: function set(value) {
      if (value) {
        _classPrivateFieldLooseBase(this, _worldNormal)[_worldNormal][0] = value[0];
        _classPrivateFieldLooseBase(this, _worldNormal)[_worldNormal][1] = value[1];
        _classPrivateFieldLooseBase(this, _worldNormal)[_worldNormal][2] = value[2];
        _classPrivateFieldLooseBase(this, _gotWorldNormal)[_gotWorldNormal] = true;
      } else {
        _classPrivateFieldLooseBase(this, _gotWorldNormal)[_gotWorldNormal] = false;
      }
    }
    /**
     * UV coordinates at picked position on surface.
     * Only defined when an object and a point on its surface was picked.
     */
  }, {
    key: "uv",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _viewObject)[_viewObject] !== null && _classPrivateFieldLooseBase(this, _gotUV)[_gotUV] ? _classPrivateFieldLooseBase(this, _uv)[_uv] : null;
    }
    /**
     * @private
     */,
    set: function set(value) {
      if (value) {
        _classPrivateFieldLooseBase(this, _uv)[_uv][0] = value[0];
        _classPrivateFieldLooseBase(this, _uv)[_uv][1] = value[1];
        _classPrivateFieldLooseBase(this, _gotUV)[_gotUV] = true;
      } else {
        _classPrivateFieldLooseBase(this, _gotUV)[_gotUV] = false;
      }
    }
    /**
     * Returns `true` if picking has snapped to the canvas coordinates of the nearest vertex.
     * When this is `true`, then {@link PickResult.snappedCanvasPos} will contain the canvas coordinates of the nearest position on teh nearest vertex.
     */
  }, {
    key: "snappedToVertex",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _viewObject)[_viewObject] !== null && _classPrivateFieldLooseBase(this, _snappedToVertex)[_snappedToVertex];
    }
    /**
     * @private
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _snappedToVertex)[_snappedToVertex] = value;
    }
    /**
     * Returns `true` if picking has snapped to the canvas coordinates of the nearest edge.
     * When this is `true`, then {@link PickResult.snappedCanvasPos} will contain the canvas coordinates of the nearest position on teh nearest edge.
     */
  }, {
    key: "snappedToEdge",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _viewObject)[_viewObject] !== null && _classPrivateFieldLooseBase(this, _snappedToEdge)[_snappedToEdge];
    },
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _snappedToEdge)[_snappedToEdge] = value;
    }
    /**
     * Snapped canvas coordinates when picking with a 2D pointer.
     * This has a value when {@link PickResult.snappedToEdge} or {@link PickResult.snappedToVertex} is `true`, otherwise will be `null`.
     */
  }, {
    key: "snappedCanvasPos",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _gotSnappedCanvasPos)[_gotSnappedCanvasPos] ? _classPrivateFieldLooseBase(this, _snappedCanvasPos)[_snappedCanvasPos] : undefined;
    }
    /**
     * @private
     */,
    set: function set(value) {
      if (value) {
        _classPrivateFieldLooseBase(this, _snappedCanvasPos)[_snappedCanvasPos][0] = value[0];
        _classPrivateFieldLooseBase(this, _snappedCanvasPos)[_snappedCanvasPos][1] = value[1];
        _classPrivateFieldLooseBase(this, _gotSnappedCanvasPos)[_gotSnappedCanvasPos] = true;
      } else {
        _classPrivateFieldLooseBase(this, _gotSnappedCanvasPos)[_gotSnappedCanvasPos] = false;
      }
    }
  }]);
  return PickResult;
}();

/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2Fviewer.svg)](https://badge.fury.io/js/%40xeokit%2Fviewer)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/viewer/badge)](https://www.jsdelivr.com/package/npm/@xeokit/viewer)
 *
 * <img style="padding:0px; padding-top:20px; padding-bottom:30px;" src="media://images/xeokit_viewer_logo.png"/>
 *
 * # xeokit Scene Viewer
 *
 * ---
 *
 * ### *The SDK's browser-based 3D/2D scene viewer*
 *
 * ---
 *
 * ## Features
 *
 * * Use a {@link @xeokit/viewer!Viewer} to interactively view a {@link @xeokit/scene!Scene} in all major browsers, including mobile.
 * * A Viewer has a {@link @xeokit/viewer!Renderer}, which is a pluggable strategy that adapts the Viewer to use various browser graphics APIs. Currently we have two
 * Renderer implementations:
 * {@link @xeokit/webglrenderer!WebGLRenderer} and WebGPURenderer.
 * * A Viewer can have multiple {@link @xeokit/viewer!View | Views}, each providing an independently configurable view of the Scene in a separate HTML canvas.
 * * Each View has a {@link @xeokit/viewer!ViewObject} for each of the {@link @xeokit/scene!SceneObject | SceneObjects} in the Scene, which represnts and controls that
 * SceneObject's appearance in the View's canvas.
 * The View creates and destroys its ViewObjects automatically, in order to proxy the SceneObjects.
 * * Each View also has it's own {@link @xeokit/viewer!Camera}, {@link @xeokit/viewer!DirLight | Lights} and {@link @xeokit/viewer!SectionPlane | SectionPlanes}.
 * * Each View can optionally organize its ViewObjects into {@link @xeokit/viewer!ViewLayer | ViewLayers}. These allow us to partition our ViewObjects into
 * different *bins* depending on what they represent in the View, and then conveniently focus our updates (toggle visibility, select, highlight, slice etc.)
 * eon certain bins, exclusively. ViewLayers also allow us to restrict which SceneObjects are renderable in the Viewer's [phycially-based](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#pbr)
 * quality rendering mode. This allows us to disable wasteful quality rendering for objects that are not supposed to appear realistic, such as grids and other 3D helper objects.
 *
 * <br>
 *
 * [![](https://mermaid.ink/img/pako:eNqNVU1v4jAQ_SuRT7srQKRAgKjiQqXdA6iI7oe0ysVJpsWtY2cdhy2l_Pd1_JEmkK7KJWbemzdj541zRAlPAYUoobgobgh-EDiLWEoEJJJw5q22EdOY95PAXxDeMWKe-QlgKQgQJlAkwMAs94pZmGUiAEuoUj99NpGInZqKTi_BbI9tEo8fVXWngDMQ2Kwpedi5eGEa3FDMwIYoPoBoFV5VEVfZhO4aeW1kValXoVaDWsJ1SdKODv-UmBJ52OrjOMu-1cTz9D0pSEzBbYQqClhop5rQ23SBZ6EasOuEUy7Ii01MKMlzXOvkJHl6-4dxHDd6WepTdH3AATx7ZJw_mVWZWxnBH80RNdKbh-ZEcl54VkXZpfleb4jQZ-mYFeyoegstF2ytjTT7-hrHhRQ4kYtFg_ML4q-rFrG5t7KQPNvUfbuyGZaCPDd3UVm0RpXvaafhtBnWFVz7gwIWLWdoKc35rzWMljGBE4tLQlP3JwW1W3641L40jsIjZoYwQn6E-v2Ffm7rMewA78xUmkcNfLGAKfIurPdnUbN-V-G8tMKrUGivgmp9AZrcsD6wt5imtLZgucosuYACmCw8wrxv39er-uborKGnN3QXQx2J0HAw-EA7rbNc2pvoopDze-jupwtGc34iZoWa2hvVX16R9t34rZA73omcuz9i9Zxcv_b7Z6MTeiTLKWTVCXYxNz8-RF3z5OkdYvO-WXKm3F2PiP4waCO34NbL8M3LQD2kGBkmqfo26fQIyZ2qEaFQLVO4xyVVPlFqiopLye8OLEHhPaYF9FCZp2ru7OesjkJKJBdr-8GrHj2UY4bCI3pGoT-dD4JgOJv644nvj-ejWQ8dUDgKZoPRfDjxx1fB_Go6np166IVzpTocTILJVGGjSTAMRrPxSMv91qAUJZz-AZsUb1U?type=png)](https://mermaid.live/edit#pako:eNqNVU1v4jAQ_SuRT7srQKRAgKjiQqXdA6iI7oe0ysVJpsWtY2cdhy2l_Pd1_JEmkK7KJWbemzdj541zRAlPAYUoobgobgh-EDiLWEoEJJJw5q22EdOY95PAXxDeMWKe-QlgKQgQJlAkwMAs94pZmGUiAEuoUj99NpGInZqKTi_BbI9tEo8fVXWngDMQ2Kwpedi5eGEa3FDMwIYoPoBoFV5VEVfZhO4aeW1kValXoVaDWsJ1SdKODv-UmBJ52OrjOMu-1cTz9D0pSEzBbYQqClhop5rQ23SBZ6EasOuEUy7Ii01MKMlzXOvkJHl6-4dxHDd6WepTdH3AATx7ZJw_mVWZWxnBH80RNdKbh-ZEcl54VkXZpfleb4jQZ-mYFeyoegstF2ytjTT7-hrHhRQ4kYtFg_ML4q-rFrG5t7KQPNvUfbuyGZaCPDd3UVm0RpXvaafhtBnWFVz7gwIWLWdoKc35rzWMljGBE4tLQlP3JwW1W3641L40jsIjZoYwQn6E-v2Ffm7rMewA78xUmkcNfLGAKfIurPdnUbN-V-G8tMKrUGivgmp9AZrcsD6wt5imtLZgucosuYACmCw8wrxv39er-uborKGnN3QXQx2J0HAw-EA7rbNc2pvoopDze-jupwtGc34iZoWa2hvVX16R9t34rZA73omcuz9i9Zxcv_b7Z6MTeiTLKWTVCXYxNz8-RF3z5OkdYvO-WXKm3F2PiP4waCO34NbL8M3LQD2kGBkmqfo26fQIyZ2qEaFQLVO4xyVVPlFqiopLye8OLEHhPaYF9FCZp2ru7OesjkJKJBdr-8GrHj2UY4bCI3pGoT-dD4JgOJv644nvj-ejWQ8dUDgKZoPRfDjxx1fB_Go6np166IVzpTocTILJVGGjSTAMRrPxSMv91qAUJZz-AZsUb1U)
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/viewer
 * ````
 *
 * ## Usage
 *
 * * [Creating a Viewer](#creating-a-viewer)
 * * [Creating a View](#creating-a-view)
 * * [Adding a CameraControl](#adding-a-cameracontrol)
 * * [Creating a SceneModel](#creating-a-scene)
 * * [Showing and Hiding Objects](#showing-and-hiding-objects)
 * * [Highlighting, Selecting and X-Raying Objects](#highlighting-selecting-and-x-raying-objects)
 * * [Creating a Second View](#creating-a-second-view)
 * * [Slicing Objects](#slicing-objects)
 * * [Adding a ViewLayer](#adding-a-viewlayer)
 *
 * ### Creating a Viewer
 *
 * Install these NPM modules:
 *
 * ````bash
 * npm install @xeokit/scene
 * npm install @xeokit/viewer
 * npm install @xeokit/ktx2
 * npm install @xeokit/webglrenderer
 * npm install @xeokit/constants
 * npm install @xeokit/cameracontrol
 * ````
 *
 *  In our JavaScript, import the modules:
 *
 * ````javascript
 * import {Scene} from "@xeokit/scene";
 * import {Viewer} from "@xeokit/viewer";
 * import {WebGLRenderer} from "@xeokit/webglrenderer";
 * import {KTX2TextureTranscoder} from "@xeokit/ktx2";
 * import {TrianglesPrimitive, LinearEncoding, LinearFilter} from "@xeokit/constants";
 * import {CameraControl} from "@xeokit/cameracontrol";
 * ````
 *
 * Create a {@link @xeokit/scene!Scene} to hold our scene graph:
 *
 * ````javascript
 * const scene = new Scene();
 * ````
 *
 * Create a {@link @xeokit/viewer!Viewer} to view our Scene.
 *
 * We'll configured it with
 * a {@link @xeokit/webglrenderer!WebGLRenderer}, which will adapt the Viewer to use the browser's WebGL graphics API.
 * We'll also equip our WebGLRenderer with a {@link @xeokit/ktx2!KTX2TextureTranscoder} so we that we can view compressed textures.
 *
 * ````javascript
 * const myViewer = new Viewer({
 *     id: "myViewer",
 *     scene,
 *     renderer: new WebGLRenderer({
 *          textureTranscoder: new KTX2TextureTranscoder({  // Optional, this is the default
 *              transcoderPath: "./../dist/basis/" // Optional, defaults to CDN
 *          })
 *      })
 * });
 * ````
 *
 * ### Creating a View
 *
 * Within our Viewer, create a {@link @xeokit/viewer!View} and arrange its {@link @xeokit/viewer!Camera}:
 *
 * ````javascript
 * const view1 = myViewer.createView({
 *     id: "myView",
 *     canvasId: "myView1"
 * });
 *
 * view1.camera.eye = [-3.933, 2.855, 27.018];
 * view1.camera.look = [4.400, 3.724, 8.899];
 * view1.camera.up = [-0.018, 0.999, 0.039];
 * ````
 *
 * ### Adding a CameraControl
 *
 * > *See [@xeokit/cameracontrol](/docs/modules/_xeokit_cameracontrol.html)*
 *
 * Add a {@link @xeokit/cameracontrol!CameraControl} to the View, to control the Camera from mouse and touch input:
 *
 * ````javascript
 * const myCameraControl = new CameraControl({
 *      view: view1
 * });
 * ````
 *
 * ### Creating a SceneModel
 *
 * > *See [@xeokit/scene](/docs/modules/_xeokit_scene.html)*
 *
 * Our {@link @xeokit/scene!Scene | Scene } contains geometric representations of our models and objects,
 * with materials and textures.
 *
 * Within the Scene, we'll create a {@link @xeokit/scene!SceneModel | SceneModel} that contains a couple
 * of textured {@link @xeokit/scene!SceneModel | SceneObjects}:
 *
 * ````javascript
 * const sceneModel = scene.createModel();
 *
 * sceneModel.createGeometry({
 *      id: "myGeometry",
 *      primitive: TrianglesPrimitive,
 *      positions: [202, 202, 202, 200, 202, 202, ...],
 *      indices: [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, ...]
 * });
 *
 * sceneModel.createTexture({
 *      id: "myColorTexture",
 *      src: "myTexture",
 *      encoding: LinearEncoding, // Demo some texture configs
 *      magFilter: LinearFilter,
 *      minFilter: LinearFilter
 * });
 *
 * sceneModel.createTextureSet({
 *      id: "myTextureSet",
 *      colorTextureId: "myColorTexture"
 * });
 *
 * sceneModel.createMesh({
 *     id: "myMesh1",
 *     geometryId: "myGeometry",
 *     textureSetId: "myTextureSet"
 * });
 *
 * sceneModel.createMesh({
 *     id: "myMesh2",
 *     geometryId: "myGeometry",
 *     textureSetId: "myTextureSet"
 * });
 *
 * sceneModel.createObject({
 *     id: "myObject1",
 *     meshIds: ["myMesh1"]
 * });
 *
 * sceneModel.createObject({
 *     id: "myObject2",
 *     meshIds: ["myMesh2"]
 * });
 *
 * sceneModel.build();
 * ````
 *
 * As soon as we've called {@link @xeokit/scene!SceneModel.build | SceneModel.build}, two new objects appear
 * in the View's canvas.
 *
 * ### Showing and Hiding Objects
 *
 * Hide one of the objects in the View's canvas:
 *
 * ````javascript
 * view1.setObjectsVisible(["myObject1"], false);
 * ````
 *
 * Another way to hide the object:
 *
 * ````javascript
 * view1.objects["myObject1"].visible = false;
 * ````
 *
 * Show the object again:
 *
 * ````javascript
 * view1.objects["myObject1"].visible = true;
 * ````
 *
 * ### Highlighting, Selecting and X-Raying Objects
 *
 * The functions for highlighting, selecting, colorizing and X-raying objects work the same as hiding and
 * showing, as just described.
 *
 * Let's highlight the first object in our View:
 *
 * ````javascript
 * view1.objects["myObject1"].highlighted = true;
 * ````
 *
 * ### Creating a Second View
 *
 * A Viewer can have many Views, each providing an independent view of the Scene in a separate
 * HTML canvas. Each View can have a completely different viewpoint, projection, and configuration of which objects
 * are visible, x-rayed, highlighted etc.
 *
 * Create a second View, with a separate canvas, that shows the other object highlighted instead:
 *
 * ```` javascript
 * const view2 = myViewer.createView({
 *      id: "myView2",
 *      canvasId: "myView2"
 * });
 *
 * view2.camera.eye = [-3.933, 2.855, 27.018];
 * view2.camera.look = [4.400, 3.724, 8.899];
 * view2.camera.up = [-0.018, 0.999, 0.039];
 *
 * view2.objects["myObject1"].highlighted = true;
 * ````
 *
 * To show an independent view of {@link @xeokit/scene!SceneModel | SceneObjects}, a View
 * proxies them with {@link @xeokit/viewer!ViewObject | ViewObjects}, which represent and control their appearance within the View's canvas.
 *
 * ### Slicing Objects
 *
 * Each View can have an unlimited number of interactive {@link SectionPlane | SectionPlanes}, with which we can use to slice open objects
 * to view interior structures.
 *
 * Create a couple of SectionPlanes within our second View, to slice through one of our
 * objects, then adjust the direction of one of the SectionPlanes:
 *
 * ````javascript
 * const mySlice1 = view2.createSlice({
 *     id: "mySlice1",
 *     pos: [0,0,0],
 *     dir: [-1,-1,-1]
 * });
 *
 * const mySlice2 = view2.createSlice({
 *     id: "mySlice2",
 *     pos: [0,0,0],
 *     dir: [1,1,.5]
 * });
 *
 * mySlice1.dir = [1,1,1];
 * ````
 *
 * ### Adding a ViewLayer
 *
 * Sometimes we want to create SceneModels whose objects will never be included in any BCF viewpoints that we save, and
 * will never be disturbed by any viewpoints that we load.
 *
 * An example of such a case is a skybox, which we'd never want included in any BCF viewpoints, or hidden
 * whenever we load a BCF viewpoint.
 *
 * TODO TODO TODO TODO
 *
 * ````javascript
 * const environmentViewLayer = view.createLayer({
 *     id: "myEnviromentViewLayer"
 * });
 * ````
 *
 * Now we'll create a SceneModel for our skybox in that ViewLayer:
 *
 * ````javascript
 * const skyboxSceneModel = myVScene.createModel({
 *      id: "mySkyBox",
 *      layerId: "myEnviromentViewLayer"
 * });
 *
 * skyboxSceneModel.createObject({
 *      id: "skyBox",
 *      //...
 * });
 *
 * skyboxSceneModel.build();
 * ````
 *
 * Now we can save that View as a BCF viewpoint that will never include our skybox objects:
 *
 * ````javascript
 * const bcfViewpointAgain = saveBCFViewpoint({
 *      view: view2,
 *      excludeLayerIds: ["myEnviromentViewLayer"]
 * });
 * ````
 *
 * We can also load that viewpoint back into our View, in a way that won't disrupt our skybox:
 *
 * ````javascript
 * loadBCFViewpoint({
 *      bcfViewpoint: bcfViewpointAgain
 *      view: view2,
 *      excludeLayerIds: ["myEnvironmentViewLayer"]
 * });
 * ````
 *
 * ````javascript
 * myViewer.viewModes.createViewMode({
 *    id: "qualityViewMode"
 * });
 *
 * myViewer.viewModes.createViewMode({
 *    id: "navigationViewMode"
 * });
 *
 * environmentViewLayer.setViewModes(["qualityViewMode"]};
 *
 * myViewer.viewModes.setActiveViewMode("quality");
 * ````
 *
 * @module @xeokit/viewer
 */

var index$5 = {
  __proto__: null,
  Viewer: Viewer,
  Camera: Camera,
  FrustumProjection: FrustumProjection,
  OrthoProjection: OrthoProjection,
  PerspectiveProjection: PerspectiveProjection,
  CustomProjection: CustomProjection,
  CameraFlightAnimation: CameraFlightAnimation,
  AmbientLight: AmbientLight,
  DirLight: DirLight,
  PointLight: PointLight,
  EmphasisMaterial: EmphasisMaterial,
  Edges: Edges,
  PointsMaterial: PointsMaterial,
  Metrics: Metrics,
  View: View,
  ViewLayer: ViewLayer,
  ViewObject: ViewObject,
  SectionPlane: SectionPlane,
  SAO: SAO,
  PickResult: PickResult
};

/**
 * Mock rendering strategy for a {@link @xeokit/scene!SceneObject | SceneObject}.
 *
 * See {@link @xeokit/mockrenderer} for usage.
 */
var MockRendererObject = /*#__PURE__*/function () {
  /**
   * @private
   */
  function MockRendererObject(params) {
    this.id = void 0;
    this.rendererModel = void 0;
    this.sceneObject = void 0;
    this.layerId = void 0;
    this.rendererMeshes = void 0;
    this.id = params.id;
    this.sceneObject = params.sceneObject;
    this.rendererModel = params.rendererModel;
    this.rendererMeshes = params.rendererMeshes;
    //  this.layerId = params.layerId;
  }
  /**
   * @inheritdoc
   */
  var _proto = MockRendererObject.prototype;
  /**
   * @inheritdoc
   */
  _proto.setVisible = function setVisible(viewIndex, visible) {}
  /**
   * @inheritdoc
   */;
  _proto.setHighlighted = function setHighlighted(viewIndex, highlighted) {}
  /**
   * @inheritdoc
   */;
  _proto.setXRayed = function setXRayed(viewIndex, xrayed) {}
  /**
   * @inheritdoc
   */;
  _proto.setSelected = function setSelected(viewIndex, selected) {}
  /**
   * @inheritdoc
   */;
  _proto.setEdges = function setEdges(viewIndex, edges) {}
  /**
   * @inheritdoc
   */;
  _proto.setCulled = function setCulled(viewIndex, culled) {}
  /**
   * @inheritdoc
   */;
  _proto.setClippable = function setClippable(viewIndex, clippable) {}
  /**
   * @inheritdoc
   */;
  _proto.setCollidable = function setCollidable(viewIndex, collidable) {}
  /**
   * @inheritdoc
   */;
  _proto.setPickable = function setPickable(viewIndex, pickable) {}
  /**
   * @inheritdoc
   */;
  _proto.setColorize = function setColorize(viewIndex, color) {}
  /**
   * @inheritdoc
   */;
  _proto.setOpacity = function setOpacity(viewIndex, opacity) {}
  /**
   * @inheritdoc
   */;
  _proto.setOffset = function setOffset(viewIndex, offset) {};
  _proto.destroy = function destroy() {
    for (var i = 0, len = this.rendererMeshes.length; i < len; i++) {
      this.rendererMeshes[i].destroy();
    }
  };
  _createClass(MockRendererObject, [{
    key: "aabb",
    get: function get() {
      return this.sceneObject.aabb;
    }
  }]);
  return MockRendererObject;
}();

/**
 * TODO
 *
 * @internal
 */
var MockRendererTexture = /*#__PURE__*/function () {
  function MockRendererTexture(texture) {
    this.texture = void 0;
    this.texture = texture;
  }
  var _proto = MockRendererTexture.prototype;
  _proto.destroy = function destroy() {};
  return MockRendererTexture;
}();

/**
 * @internal
 * @inheritdoc
 */
var MockRendererGeometry = function MockRendererGeometry() {};

/**
 * Mock rendering strategy for a {@link @xeokit/scene!Mesh | Mesh}.
 *
 * See {@link @xeokit/mockrenderer} for usage.
 */
var MockRendererMesh = /*#__PURE__*/function () {
  /**
   * @private
   */
  function MockRendererMesh(params) {}
  /**
   * @inheritdoc
   */
  var _proto = MockRendererMesh.prototype;
  _proto.delegatePickedEntity = function delegatePickedEntity() {
    throw new Error("Method not implemented.");
  }
  /**
   * @inheritdoc
   */;
  _proto.setMatrix = function setMatrix(matrix) {}
  /**
   * @inheritdoc
   */;
  _proto.setMetallic = function setMetallic(metallic) {}
  /**
   * @inheritdoc
   */;
  _proto.setRoughness = function setRoughness(roughness) {}
  /**
   * @inheritdoc
   */;
  _proto.setColor = function setColor(color) {}
  /**
   * @inheritdoc
   */;
  _proto.canPickTriangle = function canPickTriangle() {
    return false;
  }
  /**
   * @inheritdoc
   */;
  _proto.canPickWorldPos = function canPickWorldPos() {
    return false;
  }
  /**
   * @inheritdoc
   */;
  _proto.pickTriangleSurface = function pickTriangleSurface(pickResult) {}
  /**
   * @inheritdoc
   */;
  _proto.destroy = function destroy() {};
  return MockRendererMesh;
}();

/**
 * TODO
 *
 * @internal
 */
var MockRendererTextureSet = function MockRendererTextureSet(params) {
  this.id = void 0;
  this.colorRendererTexture = void 0;
  this.metallicRoughnessRendererTexture = void 0;
  this.emissiveRendererTexture = void 0;
  this.occlusionRendererTexture = void 0;
  this.id = params.id;
  this.colorRendererTexture = params.colorRendererTexture;
  this.metallicRoughnessRendererTexture = params.metallicRoughnessRendererTexture;
  this.emissiveRendererTexture = params.emissiveRendererTexture;
  this.occlusionRendererTexture = params.occlusionRendererTexture;
};

var defaultColorTextureId = "defaultColorTexture";
var defaultMetalRoughTextureId = "defaultMetalRoughTexture";
var defaultNormalsTextureId = "defaultNormalsTexture";
var defaultEmissiveTextureId = "defaultEmissiveTexture";
var defaultOcclusionTextureId = "defaultOcclusionTexture";
var defaultTextureSetId = "defaultTextureSet";
/**
 * Mock rendering strategy for a {@link @xeokit/scene!Mesh | Mesh}.
 *
 * See {@link @xeokit/mockrenderer} for usage.
 */
var _createDefaultTextureSet = /*#__PURE__*/_classPrivateFieldLooseKey("createDefaultTextureSet");
var _attachSceneModel = /*#__PURE__*/_classPrivateFieldLooseKey("attachSceneModel");
var _attachTexture = /*#__PURE__*/_classPrivateFieldLooseKey("attachTexture");
var _attachGeometry = /*#__PURE__*/_classPrivateFieldLooseKey("attachGeometry");
var _attachMesh = /*#__PURE__*/_classPrivateFieldLooseKey("attachMesh");
var _attachSceneObject = /*#__PURE__*/_classPrivateFieldLooseKey("attachSceneObject");
var MockRendererModel = /*#__PURE__*/function (_Component) {
  _inheritsLoose(MockRendererModel, _Component);
  /**
   * @private
   */
  function MockRendererModel(params) {
    var _this;
    _this = _Component.call(this, params.view) || this;
    Object.defineProperty(_assertThisInitialized(_this), _attachSceneObject, {
      value: _attachSceneObject2
    });
    Object.defineProperty(_assertThisInitialized(_this), _attachMesh, {
      value: _attachMesh2
    });
    Object.defineProperty(_assertThisInitialized(_this), _attachGeometry, {
      value: _attachGeometry2
    });
    Object.defineProperty(_assertThisInitialized(_this), _attachTexture, {
      value: _attachTexture2
    });
    Object.defineProperty(_assertThisInitialized(_this), _attachSceneModel, {
      value: _attachSceneModel2
    });
    Object.defineProperty(_assertThisInitialized(_this), _createDefaultTextureSet, {
      value: _createDefaultTextureSet2
    });
    _this.qualityRender = void 0;
    _this.viewer = void 0;
    _this.sceneModel = void 0;
    _this.rendererGeometries = void 0;
    _this.rendererTextures = void 0;
    _this.rendererTextureSets = void 0;
    _this.rendererMeshes = void 0;
    _this.rendererObjects = void 0;
    _this.rendererObjectsList = void 0;
    _this.rendererViewObjects = void 0;
    _this.onBuilt = void 0;
    _this.id = params.id;
    _this.sceneModel = params.sceneModel;
    _this.viewer = params.view.viewer;
    _this.rendererGeometries = {};
    _this.rendererTextures = {};
    _this.rendererTextureSets = {};
    _this.rendererMeshes = {};
    _this.rendererObjects = {};
    _this.rendererObjectsList = [];
    _this.rendererViewObjects = {};
    _this.built = false;
    _this.qualityRender = params.qualityRender !== false;
    _this.onBuilt = new EventEmitter(new dist.EventDispatcher());
    _this.built = true;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _createDefaultTextureSet)[_createDefaultTextureSet]();
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _attachSceneModel)[_attachSceneModel](_this.sceneModel);
    return _this;
  }
  var _proto = MockRendererModel.prototype;
  _proto.destroy = function destroy() {
    if (this.destroyed) {
      return;
    }
    this.rendererGeometries = {};
    this.rendererTextures = {};
    this.rendererTextureSets = {};
    this.rendererMeshes = {};
    this.rendererViewObjects = {};
    this.onBuilt.clear();
    _Component.prototype.destroy.call(this);
  };
  return MockRendererModel;
}(Component);
function _createDefaultTextureSet2() {
  var defaultColorRendererTexture = new MockRendererTexture(null);
  var defaultMetalRoughRendererTexture = new MockRendererTexture(null);
  var defaultNormalsRendererTexture = new MockRendererTexture(null);
  var defaultEmissiveRendererTexture = new MockRendererTexture(null);
  var defaultOcclusionRendererTexture = new MockRendererTexture(null);
  this.rendererTextures[defaultColorTextureId] = defaultColorRendererTexture;
  this.rendererTextures[defaultMetalRoughTextureId] = defaultMetalRoughRendererTexture;
  this.rendererTextures[defaultNormalsTextureId] = defaultNormalsRendererTexture;
  this.rendererTextures[defaultEmissiveTextureId] = defaultEmissiveRendererTexture;
  this.rendererTextures[defaultOcclusionTextureId] = defaultOcclusionRendererTexture;
  this.rendererTextureSets[defaultTextureSetId] = new MockRendererTextureSet({
    id: defaultTextureSetId,
    colorRendererTexture: defaultColorRendererTexture,
    metallicRoughnessRendererTexture: defaultMetalRoughRendererTexture,
    emissiveRendererTexture: defaultEmissiveRendererTexture,
    occlusionRendererTexture: defaultOcclusionRendererTexture
  });
}
function _attachSceneModel2(sceneModel) {
  var _this2 = this;
  var attach = function attach() {
    var textures = sceneModel.textures;
    var geometries = sceneModel.geometries;
    var meshes = sceneModel.meshes;
    var objects = sceneModel.objects;
    if (textures) {
      for (var textureId in textures) {
        _classPrivateFieldLooseBase(_this2, _attachTexture)[_attachTexture](textures[textureId]);
      }
    }
    if (geometries) {
      for (var geometryId in geometries) {
        _classPrivateFieldLooseBase(_this2, _attachGeometry)[_attachGeometry](geometries[geometryId]);
      }
    }
    if (meshes) {
      for (var meshId in meshes) {
        _classPrivateFieldLooseBase(_this2, _attachMesh)[_attachMesh](meshes[meshId]);
      }
    }
    if (objects) {
      for (var objectId in objects) {
        _classPrivateFieldLooseBase(_this2, _attachSceneObject)[_attachSceneObject](objects[objectId]);
      }
    }
    _this2.onBuilt.dispatch(_this2, null);
  };
  if (sceneModel.built) {
    attach();
  } else {
    sceneModel.onBuilt.one(attach);
  }
}
function _attachTexture2(texture) {
  var textureId = texture.id;
  if (this.rendererTextures[textureId]) {
    throw new SDKError("RendererTexture already created: " + textureId);
  }
  var rendererTexture = new MockRendererTexture(texture);
  texture.rendererTexture = rendererTexture;
  this.rendererTextures[textureId] = rendererTexture;
}
function _attachGeometry2(geometry) {
  var geometryId = geometry.id;
  if (this.rendererGeometries[geometryId]) {
    throw new SDKError("RendererGeometry already created: " + geometryId);
  }
  var rendererGeometry = new MockRendererGeometry();
  this.rendererGeometries[geometryId] = rendererGeometry;
  geometry.rendererGeometry = rendererGeometry;
}
function _attachMesh2(mesh) {
  var rendererGeometry = this.rendererGeometries[mesh.geometry.id];
  if (!rendererGeometry) {
    throw new SDKError("RendererGeometry not found");
  }
  var textureSetId = mesh.textureSet ? mesh.textureSet.id : defaultTextureSetId;
  var rendererTextureSet = this.rendererTextureSets[textureSetId];
  if (!rendererTextureSet) {
    throw new SDKError("TextureSet not found");
  }
  var meshRenderer = new MockRendererMesh({
    id: mesh.id,
    rendererTextureSet: rendererTextureSet,
    rendererGeometry: rendererGeometry,
    meshIndex: 0
  });
  this.rendererMeshes[mesh.id] = meshRenderer;
}
function _attachSceneObject2(sceneObject) {
  var objectId = sceneObject.id;
  if (objectId === undefined) {
    objectId = createUUID();
  } else if (this.rendererObjects[objectId]) {
    this.error("[createObject] rendererModel already has a ViewerObject with this ID: " + objectId + " - will assign random ID");
    objectId = createUUID();
  }
  var meshes = sceneObject.meshes;
  if (meshes === undefined) {
    throw new SDKError("[createObject] Param expected: meshes");
  }
  var rendererMeshes = [];
  for (var i = 0, len = meshes.length; i < len; i++) {
    var mesh = meshes[i];
    var rendererMesh = this.rendererMeshes[mesh.id];
    rendererMeshes.push(rendererMesh);
  }
  var rendererObject = new MockRendererObject({
    id: objectId,
    sceneObject: sceneObject,
    rendererModel: this,
    rendererMeshes: rendererMeshes,
    aabb: sceneObject.aabb,
    layerId: "0"
  });
  this.rendererObjectsList.push(rendererObject);
  this.rendererObjects[objectId] = rendererObject; // <RendererObject>
  this.rendererViewObjects[objectId] = rendererObject; // <RendererViewObject>
}

/**
 * Mock rendering strategy for a {@link @xeokit/viewer!Viewer | Viewer}.
 *
 * Plug a MockRenderer into a Viewer to effectively make it think it has a renderer, but not
 * actually render anything. This is useful for testing, and to demonstrate the API contract
 * to help you implement your own rendering strategies.
 *
 * See {@link @xeokit/mockrenderer} for usage.
 */
var _view$9 = /*#__PURE__*/_classPrivateFieldLooseKey("view");
var _viewMatrixDirty = /*#__PURE__*/_classPrivateFieldLooseKey("viewMatrixDirty");
var _rendererModels = /*#__PURE__*/_classPrivateFieldLooseKey("rendererModels");
var _viewer$1 = /*#__PURE__*/_classPrivateFieldLooseKey("viewer");
var _onViewMat = /*#__PURE__*/_classPrivateFieldLooseKey("onViewMat");
var _detachRendererViewObjects = /*#__PURE__*/_classPrivateFieldLooseKey("detachRendererViewObjects");
var _attachRendererViewObjects = /*#__PURE__*/_classPrivateFieldLooseKey("attachRendererViewObjects");
var MockRenderer = /*#__PURE__*/function () {
  /**
   * Creates a MockRenderer.
   *
   * @param params Configs
   */
  function MockRenderer(params) {
    Object.defineProperty(this, _attachRendererViewObjects, {
      value: _attachRendererViewObjects2
    });
    Object.defineProperty(this, _detachRendererViewObjects, {
      value: _detachRendererViewObjects2
    });
    /**
     * @inheritdoc
     */
    this.rendererViewObjects = void 0;
    Object.defineProperty(this, _view$9, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _viewMatrixDirty, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _rendererModels, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _viewer$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _onViewMat, {
      writable: true,
      value: void 0
    });
    this.rendererViewObjects = {};
    _classPrivateFieldLooseBase(this, _rendererModels)[_rendererModels] = {};
  }
  /**
   * @inheritdoc
   */
  var _proto = MockRenderer.prototype;
  _proto.getCapabilities = function getCapabilities(capabilities) {
    capabilities.maxViews = 1;
    capabilities.headless = true;
  }
  /**
   * @inheritdoc
   */;
  _proto.attachViewer = function attachViewer(viewer) {
    if (_classPrivateFieldLooseBase(this, _viewer$1)[_viewer$1]) {
      return new SDKError("Only one Viewer allowed with MockRenderer");
    }
    _classPrivateFieldLooseBase(this, _viewer$1)[_viewer$1] = viewer;
  }
  /**
   * @inheritdoc
   */;
  _proto.attachView = function attachView(view) {
    var _this = this;
    if (_classPrivateFieldLooseBase(this, _view$9)[_view$9]) {
      return new SDKError("Only one View allowed with MockRenderer (see WebViewerCapabilities.maxViews)");
    }
    _classPrivateFieldLooseBase(this, _view$9)[_view$9] = view;
    view.camera.onViewMatrix.sub(_classPrivateFieldLooseBase(this, _onViewMat)[_onViewMat] = function () {
      _classPrivateFieldLooseBase(_this, _viewMatrixDirty)[_viewMatrixDirty] = true;
    });
    return 0;
  }
  /**
   * @inheritdoc
   */;
  _proto.detachView = function detachView(viewIndex) {
    if (!_classPrivateFieldLooseBase(this, _view$9)[_view$9]) {
      return new SDKError("No View is currently attached to this Renderer");
    }
    _classPrivateFieldLooseBase(this, _view$9)[_view$9].camera.onViewMatrix.unsub(_classPrivateFieldLooseBase(this, _onViewMat)[_onViewMat]);
    _classPrivateFieldLooseBase(this, _onViewMat)[_onViewMat] = null;
    _classPrivateFieldLooseBase(this, _view$9)[_view$9] = null;
  }
  /**
   * @inheritdoc
   */;
  _proto.attachSceneModel = function attachSceneModel(sceneModel) {
    var _this2 = this;
    if (!_classPrivateFieldLooseBase(this, _view$9)[_view$9]) {
      return new SDKError("No View is currently attached to this Renderer");
    }
    if (sceneModel.rendererModel) {
      if (_classPrivateFieldLooseBase(this, _rendererModels)[_rendererModels][sceneModel.id]) {
        return new SDKError("SceneModel not attached to this Renderer");
      } else {
        return new SDKError("SceneModel already attached to another Renderer");
      }
    }
    var rendererModel = new MockRendererModel({
      qualityRender: false,
      id: sceneModel.id,
      sceneModel: sceneModel,
      view: _classPrivateFieldLooseBase(this, _view$9)[_view$9],
      mockRenderer: this
    });
    _classPrivateFieldLooseBase(this, _rendererModels)[_rendererModels][rendererModel.id] = rendererModel;
    _classPrivateFieldLooseBase(this, _attachRendererViewObjects)[_attachRendererViewObjects](rendererModel);
    rendererModel.onDestroyed.one(function (component) {
      var rendererModel = _classPrivateFieldLooseBase(_this2, _rendererModels)[_rendererModels][component.id];
      delete _classPrivateFieldLooseBase(_this2, _rendererModels)[_rendererModels][component.id];
      _classPrivateFieldLooseBase(_this2, _detachRendererViewObjects)[_detachRendererViewObjects](rendererModel);
    });
    sceneModel.rendererModel = rendererModel;
  }
  /**
   * @inheritdoc
   */;
  _proto.detachSceneModel = function detachSceneModel(sceneModel) {
    if (!_classPrivateFieldLooseBase(this, _view$9)[_view$9]) {
      return new SDKError("No View is currently attached to this Renderer");
    }
    if (!sceneModel.rendererModel) {
      return new SDKError("SceneModel not attached to any Renderer");
    }
    if (!_classPrivateFieldLooseBase(this, _rendererModels)[_rendererModels][sceneModel.id]) {
      return new SDKError("SceneModel not attached to this Renderer");
    }
    var rendererModel = _classPrivateFieldLooseBase(this, _rendererModels)[_rendererModels][sceneModel.id];
    delete _classPrivateFieldLooseBase(this, _rendererModels)[_rendererModels][sceneModel.id];
    _classPrivateFieldLooseBase(this, _detachRendererViewObjects)[_detachRendererViewObjects](rendererModel);
    sceneModel.rendererModel = null;
  }
  /**
   * @inheritdoc
   */;
  _proto.setImageDirty = function setImageDirty(viewIndex) {
    if (!_classPrivateFieldLooseBase(this, _view$9)[_view$9]) {
      return new SDKError("No View is currently attached to this Renderer");
    }
    if (viewIndex !== 0) {
      return new SDKError("No View with the given handle (" + viewIndex + ") is currently attached to this Renderer");
    }
  }
  /**
   * @inheritdoc
   */;
  _proto.setBackgroundColor = function setBackgroundColor(viewIndex, color) {
    if (!_classPrivateFieldLooseBase(this, _view$9)[_view$9]) {
      return new SDKError("No View is currently attached to this Renderer");
    }
    if (viewIndex !== 0) {
      return new SDKError("No View with the given handle (" + viewIndex + ") is currently attached to this Renderer");
    }
  }
  /**
   * @inheritdoc
   */;
  _proto.setEdgesEnabled = function setEdgesEnabled(viewIndex, enabled) {
    if (!_classPrivateFieldLooseBase(this, _view$9)[_view$9]) {
      return new SDKError("No View is currently attached to this Renderer");
    }
    if (viewIndex !== 0) {
      return new SDKError("No View with the given handle (" + viewIndex + ") is currently attached to this Renderer");
    }
  }
  /**
   * @inheritdoc
   */;
  _proto.setPBREnabled = function setPBREnabled(viewIndex, enabled) {
    if (!_classPrivateFieldLooseBase(this, _view$9)[_view$9]) {
      return new SDKError("No View is currently attached to this Renderer");
    }
    if (viewIndex !== 0) {
      return new SDKError("No View with the given handle (" + viewIndex + ") is currently attached to this Renderer");
    }
  }
  /**
   * @inheritdoc
   */;
  _proto.getSAOSupported = function getSAOSupported() {
    return false;
  }
  /**
   * @inheritdoc
   */;
  _proto.setSAOEnabled = function setSAOEnabled(viewIndex, enabled) {
    if (!_classPrivateFieldLooseBase(this, _view$9)[_view$9]) {
      return new SDKError("No View is currently attached to this Renderer");
    }
    if (viewIndex !== 0) {
      return new SDKError("No View with the given handle (" + viewIndex + ") is currently attached to this Renderer");
    }
  }
  /**
   * @inheritdoc
   */;
  _proto.setTransparentEnabled = function setTransparentEnabled(viewIndex, enabled) {
    if (!_classPrivateFieldLooseBase(this, _view$9)[_view$9]) {
      return new SDKError("No View is currently attached to this Renderer");
    }
    if (viewIndex !== 0) {
      return new SDKError("No View with the given handle (" + viewIndex + ") is currently attached to this Renderer");
    }
  }
  /**
   * @inheritdoc
   */;
  _proto.clear = function clear(viewIndex) {
    if (!_classPrivateFieldLooseBase(this, _view$9)[_view$9]) {
      return new SDKError("No View is currently attached to this Renderer");
    }
    if (viewIndex !== 0) {
      return new SDKError("No View with the given handle (" + viewIndex + ") is currently attached to this Renderer");
    }
  };
  /**
   * @inheritdoc
   */
  _proto.needsRebuild = function needsRebuild(viewIndex) {
    if (!_classPrivateFieldLooseBase(this, _view$9)[_view$9]) {
      return new SDKError("No View is currently attached to this Renderer");
    }
    if (viewIndex !== 0) {
      return new SDKError("No View with the given handle (" + viewIndex + ") is currently attached to this Renderer");
    }
  }
  /**
   * @inheritdoc
   */;
  _proto.needsRender = function needsRender(viewIndex) {
    if (!_classPrivateFieldLooseBase(this, _view$9)[_view$9]) {
      return new SDKError("No View is currently attached to this Renderer");
    }
    if (viewIndex !== 0) {
      return new SDKError("No View with the given handle (" + viewIndex + ") is currently attached to this Renderer");
    }
    return false;
  }
  /**
   * @inheritdoc
   */;
  _proto.render = function render(viewIndex, params) {
    if (!_classPrivateFieldLooseBase(this, _view$9)[_view$9]) {
      return new SDKError("No View is currently attached to this Renderer");
    }
    if (viewIndex !== 0) {
      return new SDKError("No View with the given handle (" + viewIndex + ") is currently attached to this Renderer");
    }
  }
  /**
   * @inheritdoc
   */;
  _proto.pickViewObject = function pickViewObject(viewIndex, params) {
    if (!_classPrivateFieldLooseBase(this, _view$9)[_view$9]) {
      return new SDKError("No View is currently attached to this Renderer");
    }
    if (viewIndex !== 0) {
      return new SDKError("No View with the given handle (" + viewIndex + ") is currently attached to this Renderer");
    }
    return null;
  };
  return MockRenderer;
}();
function _detachRendererViewObjects2(rendererModel) {
  var rendererViewObjects = rendererModel.rendererViewObjects;
  for (var id in rendererViewObjects) {
    delete this.rendererViewObjects[id];
  }
}
function _attachRendererViewObjects2(rendererModel) {
  var rendererViewObjects = rendererModel.rendererViewObjects;
  for (var id in rendererViewObjects) {
    this.rendererViewObjects[id] = rendererViewObjects[id];
  }
}

/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2Fwebgl.svg)](https://badge.fury.io/js/%40xeokit%2Fwebgl)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/mockrenderer/badge)](https://www.jsdelivr.com/package/npm/@xeokit/mockrenderer)
 *
 * <img style="padding:50px" src="media://images/xeokit_datamodel_icon.png"/>
 *
 * # xeokit Mock Renderer
 *
 * ---
 *
 * ### *Configures a xeokit Viewer with a mock renderer*
 *
 * ---
 *
 * * Plug a {@link MockRenderer} into a {@link @xeokit/viewer!Viewer} to use a mock renderer for model storage and rendering
 * * Does not render anything
 * * Used for testing the Viewer
 * * Used to guide the development of custom renderers
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/mockrenderer
 * ````
 *
 * ## Usage
 *
 * Configuring a {@link @xeokit/viewer!Viewer} with a {@link MockRenderer} to use the browser's WebGL
 * graphics API for storing and rendering models:
 *
 * ````javascript
 * import {Scene} from "@xeokit/scene";
 * import {Viewer} from "@xeokit/viewer";
 * import {MockRenderer} from "@xeokit/mockrenderer";
 *
 * const myViewer = new Viewer({
 *     id: "myViewer",
 *     scene: new Scene(),
 *     renderer: new MockRenderer()
 * });
 *
 * //...
 * ````
 *
 * @module @xeokit/mockrenderer
 */

var index$4 = {
  __proto__: null,
  MockRenderer: MockRenderer
};

var KTX2TransferSRGB = 2;
var KTX2_ALPHA_PREMULTIPLIED = 1;
var activeTranscoders = 0;
var BasisFormat = {
  ETC1S: 0,
  UASTC_4x4: 1
};
var TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
};
var EngineFormat = {
  RGBAFormat: RGBAFormat,
  RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format: RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format: RGB_ETC1_Format,
  RGB_ETC2_Format: RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format
};
/**
 * [KTX2](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#ktx2) texture decompression strategy.
 *
 * See {@link @xeokit/ktx2} for usage.
 */
var _transcoderPath = /*#__PURE__*/_classPrivateFieldLooseKey("transcoderPath");
var _transcoderBinary = /*#__PURE__*/_classPrivateFieldLooseKey("transcoderBinary");
var _transcoderPending = /*#__PURE__*/_classPrivateFieldLooseKey("transcoderPending");
var _workerPool = /*#__PURE__*/_classPrivateFieldLooseKey("workerPool");
var _workerSourceURL = /*#__PURE__*/_classPrivateFieldLooseKey("workerSourceURL");
var _workerConfig = /*#__PURE__*/_classPrivateFieldLooseKey("workerConfig");
var _supportedFileTypes = /*#__PURE__*/_classPrivateFieldLooseKey("supportedFileTypes");
var _withCredentials = /*#__PURE__*/_classPrivateFieldLooseKey("withCredentials");
var _initTranscoder = /*#__PURE__*/_classPrivateFieldLooseKey("initTranscoder");
var KTX2TextureTranscoder = /*#__PURE__*/function () {
  /**
   * Creates a new KTX2TextureTranscoder.
   *
   * @param {String} [params.transcoderPath="https://cdn.jsdelivr.net/npm/@xeokit/sdk/dist/basis/"] Path to the Basis
   * transcoder module that internally does the heavy lifting for our KTX2TextureTranscoder. If we omit this configuration,
   * then our KTX2TextureTranscoder will load it from ````https://cdn.jsdelivr.net/npm/@xeokit/sdk/dist/basis/```` by
   * default. Therefore, make sure your application is connected to the internet if you wish to use the default transcoder path.
   * @param {Number} [params.workerLimit] The maximum number of Workers to use for transcoding.
   */
  function KTX2TextureTranscoder(params) {
    Object.defineProperty(this, _initTranscoder, {
      value: _initTranscoder2
    });
    Object.defineProperty(this, _transcoderPath, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _transcoderBinary, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _transcoderPending, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _workerPool, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _workerSourceURL, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _workerConfig, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _supportedFileTypes, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _withCredentials, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _transcoderPath)[_transcoderPath] = params.transcoderPath || "https://cdn.jsdelivr.net/npm/@xeokit/sdk/dist/basis/";
    _classPrivateFieldLooseBase(this, _transcoderBinary)[_transcoderBinary] = null;
    _classPrivateFieldLooseBase(this, _transcoderPending)[_transcoderPending] = null;
    _classPrivateFieldLooseBase(this, _workerPool)[_workerPool] = new WorkerPool();
    _classPrivateFieldLooseBase(this, _workerSourceURL)[_workerSourceURL] = '';
    if (params.workerLimit) {
      _classPrivateFieldLooseBase(this, _workerPool)[_workerPool].setWorkerLimit(params.workerLimit);
    }
    _classPrivateFieldLooseBase(this, _workerConfig)[_workerConfig] = null;
    _classPrivateFieldLooseBase(this, _withCredentials)[_withCredentials] = false;
    _classPrivateFieldLooseBase(this, _supportedFileTypes)[_supportedFileTypes] = ["xkt2"];
  }
  /**
   * Initializes this transcoder.
   *
   * @param capabilities A set of flags indicating the capabilities of this TextureTranscoder.
   */
  var _proto = KTX2TextureTranscoder.prototype;
  _proto.init = function init(capabilities) {
    _classPrivateFieldLooseBase(this, _workerConfig)[_workerConfig] = {
      astcSupported: capabilities.astcSupported,
      etc1Supported: capabilities.etc1Supported,
      etc2Supported: capabilities.etc2Supported,
      dxtSupported: capabilities.dxtSupported,
      bptcSupported: capabilities.bptcSupported,
      pvrtcSupported: capabilities.pvrtcSupported
    };
  }
  /**
   * Transcodes texture data from transcoded buffers.
   *
   * @param {ArrayBuffer[]} buffers Transcoded input texture data. Given as an array of buffers so that we can support multi-image textures, such as cube maps.
   * @param {*} config Transcoding options.
   * @returns {Promise<TextureCompressedParams>} Transcoded output texture data.
   */;
  _proto.transcode = function transcode(buffers, config) {
    var _this = this;
    if (config === void 0) {
      config = {};
    }
    return new Promise(function (resolve, reject) {
      var taskConfig = config;
      _classPrivateFieldLooseBase(_this, _initTranscoder)[_initTranscoder]().then(function () {
        return _classPrivateFieldLooseBase(_this, _workerPool)[_workerPool].postMessage({
          type: 'transcode',
          buffers: buffers,
          taskConfig: taskConfig
        }, buffers);
      }).then(function (e) {
        // @ts-ignore
        var transcodeResult = e.data;
        var mipmaps = transcodeResult.mipmaps,
          format = transcodeResult.format,
          type = transcodeResult.type,
          error = transcodeResult.error,
          dfdTransferFn = transcodeResult.dfdTransferFn,
          dfdFlags = transcodeResult.dfdFlags;
        if (type === 'error') {
          return reject(error);
        }
        resolve({
          mipmaps: mipmaps,
          props: {
            format: format,
            minFilter: mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter,
            magFilter: mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter,
            encoding: dfdTransferFn === KTX2TransferSRGB ? sRGBEncoding : LinearEncoding,
            premultiplyAlpha: !!(dfdFlags & KTX2_ALPHA_PREMULTIPLIED)
          }
        });
      });
    });
  }
  /**
   * Destroys this KTX2TextureTranscoder
   */;
  _proto.destroy = function destroy() {
    URL.revokeObjectURL(_classPrivateFieldLooseBase(this, _workerSourceURL)[_workerSourceURL]);
    _classPrivateFieldLooseBase(this, _workerPool)[_workerPool].destroy();
    activeTranscoders--;
  };
  return KTX2TextureTranscoder;
}();
function _initTranscoder2() {
  var _this2 = this;
  if (!_classPrivateFieldLooseBase(this, _transcoderPending)[_transcoderPending]) {
    var jsLoader = new FileLoader();
    jsLoader.setPath(_classPrivateFieldLooseBase(this, _transcoderPath)[_transcoderPath]);
    jsLoader.setWithCredentials(_classPrivateFieldLooseBase(this, _withCredentials)[_withCredentials]);
    // @ts-ignore
    var jsContent = jsLoader.loadAsync('basis_transcoder.js');
    var binaryLoader = new FileLoader();
    binaryLoader.setPath(_classPrivateFieldLooseBase(this, _transcoderPath)[_transcoderPath]);
    binaryLoader.setResponseType('arraybuffer');
    binaryLoader.setWithCredentials(_classPrivateFieldLooseBase(this, _withCredentials)[_withCredentials]);
    // @ts-ignore
    var binaryContent = binaryLoader.loadAsync('basis_transcoder.wasm');
    _classPrivateFieldLooseBase(this, _transcoderPending)[_transcoderPending] = Promise.all([jsContent, binaryContent]).then(function (_ref) {
      var jsContent = _ref[0],
        binaryContent = _ref[1];
      var fn = BasisWorker.toString();
      var body = ['/* constants */', 'let _EngineFormat = ' + JSON.stringify(EngineFormat), 'let _TranscoderFormat = ' + JSON.stringify(TranscoderFormat), 'let _BasisFormat = ' + JSON.stringify(BasisFormat), '/* basis_transcoder.js */', jsContent, '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\n');
      _classPrivateFieldLooseBase(_this2, _workerSourceURL)[_workerSourceURL] = URL.createObjectURL(new Blob([body]));
      _classPrivateFieldLooseBase(_this2, _transcoderBinary)[_transcoderBinary] = binaryContent;
      _classPrivateFieldLooseBase(_this2, _workerPool)[_workerPool].setWorkerCreator(function () {
        var worker = new Worker(_classPrivateFieldLooseBase(_this2, _workerSourceURL)[_workerSourceURL]);
        var transcoderBinary = _classPrivateFieldLooseBase(_this2, _transcoderBinary)[_transcoderBinary].slice(0);
        worker.postMessage({
          type: 'init',
          config: _classPrivateFieldLooseBase(_this2, _workerConfig)[_workerConfig],
          transcoderBinary: transcoderBinary
        }, [transcoderBinary]);
        return worker;
      });
    });
    if (activeTranscoders > 0) {
      console.warn('KTX2TextureTranscoder: Multiple active KTX2TextureTranscoder may cause performance issues.' + ' Use a single KTX2TextureTranscoder instance, or call .dispose() on old instances.');
    }
    activeTranscoders++;
  }
  return _classPrivateFieldLooseBase(this, _transcoderPending)[_transcoderPending];
}
var BasisWorker = function BasisWorker() {
  var config;
  var transcoderPending;
  var BasisModule;
  // @ts-ignore
  var EngineFormat = _EngineFormat; // eslint-disable-line no-undef
  // @ts-ignore
  var TranscoderFormat = _TranscoderFormat; // eslint-disable-line no-undef
  // @ts-ignore
  var BasisFormat = _BasisFormat; // eslint-disable-line no-undef
  self.addEventListener('message', function (e) {
    var message = e.data;
    switch (message.type) {
      case 'init':
        config = message.config;
        init(message.transcoderBinary);
        break;
      case 'transcode':
        transcoderPending.then(function () {
          try {
            var _transcode = transcode(message.buffers[0]),
              width = _transcode.width,
              height = _transcode.height,
              hasAlpha = _transcode.hasAlpha,
              mipmaps = _transcode.mipmaps,
              format = _transcode.format,
              dfdTransferFn = _transcode.dfdTransferFn,
              dfdFlags = _transcode.dfdFlags;
            var buffers = [];
            for (var i = 0; i < mipmaps.length; ++i) {
              buffers.push(mipmaps[i].data.buffer);
            }
            self.postMessage({
              type: 'transcode',
              id: message.id,
              width: width,
              height: height,
              hasAlpha: hasAlpha,
              mipmaps: mipmaps,
              format: format,
              dfdTransferFn: dfdTransferFn,
              dfdFlags: dfdFlags
              // @ts-ignore
            }, buffers);
          } catch (error) {
            console.error("[BasisWorker]: " + error);
            // @ts-ignore
            self.postMessage({
              type: 'error',
              id: message.id,
              error: error.message
            });
          }
        });
        break;
    }
  });
  function init(wasmBinary) {
    transcoderPending = new Promise(function (resolve) {
      BasisModule = {
        wasmBinary: wasmBinary,
        onRuntimeInitialized: resolve
      };
      // @ts-ignore
      BASIS(BasisModule); // eslint-disable-line no-undef
    }).then(function () {
      BasisModule.initializeBasis();
      if (BasisModule.KTX2File === undefined) {
        console.warn('KTX2TextureTranscoder: Please update Basis Universal transcoder.');
      }
    });
  }
  function transcode(buffer) {
    var ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));
    function cleanup() {
      ktx2File.close();
      ktx2File["delete"]();
    }
    if (!ktx2File.isValid()) {
      cleanup();
      throw new Error('KTX2TextureTranscoder: Invalid or unsupported .ktx2 file');
    }
    var basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
    var width = ktx2File.getWidth();
    var height = ktx2File.getHeight();
    var levels = ktx2File.getLevels();
    var hasAlpha = ktx2File.getHasAlpha();
    var dfdTransferFn = ktx2File.getDFDTransferFunc();
    var dfdFlags = ktx2File.getDFDFlags();
    var _getTranscoderFormat = getTranscoderFormat(basisFormat, width, height, hasAlpha),
      transcoderFormat = _getTranscoderFormat.transcoderFormat,
      engineFormat = _getTranscoderFormat.engineFormat;
    if (!width || !height || !levels) {
      cleanup();
      throw new Error('KTX2TextureTranscoder: Invalid texture');
    }
    if (!ktx2File.startTranscoding()) {
      cleanup();
      throw new Error('KTX2TextureTranscoder: .startTranscoding failed');
    }
    var mipmaps = [];
    for (var mip = 0; mip < levels; mip++) {
      var levelInfo = ktx2File.getImageLevelInfo(mip, 0, 0);
      var mipWidth = levelInfo.origWidth;
      var mipHeight = levelInfo.origHeight;
      var dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, 0, 0, transcoderFormat));
      var status = ktx2File.transcodeImage(dst, mip, 0, 0, transcoderFormat, 0, -1, -1);
      if (!status) {
        cleanup();
        throw new Error('KTX2TextureTranscoder: .transcodeImage failed.');
      }
      mipmaps.push({
        data: dst,
        width: mipWidth,
        height: mipHeight
      });
    }
    cleanup();
    return {
      width: width,
      height: height,
      hasAlpha: hasAlpha,
      mipmaps: mipmaps,
      format: engineFormat,
      dfdTransferFn: dfdTransferFn,
      dfdFlags: dfdFlags
    };
  }
  // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),
  // device capabilities, and texture dimensions. The list below ranks the formats separately
  // for ETC1S and UASTC.
  //
  // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at
  // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently
  // chooses RGBA32 only as a last resort and does not expose that option to the caller.
  var FORMAT_OPTIONS = [{
    "if": 'astcSupported',
    basisFormat: [BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
    priorityETC1S: Infinity,
    priorityUASTC: 1,
    needsPowerOfTwo: false
  }, {
    "if": 'bptcSupported',
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
    priorityETC1S: 3,
    priorityUASTC: 2,
    needsPowerOfTwo: false
  }, {
    "if": 'dxtSupported',
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
    priorityETC1S: 4,
    priorityUASTC: 5,
    needsPowerOfTwo: false
  }, {
    "if": 'etc2Supported',
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
    priorityETC1S: 1,
    priorityUASTC: 3,
    needsPowerOfTwo: false
  }, {
    "if": 'etc1Supported',
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ETC1],
    engineFormat: [EngineFormat.RGB_ETC1_Format],
    priorityETC1S: 2,
    priorityUASTC: 4,
    needsPowerOfTwo: false
  }, {
    "if": 'pvrtcSupported',
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
    priorityETC1S: 5,
    priorityUASTC: 6,
    needsPowerOfTwo: true
  }];
  var ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {
    return a.priorityETC1S - b.priorityETC1S;
  });
  var UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {
    return a.priorityUASTC - b.priorityUASTC;
  });
  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
    var transcoderFormat;
    var engineFormat;
    var options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;
    for (var i = 0; i < options.length; i++) {
      var opt = options[i];
      if (!config[opt["if"]]) continue;
      if (!opt.basisFormat.includes(basisFormat)) continue;
      if (hasAlpha && opt.transcoderFormat.length < 2) continue;
      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;
      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
      return {
        transcoderFormat: transcoderFormat,
        engineFormat: engineFormat
      };
    }
    console.warn('KTX2TextureTranscoder: No suitable compressed texture format found. Decoding to RGBA32.');
    transcoderFormat = TranscoderFormat.RGBA32;
    engineFormat = EngineFormat.RGBAFormat;
    return {
      transcoderFormat: transcoderFormat,
      engineFormat: engineFormat
    };
  }
  function isPowerOfTwo(value) {
    if (value <= 2) return true;
    return (value & value - 1) === 0 && value !== 0;
  }
};

/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2Fktx2.svg)](https://badge.fury.io/js/%40xeokit%2Fktx2)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/ktx2/badge)](https://www.jsdelivr.com/package/npm/@xeokit/ktx2)
 *
 * <img style="padding:0px; padding-top:20px; padding-bottom:30px; height:140px;" src="media://images/xeokit_ktx_logo.svg"/>
 *
 * # xeokit KTX2 Texture Transcoder
 *
 * ---
 *
 * ### *Enables the xeokit Viewer to load KTX2-compressed textures*
 *
 * ---
 *
 * * Provides {@link KTX2TextureTranscoder}
 * * Configure a {@link @xeokit/viewer!Viewer} with a {@link @xeokit/webglrenderer!WebGLRenderer} that has a {@link KTX2TextureTranscoder}
 * * Then a Viewer is able to view a {@link @xeokit/scene!SceneModel.createTexture | SceneModel.createTexture} that has KTX2-encoded compressed textures
 * * Uses the [Basis Universal GPU Texture Codec](https://github.com/BinomialLLC/basis_universal) to
 * transcode [KTX2](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#ktx2) textures.
 * * Loads the Basis Codec from [CDN](https://cdn.jsdelivr.net/npm/@xeokit/sdk/dist/basis/) by default, but can
 * also be configured to load the Codec from local files.
 * * We also bundle the Basis Codec with the xeokit-viewer npm package, and in the [repository](https://github.com/xeokit/sdk/tree/master/dist/basis).
 *
 * ### What is KTX2?
 *
 * A [KTX2](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#ktx2) file stores GPU texture data in the Khronos Texture 2.0 (KTX2) container format. It contains image data for
 * a texture asset compressed with Basis Universal (BasisU) supercompression that can be transcoded to different formats
 * depending on the support provided by the target devices. [KTX2](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#ktx2) provides a lightweight format for distributing texture
 * assets to GPUs. Due to BasisU compression, [KTX2](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#ktx2) files can store any image format supported by GPUs.
 *
 * <br>
 *
 * [![](https://mermaid.ink/img/pako:eNqNUsFuwjAM_ZXKp00CabtWqIeN0wQD0WsupnFHpjSpnORQIf59SUMHCImtl9TPznvPjo_QWElQQqPRuaXCL8ZOGGGkYmq8sqZY7VI85ou6IUPreEMXR2GK-CmZT7v_jvUuBw0TetqM0NNzxvZBaTkFkpxnO6TwlNgn_iV6HOkfsfdse2I_1PRIL2M70pi6cAfV32a2F5Z_WcwGVxblu_LDR7353GKclZsGsVj0KSZPXFUZQmYc3kLbEmfA_Y7vrDG1e6OhrzQu7G0w43sk8rH43oqAFwHzeSXgVUB9pfVH6fJi41p7St_fhhl0xB0qGTdndCjAH6gjAWX8ldRi0F5AdBpLMXhbD6aB0nOgGYQ-9k3nXYOyRe0iSlJ5y-vzNqbj9AOT7uJt?type=png)](https://mermaid.live/edit#pako:eNqNUsFuwjAM_ZXKp00CabtWqIeN0wQD0WsupnFHpjSpnORQIf59SUMHCImtl9TPznvPjo_QWElQQqPRuaXCL8ZOGGGkYmq8sqZY7VI85ou6IUPreEMXR2GK-CmZT7v_jvUuBw0TetqM0NNzxvZBaTkFkpxnO6TwlNgn_iV6HOkfsfdse2I_1PRIL2M70pi6cAfV32a2F5Z_WcwGVxblu_LDR7353GKclZsGsVj0KSZPXFUZQmYc3kLbEmfA_Y7vrDG1e6OhrzQu7G0w43sk8rH43oqAFwHzeSXgVUB9pfVH6fJi41p7St_fhhl0xB0qGTdndCjAH6gjAWX8ldRi0F5AdBpLMXhbD6aB0nOgGYQ-9k3nXYOyRe0iSlJ5y-vzNqbj9AOT7uJt)
 *
 * <br>
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/ktx2
 * ````
 *
 * ## Usage
 *
 * ### Loading an XKT file containing [KTX2](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#ktx2) textures into a Viewer
 *
 * Create a {@link @xeokit/viewer!Viewer} with a {@link @xeokit/webglrenderer!WebGLRenderer} configured with a
 * {@link @xeokit/ktx2!KTX2TextureTranscoder | KTX2TextureTranscoder}. Then create a {@link @xeokit/scene!SceneModel | SceneModel} within the Viewer, and use {@link loadXKT} to
 * load an [XKT](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#xkt) file with KTX2-compressed textures into the SceneModel. For each [KTX2](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#ktx2) texture in the file, the
 * KTX2TextureTranscoder will transparently transcode the [KTX2](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#ktx2) data for us.
 *
 * ````javascript
 * import {Viewer} from "@xeokit/viewer";
 * import {WebGLRenderer} from "@xeokit/webglrenderer";
 * import {KTX2TextureTranscoder} from "@xeokit/ktx2";
 * import {loadXKT} from "@xeokit/xkt";
 *
 * const myViewer = new Viewer({
 *     id: "myViewer",
 *     renderer: new WebGLRenderer({ // Optional
 *          textureTranscoder: new KTX2TextureTranscoder({
 *              transcoderPath: "./../dist/basis/" // Optional, path to BasisU transcoder module
 *          })
 *     })
 * });
 *
 * const view1 = myViewer.createView({
 *     id: "myView",
 *     canvasId: "myCanvas1"
 * });
 *
 * view1.camera.eye = [-3.933, 2.855, 27.018];
 * view1.camera.look = [4.400, 3.724, 8.899];
 * view1.camera.up = [-0.018, 0.999, 0.039];
 *
 * const sceneModel= myViewer.scene.createModel({
 *     id: "myModel"
 * });
 *
 * fetch("myModelWithTextures.xkt") // <<-- [XKT](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#xkt) file with KTX2 textures
 *     .then(response => {
 *          if (response.ok) {
 *              loadXKT(response.arrayBuffer(), sceneModel);
 *              sceneModel.build();
 *          }
 *     });
 * ````
 *
 * ### Loading KTX2 texture files into a Viewer
 *
 * As in the previous example, create a {@link @xeokit/viewer!Viewer} with a {@link @xeokit/webglrenderer!WebGLRenderer} configured with a
 * {@link @xeokit/ktx2!KTX2TextureTranscoder}, then create a {@link @xeokit/scene!SceneModel | SceneModel} within the Viewer.
 *
 * This time, we'll build the SceneModel ourselves, using its builder methods. When we
 * call builder method {@link @xeokit/scene!SceneModel.createTexture | SceneModel.createTexture} with a path to a KTX2-compressed texture file, the
 * KTX2TextureTranscoder will transparently transcode that KTX2 data for us.
 *
 * ````javascript
 * import {Viewer} from "@xeokit/viewer";
 * import {WebGLRenderer} from "@xeokit/webglrenderer";
 * import {KTX2TextureTranscoder} from "@xeokit/ktx2";
 * import {loadXKT} from "@xeokit/xkt";
 *
 * const myViewer = new Viewer({
 *     id: "myViewer",
 *     renderer: new WebGLRenderer({ // Optional
 *          textureTranscoder: new KTX2TextureTranscoder({ // Optional
 *              transcoderPath: "./../dist/basis/" // Optional, path to BasisU transcoder module
 *          })
 *     })
 * });
 *
 * const view1 = myViewer.createView({
 *     id: "myView",
 *     canvasId: "myView1"
 * });
 *
 * view1.camera.eye = [-3.933, 2.855, 27.018];
 * view1.camera.look = [4.400, 3.724, 8.899];
 * view1.camera.up = [-0.018, 0.999, 0.039];
 *
 * const viewerModel = myViewer.scene.createModel({
 *      id: "myModel"
 *  });
 *
 * viewerModel.createTexture({
 *      id: "myColorTexture",
 *      src: "sample_uastc_zstd.ktx2" // <<----- KTX2 texture asset
 * });
 *
 * viewerModel.createTexture({
 *      id: "myMetallicRoughnessTexture",
 *      src: "crosshatchAlphaMap.jpg" // <<----- JPEG texture asset
 * });
 *
 * viewerModel.createTextureSet({
 *      id: "myTextureSet",
 *      colorTextureId: "myColorTexture",
 *      metallicRoughnessTextureId: "myMetallicRoughnessTexture"
 *  });
 *
 * viewerModel.createGeometry({
 *     id: "myGeometry",
 *     primitive: TrianglesPrimitive,
 *     positions: [1, 1, 1, ...],
 *     normals: [0, 0, 1, 0, ...],
 *     uv: [1, 0, 0, ...],
 *     indices: [0, 1, 2, ...],
 * });
 *
 * viewerModel.createMesh({
 *      id: "myMesh",
 *      textureSetId: "myTextureSet",
 *      geometryId: "myGeometry"
 *  });
 *
 * viewerModel.createObject({
 *      id: "myObject",
 *      meshIds: ["myMesh"]
 *  });
 *
 * viewerModel.build();
 * ````
 *
 * ### Loading [KTX2](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#ktx2) texture ArrayBuffers into a Viewer
 *
 * As in the previous two examples, create a {@link @xeokit/viewer!Viewer} that has a {@link @xeokit/webglrenderer!WebGLRenderer} configured with a
 * {@link @xeokit/ktx2!KTX2TextureTranscoder}, and then create a {@link @xeokit/scene!SceneModel | SceneModel} within the Viewer.
 *
 * Once more, build the SceneModel using its builder methods. This time, call builder method
 * {@link @xeokit/scene!SceneModel.createTexture | SceneModel.createTexture} with an ArrayBuffer containing the contents of a KTX2-compressed texture
 * file. As before, the KTX2TextureTranscoder will transparently transcode that [KTX2](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#ktx2) data for us.
 *
 * ````javascript
 * import {Viewer} from "@xeokit/viewer";
 * import {WebGLRenderer} from "@xeokit/webglrenderer";
 * import {KTX2TextureTranscoder} from "@xeokit/ktx2";
 * import {loadXKT} from "@xeokit/xkt";
 *
 * const myViewer = new Viewer({
 *     id: "myViewer",
 *     renderer: new WebGLRenderer({ // Optional
 *          textureTranscoder: new KTX2TextureTranscoder({ // Optional
 *              transcoderPath: "./../dist/basis/" // Optional, path to BasisU transcoder module
 *          })
 *     })
 * });
 *
 * const view1 = myViewer.createView({
 *     id: "myView",
 *     canvasId: "myView1"
 * });
 *
 * view1.camera.eye = [-3.933, 2.855, 27.018];
 * view1.camera.look = [4.400, 3.724, 8.899];
 * view1.camera.up = [-0.018, 0.999, 0.039];
 *
 * const viewerModel = myViewer.scene.createModel({
 *      id: "myModel"
 * });
 *
 * fetch("sample_uastc_zstd.ktx2") // // <<----- KTX2 texture asset
 *     .then(response => {
 *          if (response.ok) {
 *
 *              viewerModel.createTexture({
 *                  id: "myColorTexture",
 *                  buffers: [arrayBuffer] // <<----- KTX2 texture asset
 *              });
 *
 *              viewerModel.createTexture({
 *                  id: "myMetallicRoughnessTexture",
 *                  src: "../assets/textures/alpha/crosshatchAlphaMap.jpg" // <<----- JPEG texture asset
 *              });
 *
 *              viewerModel.createTextureSet({
 *                  id: "myTextureSet",
 *                  colorTextureId: "myColorTexture",
 *                  metallicRoughnessTextureId: "myMetallicRoughnessTexture"
 *              });
 *
 *              viewerModel.createGeometry({
 *                  id: "myGeometry",
 *                  primitive: TrianglesPrimitive,
 *                  positions: [1, 1, 1, ...],
 *                  normals: [0, 0, 1, 0, ...],
 *                  uv: [1, 0, 0, ...],
 *                  indices: [0, 1, 2, ...],
 *              });
 *
 *              viewerModel.createMesh({
 *                  id: "myMesh",
 *                  textureSetId: "myTextureSet",
 *                  geometryId: "myGeometry"
 *              });
 *
 *              viewerModel.createObject({
 *                  id: "myObject",
 *                  meshIds: ["myMesh"]
 *              });
 *
 *              viewerModel.build();
 *          }
 *     });
 * ````
 *
 * @module @xeokit/ktx2
 */

var index$3 = {
  __proto__: null,
  KTX2TextureTranscoder: KTX2TextureTranscoder
};

var screenPos = createVec4();
var viewPos = createVec4();
var tempVec3a$2 = createVec3();
var tempVec3b$2 = createVec3();
var tempVec3c$2 = createVec3();
var tempVec4a$1 = createVec4();
var tempVec4b$1 = createVec4();
var tempVec4c$1 = createVec4();
/**
 * @private
 */
var _unproject = /*#__PURE__*/_classPrivateFieldLooseKey("unproject");
var PanController = /*#__PURE__*/function () {
  function PanController(cameraControl) {
    Object.defineProperty(this, _unproject, {
      value: _unproject2
    });
    this.view = void 0;
    this.view = cameraControl.view;
  }
  /**
   * Dollys the Camera towards the given target 2D canvas position.
   *
   * When the target's corresponding World-space position is also provided, then this function will also test if we've
   * dollied past the target, and will return ````true```` if that's the case.
   *
   * @param [optionalTargetWorldPos] Optional world position of the target
   * @param targetCanvasPos Canvas position of the target
   * @param dollyDelta Amount to dolly
   * @return True if optionalTargetWorldPos was given, and we've dollied past that position.
   */
  var _proto = PanController.prototype;
  _proto.dollyToCanvasPos = function dollyToCanvasPos(optionalTargetWorldPos, targetCanvasPos, dollyDelta) {
    var dolliedThroughSurface = false;
    var camera = this.view.camera;
    if (optionalTargetWorldPos) {
      var eyeToWorldPosVec = subVec3(optionalTargetWorldPos, camera.eye, tempVec3a$2);
      var eyeWorldPosDist = lenVec3(eyeToWorldPosVec);
      dolliedThroughSurface = eyeWorldPosDist < dollyDelta;
    }
    if (camera.projectionType === PerspectiveProjectionType) {
      camera.orthoProjection.scale = camera.orthoProjection.scale - dollyDelta;
      var unprojectedWorldPos = _classPrivateFieldLooseBase(this, _unproject)[_unproject](targetCanvasPos, tempVec4a$1);
      var offset = subVec3(unprojectedWorldPos, camera.eye, tempVec4c$1);
      var moveVec = mulVec3Scalar(normalizeVec3(offset), -dollyDelta, []);
      camera.eye = [camera.eye[0] - moveVec[0], camera.eye[1] - moveVec[1], camera.eye[2] - moveVec[2]];
      camera.look = [camera.look[0] - moveVec[0], camera.look[1] - moveVec[1], camera.look[2] - moveVec[2]];
      if (optionalTargetWorldPos) {
        // Subtle UX tweak - if we have a target World position, then set camera eye->look distance to
        // the same distance as from eye->target. This just gives us a better position for look,
        // if we subsequently orbit eye about look, so that we don't orbit a position that's
        // suddenly a lot closer than the point we pivoted about on the surface of the last object
        // that we click-drag-pivoted on.
        var eyeTargetVec = subVec3(optionalTargetWorldPos, camera.eye, tempVec3a$2);
        var lenEyeTargetVec = lenVec3(eyeTargetVec);
        var eyeLookVec = mulVec3Scalar(normalizeVec3(subVec3(camera.look, camera.eye, tempVec3b$2)), lenEyeTargetVec);
        camera.look = [camera.eye[0] + eyeLookVec[0], camera.eye[1] + eyeLookVec[1], camera.eye[2] + eyeLookVec[2]];
      }
    } else if (camera.projectionType === OrthoProjectionType) {
      // - set ortho scale, getting the unprojected targetCanvasPos before and after, get that difference in a vector;
      // - get the vector in which we're dollying;
      // - add both vectors to camera eye and look.
      var worldPos1 = _classPrivateFieldLooseBase(this, _unproject)[_unproject](targetCanvasPos, tempVec4a$1);
      camera.orthoProjection.scale = camera.orthoProjection.scale - dollyDelta;
      camera.orthoProjection.clean(); // HACK
      var worldPos2 = _classPrivateFieldLooseBase(this, _unproject)[_unproject](targetCanvasPos, tempVec4b$1);
      var _offset = subVec3(worldPos2, worldPos1, tempVec4c$1);
      var eyeLookMoveVec = mulVec3Scalar(normalizeVec3(subVec3(camera.look, camera.eye, tempVec3a$2)), -dollyDelta, tempVec3b$2);
      var _moveVec = addVec3(_offset, eyeLookMoveVec, tempVec3c$2);
      camera.eye = [camera.eye[0] - _moveVec[0], camera.eye[1] - _moveVec[1], camera.eye[2] - _moveVec[2]];
      camera.look = [camera.look[0] - _moveVec[0], camera.look[1] - _moveVec[1], camera.look[2] - _moveVec[2]];
    }
    return dolliedThroughSurface;
  };
  _proto.destroy = function destroy() {};
  return PanController;
}();
function _unproject2(canvasPos, worldPos) {
  var camera = this.view.camera;
  var transposedProjectMat = camera.project.transposedProjMatrix;
  // @ts-ignore
  var Pt3 = transposedProjectMat.subarray(8, 12);
  // @ts-ignore
  var Pt4 = transposedProjectMat.subarray(12);
  var D = [0, 0, -1.0, 1];
  var screenZ = dotVec4(D, Pt3) / dotVec4(D, Pt4);
  camera.project.unproject(canvasPos, screenZ, screenPos, viewPos, worldPos);
  return worldPos;
}

var tempVec3a$1 = createVec3();
var tempVec3b$1 = createVec3();
var tempVec3c$1 = createVec3();
var tempVec4a = createVec4();
var tempVec4b = createVec4();
var tempVec4c = createVec4();
/**
 * @private
 */
var _view$8 = /*#__PURE__*/_classPrivateFieldLooseKey("view");
var _configs$1 = /*#__PURE__*/_classPrivateFieldLooseKey("configs");
var _pivotWorldPos = /*#__PURE__*/_classPrivateFieldLooseKey("pivotWorldPos");
var _cameraOffset = /*#__PURE__*/_classPrivateFieldLooseKey("cameraOffset");
var _azimuth = /*#__PURE__*/_classPrivateFieldLooseKey("azimuth");
var _polar = /*#__PURE__*/_classPrivateFieldLooseKey("polar");
var _radius = /*#__PURE__*/_classPrivateFieldLooseKey("radius");
var _pivotPosSet = /*#__PURE__*/_classPrivateFieldLooseKey("pivotPosSet");
var _pivoting = /*#__PURE__*/_classPrivateFieldLooseKey("pivoting");
var _shown = /*#__PURE__*/_classPrivateFieldLooseKey("shown");
var _pivotViewPos = /*#__PURE__*/_classPrivateFieldLooseKey("pivotViewPos");
var _pivotProjPos = /*#__PURE__*/_classPrivateFieldLooseKey("pivotProjPos");
var _pivotCanvasPos = /*#__PURE__*/_classPrivateFieldLooseKey("pivotCanvasPos");
var _cameraDirty = /*#__PURE__*/_classPrivateFieldLooseKey("cameraDirty");
var _onViewMatrix = /*#__PURE__*/_classPrivateFieldLooseKey("onViewMatrix");
var _onProjMatrix = /*#__PURE__*/_classPrivateFieldLooseKey("onProjMatrix");
var _onTick$3 = /*#__PURE__*/_classPrivateFieldLooseKey("onTick");
var _hideTimeout = /*#__PURE__*/_classPrivateFieldLooseKey("hideTimeout");
var _pivotElement = /*#__PURE__*/_classPrivateFieldLooseKey("pivotElement");
var _cameraLookingDownwards = /*#__PURE__*/_classPrivateFieldLooseKey("cameraLookingDownwards");
var PivotController = /*#__PURE__*/function () {
  /**
   * @private
   */
  function PivotController(cameraControl, configs) {
    var _this = this;
    Object.defineProperty(this, _cameraLookingDownwards, {
      value: _cameraLookingDownwards2
    });
    Object.defineProperty(this, _view$8, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _configs$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _pivotWorldPos, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _cameraOffset, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _azimuth, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _polar, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _radius, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _pivotPosSet, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _pivoting, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _shown, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _pivotViewPos, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _pivotProjPos, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _pivotCanvasPos, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _cameraDirty, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _onViewMatrix, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _onProjMatrix, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _onTick$3, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _hideTimeout, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _pivotElement, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _view$8)[_view$8] = cameraControl.view;
    _classPrivateFieldLooseBase(this, _configs$1)[_configs$1] = configs;
    _classPrivateFieldLooseBase(this, _pivotWorldPos)[_pivotWorldPos] = createVec3();
    _classPrivateFieldLooseBase(this, _cameraOffset)[_cameraOffset] = createVec3();
    _classPrivateFieldLooseBase(this, _azimuth)[_azimuth] = 0;
    _classPrivateFieldLooseBase(this, _polar)[_polar] = 0;
    _classPrivateFieldLooseBase(this, _radius)[_radius] = 0;
    _classPrivateFieldLooseBase(this, _pivotPosSet)[_pivotPosSet] = false; // Initially false, true as soon as #pivotWorldPos has been set to some value
    _classPrivateFieldLooseBase(this, _pivoting)[_pivoting] = false; // True while pivoting
    _classPrivateFieldLooseBase(this, _shown)[_shown] = false;
    _classPrivateFieldLooseBase(this, _pivotViewPos)[_pivotViewPos] = createVec4();
    _classPrivateFieldLooseBase(this, _pivotProjPos)[_pivotProjPos] = createVec4();
    _classPrivateFieldLooseBase(this, _pivotViewPos)[_pivotViewPos] = createVec2();
    _classPrivateFieldLooseBase(this, _cameraDirty)[_cameraDirty] = true;
    _classPrivateFieldLooseBase(this, _onViewMatrix)[_onViewMatrix] = _classPrivateFieldLooseBase(this, _view$8)[_view$8].camera.onViewMatrix.subscribe(function () {
      _classPrivateFieldLooseBase(_this, _cameraDirty)[_cameraDirty] = true;
    });
    _classPrivateFieldLooseBase(this, _onProjMatrix)[_onProjMatrix] = _classPrivateFieldLooseBase(this, _view$8)[_view$8].camera.onProjMatrix.subscribe(function () {
      _classPrivateFieldLooseBase(_this, _cameraDirty)[_cameraDirty] = true;
    });
    _classPrivateFieldLooseBase(this, _onTick$3)[_onTick$3] = _classPrivateFieldLooseBase(this, _view$8)[_view$8].viewer.onTick.subscribe(function () {
      _this.updatePivotElement();
    });
  }
  var _proto = PivotController.prototype;
  _proto.updatePivotElement = function updatePivotElement() {
    var camera = _classPrivateFieldLooseBase(this, _view$8)[_view$8].camera;
    var canvasElement = _classPrivateFieldLooseBase(this, _view$8)[_view$8].canvasElement;
    if (_classPrivateFieldLooseBase(this, _pivoting)[_pivoting] && _classPrivateFieldLooseBase(this, _cameraDirty)[_cameraDirty]) {
      transformPoint3(camera.viewMatrix, this.getPivotPos(), _classPrivateFieldLooseBase(this, _pivotViewPos)[_pivotViewPos]);
      _classPrivateFieldLooseBase(this, _pivotViewPos)[_pivotViewPos][3] = 1;
      transformPoint4(camera.projMatrix, _classPrivateFieldLooseBase(this, _pivotViewPos)[_pivotViewPos], _classPrivateFieldLooseBase(this, _pivotProjPos)[_pivotProjPos]);
      var canvasAABB = _classPrivateFieldLooseBase(this, _view$8)[_view$8].boundary;
      var canvasWidth = canvasAABB[2];
      var canvasHeight = canvasAABB[3];
      _classPrivateFieldLooseBase(this, _pivotViewPos)[_pivotViewPos][0] = Math.floor((1 + _classPrivateFieldLooseBase(this, _pivotProjPos)[_pivotProjPos][0] / _classPrivateFieldLooseBase(this, _pivotProjPos)[_pivotProjPos][3]) * canvasWidth / 2);
      _classPrivateFieldLooseBase(this, _pivotViewPos)[_pivotViewPos][1] = Math.floor((1 - _classPrivateFieldLooseBase(this, _pivotProjPos)[_pivotProjPos][1] / _classPrivateFieldLooseBase(this, _pivotProjPos)[_pivotProjPos][3]) * canvasHeight / 2);
      var canvasBoundingRect = canvasElement.getBoundingClientRect();
      if (_classPrivateFieldLooseBase(this, _pivotElement)[_pivotElement]) {
        _classPrivateFieldLooseBase(this, _pivotElement)[_pivotElement].style.left = Math.floor(canvasBoundingRect.left + _classPrivateFieldLooseBase(this, _pivotViewPos)[_pivotViewPos][0]) - _classPrivateFieldLooseBase(this, _pivotElement)[_pivotElement].clientWidth / 2 + window.scrollX + "px";
        _classPrivateFieldLooseBase(this, _pivotElement)[_pivotElement].style.top = Math.floor(canvasBoundingRect.top + _classPrivateFieldLooseBase(this, _pivotViewPos)[_pivotViewPos][1]) - _classPrivateFieldLooseBase(this, _pivotElement)[_pivotElement].clientHeight / 2 + window.scrollY + "px";
      }
      _classPrivateFieldLooseBase(this, _cameraDirty)[_cameraDirty] = false;
    }
  }
  /**
   * Sets the HTML DOM element that will represent the pivot position.
   *
   * @param pivotElement
   */;
  _proto.setPivotElement = function setPivotElement(pivotElement) {
    _classPrivateFieldLooseBase(this, _pivotElement)[_pivotElement] = pivotElement;
  }
  /**
   * Begins pivoting.
   */;
  _proto.startPivot = function startPivot() {
    if (_classPrivateFieldLooseBase(this, _cameraLookingDownwards)[_cameraLookingDownwards]()) {
      _classPrivateFieldLooseBase(this, _pivoting)[_pivoting] = false;
      return false;
    }
    var camera = _classPrivateFieldLooseBase(this, _view$8)[_view$8].camera;
    var lookat = lookAtMat4v(camera.eye, camera.look, camera.worldUp);
    transformPoint3(lookat, this.getPivotPos(), _classPrivateFieldLooseBase(this, _cameraOffset)[_cameraOffset]);
    var pivotPos = this.getPivotPos();
    _classPrivateFieldLooseBase(this, _cameraOffset)[_cameraOffset][2] += distVec3(camera.eye, pivotPos);
    lookat = inverseMat4(lookat);
    var offset = transformVec3(lookat, _classPrivateFieldLooseBase(this, _cameraOffset)[_cameraOffset]);
    var diff = createVec3();
    subVec3(camera.eye, pivotPos, diff);
    addVec3(diff, offset);
    if (camera.zUp) {
      var t = diff[1];
      diff[1] = diff[2];
      diff[2] = t;
    }
    _classPrivateFieldLooseBase(this, _radius)[_radius] = lenVec3(diff);
    _classPrivateFieldLooseBase(this, _polar)[_polar] = Math.acos(diff[1] / _classPrivateFieldLooseBase(this, _radius)[_radius]);
    _classPrivateFieldLooseBase(this, _azimuth)[_azimuth] = Math.atan2(diff[0], diff[2]);
    _classPrivateFieldLooseBase(this, _pivoting)[_pivoting] = true;
  }
  /**
   * Returns true if we are currently pivoting.
   *
   * @returns {boolean}
   */;
  _proto.getPivoting = function getPivoting() {
    return _classPrivateFieldLooseBase(this, _pivoting)[_pivoting];
  }
  /**
   * Sets a 3D World-space position to pivot about.
   *
   * @param worldPos The new World-space pivot position.
   */;
  _proto.setPivotPos = function setPivotPos(worldPos) {
    // @ts-ignore
    _classPrivateFieldLooseBase(this, _pivotWorldPos)[_pivotWorldPos].set(worldPos);
    _classPrivateFieldLooseBase(this, _pivotPosSet)[_pivotPosSet] = true;
  }
  /**
   * Sets the pivot position to the 3D projection of the given 2D canvas coordinates on a sphere centered
   * at the viewpoint. The radius of the sphere is configured via {@link CameraControl#smartPivot}.
   *
   * @param canvasPos
   */;
  _proto.setCanvasPivotPos = function setCanvasPivotPos(canvasPos) {
    var camera = _classPrivateFieldLooseBase(this, _view$8)[_view$8].camera;
    var pivotShereRadius = Math.abs(distVec3(getAABB3Center(_classPrivateFieldLooseBase(this, _view$8)[_view$8].aabb), camera.eye));
    var transposedProjectMat = camera.project.transposedProjMatrix;
    // @ts-ignore
    var Pt3 = transposedProjectMat.subarray(8, 12);
    // @ts-ignore
    var Pt4 = transposedProjectMat.subarray(12);
    var D = [0, 0, -1.0, 1];
    var screenZ = dotVec4(D, Pt3) / dotVec4(D, Pt4);
    var worldPos = tempVec4a;
    camera.project.unproject(canvasPos, screenZ, tempVec4b, tempVec4c, worldPos);
    var eyeWorldPosVec = normalizeVec3(subVec3(worldPos, camera.eye, tempVec3a$1));
    var posOnSphere = addVec3(camera.eye, mulVec3Scalar(eyeWorldPosVec, pivotShereRadius, tempVec3b$1), tempVec3c$1);
    this.setPivotPos(posOnSphere);
  }
  /**
   * Gets the current position we're pivoting about.
   * @returns {Number[]} The current World-space pivot position.
   */;
  _proto.getPivotPos = function getPivotPos() {
    return _classPrivateFieldLooseBase(this, _pivotPosSet)[_pivotPosSet] ? _classPrivateFieldLooseBase(this, _pivotWorldPos)[_pivotWorldPos] : _classPrivateFieldLooseBase(this, _view$8)[_view$8].camera.look; // Avoid pivoting about [0,0,0] by default
  }
  /**
   * Continues to pivot.
   *
   * @param yawInc Yaw rotation increment.
   * @param pitchInc Pitch rotation increment.
   */;
  _proto.continuePivot = function continuePivot(yawInc, pitchInc) {
    if (!_classPrivateFieldLooseBase(this, _pivoting)[_pivoting]) {
      return;
    }
    if (yawInc === 0 && pitchInc === 0) {
      return;
    }
    var camera = _classPrivateFieldLooseBase(this, _view$8)[_view$8].camera;
    var dx = -yawInc;
    var dy = -pitchInc;
    if (camera.worldUp[2] === 1) {
      dx = -dx;
    }
    _classPrivateFieldLooseBase(this, _azimuth)[_azimuth] += -dx * .01;
    _classPrivateFieldLooseBase(this, _polar)[_polar] += dy * .01;
    _classPrivateFieldLooseBase(this, _polar)[_polar] = clamp(_classPrivateFieldLooseBase(this, _polar)[_polar], .001, Math.PI - .001);
    var pos = [_classPrivateFieldLooseBase(this, _radius)[_radius] * Math.sin(_classPrivateFieldLooseBase(this, _polar)[_polar]) * Math.sin(_classPrivateFieldLooseBase(this, _azimuth)[_azimuth]), _classPrivateFieldLooseBase(this, _radius)[_radius] * Math.cos(_classPrivateFieldLooseBase(this, _polar)[_polar]), _classPrivateFieldLooseBase(this, _radius)[_radius] * Math.sin(_classPrivateFieldLooseBase(this, _polar)[_polar]) * Math.cos(_classPrivateFieldLooseBase(this, _azimuth)[_azimuth])];
    if (camera.worldUp[2] === 1) {
      var t = pos[1];
      pos[1] = pos[2];
      pos[2] = t;
    }
    // Preserve the eye->look distance, since in xeokit "look" is the point-of-interest, not the direction vector.
    var eyeLookLen = lenVec3(subVec3(camera.look, camera.eye, createVec3()));
    var pivotPos = this.getPivotPos();
    addVec3(pos, pivotPos);
    var lookat = lookAtMat4v(pos, pivotPos, camera.worldUp);
    lookat = inverseMat4(lookat);
    var offset = transformVec3(lookat, _classPrivateFieldLooseBase(this, _cameraOffset)[_cameraOffset]);
    lookat[12] -= offset[0];
    lookat[13] -= offset[1];
    lookat[14] -= offset[2];
    var zAxis = [lookat[8], lookat[9], lookat[10]];
    camera.eye = [lookat[12], lookat[13], lookat[14]];
    subVec3(camera.eye, mulVec3Scalar(zAxis, eyeLookLen), camera.look);
    camera.up = [lookat[4], lookat[5], lookat[6]];
    this.showPivot();
  }
  /**
   * Shows the pivot position.
   *
   * Only works if we set an  HTML DOM element to represent the pivot position.
   */;
  _proto.showPivot = function showPivot() {
    var _this2 = this;
    if (_classPrivateFieldLooseBase(this, _shown)[_shown]) {
      return;
    }
    if (_classPrivateFieldLooseBase(this, _hideTimeout)[_hideTimeout] !== null) {
      window.clearTimeout(_classPrivateFieldLooseBase(this, _hideTimeout)[_hideTimeout]);
      _classPrivateFieldLooseBase(this, _hideTimeout)[_hideTimeout] = null;
    }
    if (_classPrivateFieldLooseBase(this, _pivotElement)[_pivotElement]) {
      this.updatePivotElement();
      _classPrivateFieldLooseBase(this, _pivotElement)[_pivotElement].style.visibility = "visible";
      _classPrivateFieldLooseBase(this, _shown)[_shown] = true;
      _classPrivateFieldLooseBase(this, _hideTimeout)[_hideTimeout] = window.setTimeout(function () {
        _this2.hidePivot();
      }, 1000);
    }
  }
  /**
   * Hides the pivot position.
   *
   * Only works if we set an  HTML DOM element to represent the pivot position.
   */;
  _proto.hidePivot = function hidePivot() {
    if (!_classPrivateFieldLooseBase(this, _shown)[_shown]) {
      return;
    }
    if (_classPrivateFieldLooseBase(this, _hideTimeout)[_hideTimeout] !== null) {
      window.clearTimeout(_classPrivateFieldLooseBase(this, _hideTimeout)[_hideTimeout]);
      _classPrivateFieldLooseBase(this, _hideTimeout)[_hideTimeout] = null;
    }
    if (_classPrivateFieldLooseBase(this, _pivotElement)[_pivotElement]) {
      _classPrivateFieldLooseBase(this, _pivotElement)[_pivotElement].style.visibility = "hidden";
    }
    _classPrivateFieldLooseBase(this, _shown)[_shown] = false;
  }
  /**
   * Finishes pivoting.
   */;
  _proto.endPivot = function endPivot() {
    _classPrivateFieldLooseBase(this, _pivoting)[_pivoting] = false;
  };
  _proto.destroy = function destroy() {
    _classPrivateFieldLooseBase(this, _view$8)[_view$8].camera.onViewMatrix.unsubscribe(_classPrivateFieldLooseBase(this, _onViewMatrix)[_onViewMatrix]);
    _classPrivateFieldLooseBase(this, _view$8)[_view$8].camera.onProjMatrix.unsubscribe(_classPrivateFieldLooseBase(this, _onProjMatrix)[_onProjMatrix]);
    _classPrivateFieldLooseBase(this, _view$8)[_view$8].viewer.onTick.unsubscribe(_classPrivateFieldLooseBase(this, _onTick$3)[_onTick$3]);
  };
  return PivotController;
}();
function _cameraLookingDownwards2() {
  var camera = _classPrivateFieldLooseBase(this, _view$8)[_view$8].camera;
  var forwardAxis = normalizeVec3(subVec3(camera.look, camera.eye, tempVec3a$1));
  var rightAxis = cross3Vec3(forwardAxis, camera.worldUp, tempVec3b$1);
  var rightAxisLen = sqLenVec3(rightAxis);
  return rightAxisLen <= 0.0001;
}

/**
 * @private
 */
var _view$7 = /*#__PURE__*/_classPrivateFieldLooseKey("view");
var _cameraControl = /*#__PURE__*/_classPrivateFieldLooseKey("cameraControl");
var _config = /*#__PURE__*/_classPrivateFieldLooseKey("config");
var _lastPickedobjectId$1 = /*#__PURE__*/_classPrivateFieldLooseKey("lastPickedobjectId");
var _needFireEvents = /*#__PURE__*/_classPrivateFieldLooseKey("needFireEvents");
var PickController = /*#__PURE__*/function () {
  function PickController(cameraControl, configs) {
    /**
     * Set true to schedule picking of an Entity.
     */
    this.schedulePickEntity = void 0;
    /**
     * Set true to schedule picking of a position on teh surface of an Entity.
     */
    this.schedulePickSurface = void 0;
    /**
     * The canvas position at which to do the next scheduled pick.
     */
    this.pickCursorPos = void 0;
    /**
     * Will be true after picking to indicate that something was picked.
     */
    this.picked = void 0;
    /**
     * Will be true after picking to indicate that a position on the surface of an Entity was picked.
     */
    this.pickedSurface = void 0;
    /**
     * Will hold the PickResult after after picking.
     */
    this.pickResult = void 0;
    Object.defineProperty(this, _view$7, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _cameraControl, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _config, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _lastPickedobjectId$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _needFireEvents, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _view$7)[_view$7] = cameraControl.view;
    _classPrivateFieldLooseBase(this, _cameraControl)[_cameraControl] = cameraControl;
    _classPrivateFieldLooseBase(this, _view$7)[_view$7].canvasElement.oncontextmenu = function (e) {
      e.preventDefault();
    };
    _classPrivateFieldLooseBase(this, _config)[_config] = configs;
    this.schedulePickEntity = false;
    this.schedulePickSurface = false;
    this.pickCursorPos = createVec2();
    this.picked = false;
    this.pickedSurface = false;
    this.pickResult = null;
    _classPrivateFieldLooseBase(this, _lastPickedobjectId$1)[_lastPickedobjectId$1] = null;
    _classPrivateFieldLooseBase(this, _needFireEvents)[_needFireEvents] = false;
  }
  /**
   * Immediately attempts a pick, if scheduled.
   */
  var _proto = PickController.prototype;
  _proto.update = function update() {
    if (!_classPrivateFieldLooseBase(this, _config)[_config].pointerEnabled) {
      return;
    }
    if (!this.schedulePickEntity && !this.schedulePickSurface) {
      return;
    }
    this.picked = false;
    this.pickedSurface = false;
    _classPrivateFieldLooseBase(this, _needFireEvents)[_needFireEvents] = false;
    var hasHoverSurfaceSubs = _classPrivateFieldLooseBase(this, _cameraControl)[_cameraControl].onHoverSurface.count > 0;
    if (this.schedulePickSurface) {
      // @ts-ignore
      if (this.pickResult && this.pickResult.worldPos) {
        var pickResultViewPos = this.pickResult.canvasPos;
        if (pickResultViewPos[0] === this.pickCursorPos[0] && pickResultViewPos[1] === this.pickCursorPos[1]) {
          this.picked = true;
          this.pickedSurface = true;
          _classPrivateFieldLooseBase(this, _needFireEvents)[_needFireEvents] = hasHoverSurfaceSubs;
          this.schedulePickEntity = false;
          this.schedulePickSurface = false;
          return;
        }
      }
    }
    if (this.schedulePickEntity) {
      if (this.pickResult) {
        var _pickResultViewPos = this.pickResult.canvasPos;
        if (_pickResultViewPos[0] === this.pickCursorPos[0] && _pickResultViewPos[1] === this.pickCursorPos[1]) {
          this.picked = true;
          this.pickedSurface = false;
          _classPrivateFieldLooseBase(this, _needFireEvents)[_needFireEvents] = false;
          this.schedulePickEntity = false;
          this.schedulePickSurface = false;
          return;
        }
      }
    }
    // if (this.schedulePickSurface) {
    //
    //     this.pickResult = this.#view.pick({
    //         pickSurface: true,
    //         pickSurfaceNormal: false,
    //         canvasPos: this.pickCursorPos
    //     });
    //
    //     if (this.pickResult) {
    //         this.picked = true;
    //         this.pickedSurface = true;
    //         this.#needFireEvents = true;
    //     }
    //
    // } else { // schedulePickEntity == true
    //
    //     this.pickResult = this.#view.pick({
    //         canvasPos: this.pickCursorPos
    //     });
    //
    //     if (this.pickResult) {
    //         this.picked = true;
    //         this.pickedSurface = false;
    //         this.#needFireEvents = true;
    //     }
    // }
    this.schedulePickEntity = false;
    this.schedulePickSurface = false;
  };
  _proto.fireEvents = function fireEvents() {
    if (!_classPrivateFieldLooseBase(this, _needFireEvents)[_needFireEvents]) {
      return;
    }
    if (this.picked && this.pickResult && this.pickResult.entity) {
      var pickedobjectId = this.pickResult.entity.id;
      if (_classPrivateFieldLooseBase(this, _lastPickedobjectId$1)[_lastPickedobjectId$1] !== pickedobjectId) {
        if (_classPrivateFieldLooseBase(this, _lastPickedobjectId$1)[_lastPickedobjectId$1] !== undefined && _classPrivateFieldLooseBase(this, _lastPickedobjectId$1)[_lastPickedobjectId$1] !== null) {
          _classPrivateFieldLooseBase(this, _cameraControl)[_cameraControl].onHoverOut.dispatch(_classPrivateFieldLooseBase(this, _cameraControl)[_cameraControl], {
            entity: _classPrivateFieldLooseBase(this, _view$7)[_view$7].objects[_classPrivateFieldLooseBase(this, _lastPickedobjectId$1)[_lastPickedobjectId$1]]
          });
        }
        _classPrivateFieldLooseBase(this, _cameraControl)[_cameraControl].onHoverOut.dispatch(_classPrivateFieldLooseBase(this, _cameraControl)[_cameraControl], this.pickResult);
        _classPrivateFieldLooseBase(this, _lastPickedobjectId$1)[_lastPickedobjectId$1] = pickedobjectId;
      }
      _classPrivateFieldLooseBase(this, _cameraControl)[_cameraControl].onHover.dispatch(_classPrivateFieldLooseBase(this, _cameraControl)[_cameraControl], this.pickResult);
      if (this.pickResult.worldPos) {
        this.pickedSurface = true;
        _classPrivateFieldLooseBase(this, _cameraControl)[_cameraControl].onHoverSurface.dispatch(_classPrivateFieldLooseBase(this, _cameraControl)[_cameraControl], this.pickResult);
      }
    } else {
      if (_classPrivateFieldLooseBase(this, _lastPickedobjectId$1)[_lastPickedobjectId$1] !== undefined && _classPrivateFieldLooseBase(this, _lastPickedobjectId$1)[_lastPickedobjectId$1] !== null) {
        _classPrivateFieldLooseBase(this, _cameraControl)[_cameraControl].onHoverOut.dispatch(_classPrivateFieldLooseBase(this, _cameraControl)[_cameraControl], {
          entity: _classPrivateFieldLooseBase(this, _view$7)[_view$7].objects[_classPrivateFieldLooseBase(this, _lastPickedobjectId$1)[_lastPickedobjectId$1]]
        });
        _classPrivateFieldLooseBase(this, _lastPickedobjectId$1)[_lastPickedobjectId$1] = undefined;
      }
      _classPrivateFieldLooseBase(this, _cameraControl)[_cameraControl].onHoverOff.dispatch(_classPrivateFieldLooseBase(this, _cameraControl)[_cameraControl], {
        canvasPos: this.pickCursorPos
      });
    }
    this.pickResult = null;
    _classPrivateFieldLooseBase(this, _needFireEvents)[_needFireEvents] = false;
  };
  _proto.destroy = function destroy() {};
  return PickController;
}();

/**
 * Code for the BACKSPACE key.
 */
var KEY_BACKSPACE = 8;
/**
 * Code for the TAB key.
 */
var KEY_TAB = 9;
/**
 * Code for the ENTER key.
 */
var KEY_ENTER = 13;
/**
 * Code for the SHIFT key.
 */
var KEY_SHIFT = 16;
/**
 * Code for the CTRL key.
 */
var KEY_CTRL = 17;
/**
 * Code for the ALT key.
 */
var KEY_ALT = 18;
/**
 * Code for the PAUSE_BREAK key.
 */
var KEY_PAUSE_BREAK = 19;
/**
 * Code for the CAPS_LOCK key.
 */
var KEY_CAPS_LOCK = 20;
/**
 * Code for the ESCAPE key.
 */
var KEY_ESCAPE = 27;
/**
 * Code for the PAGE_UP key.
 */
var KEY_PAGE_UP = 33;
/**
 * Code for the PAGE_DOWN key.
 */
var KEY_PAGE_DOWN = 34;
/**
 * Code for the END key.
 */
var KEY_END = 35;
/**
 * Code for the HOME key.
 */
var KEY_HOME = 36;
/**
 * Code for the LEFT_ARROW key.
 */
var KEY_LEFT_ARROW = 37;
/**
 * Code for the UP_ARROW key.

 */
var KEY_UP_ARROW = 38;
/**
 * Code for the RIGHT_ARROW key.
 */
var KEY_RIGHT_ARROW = 39;
/**
 * Code for the DOWN_ARROW key.
 */
var KEY_DOWN_ARROW = 40;
/**
 * Code for the INSERT key.
 */
var KEY_INSERT = 45;
/**
 * Code for the DELETE key.
 */
var KEY_DELETE = 46;
/**
 * Code for the 0 key.
 */
var KEY_NUM_0 = 48;
/**
 * Code for the 1 key.
 */
var KEY_NUM_1 = 49;
/**
 * Code for the 2 key.
 */
var KEY_NUM_2 = 50;
/**
 * Code for the 3 key.
 */
var KEY_NUM_3 = 51;
/**
 * Code for the 4 key.
 */
var KEY_NUM_4 = 52;
/**
 * Code for the 5 key.
 */
var KEY_NUM_5 = 53;
/**
 * Code for the 6 key.
 */
var KEY_NUM_6 = 54;
/**
 * Code for the 7 key.
 */
var KEY_NUM_7 = 55;
/**
 * Code for the 8 key.
 */
var KEY_NUM_8 = 56;
/**
 * Code for the 9 key.
 */
var KEY_NUM_9 = 57;
/**
 * Code for the A key.
 */
var KEY_A = 65;
/**
 * Code for the B key.
 */
var KEY_B = 66;
/**
 * Code for the C key.
 */
var KEY_C = 67;
/**
 * Code for the D key.
 */
var KEY_D = 68;
/**
 * Code for the E key.
 */
var KEY_E = 69;
/**
 * Code for the F key.
 */
var KEY_F = 70;
/**
 * Code for the G key.
 */
var KEY_G = 71;
/**
 * Code for the H key.
 */
var KEY_H = 72;
/**
 * Code for the I key.
 */
var KEY_I = 73;
/**
 * Code for the J key.
 */
var KEY_J = 74;
/**
 * Code for the K key.
 */
var KEY_K = 75;
/**
 * Code for the L key.
 */
var KEY_L = 76;
/**
 * Code for the M key.
 */
var KEY_M = 77;
/**
 * Code for the N key.
 */
var KEY_N = 78;
/**
 * Code for the O key.
 */
var KEY_O = 79;
/**
 * Code for the P key.
 */
var KEY_P = 80;
/**
 * Code for the Q key.
 */
var KEY_Q = 81;
/**
 * Code for the R key.
 */
var KEY_R = 82;
/**
 * Code for the S key.
 */
var KEY_S = 83;
/**
 * Code for the T key.
 */
var KEY_T = 84;
/**
 * Code for the U key.
 */
var KEY_U = 85;
/**
 * Code for the V key.
 */
var KEY_V = 86;
/**
 * Code for the W key.
 */
var KEY_W = 87;
/**
 * Code for the X key.
 */
var KEY_X = 88;
/**
 * Code for the Y key.
 */
var KEY_Y = 89;
/**
 * Code for the Z key.
 */
var KEY_Z = 90;
/**
 * Code for the LEFT_WINDOW key.
 */
var KEY_LEFT_WINDOW = 91;
/**
 * Code for the RIGHT_WINDOW key.
 */
var KEY_RIGHT_WINDOW = 92;
/**
 * Code for the SELECT key.
 */
var KEY_SELECT_KEY = 93;
/**
 * Code for the number pad 0 key.
 */
var KEY_NUMPAD_0 = 96;
/**
 * Code for the number pad 1 key.
 */
var KEY_NUMPAD_1 = 97;
/**
 * Code for the number pad 2 key.
 */
var KEY_NUMPAD_2 = 98;
/**
 * Code for the number pad 3 key.
 */
var KEY_NUMPAD_3 = 99;
/**
 * Code for the number pad 4 key.
 */
var KEY_NUMPAD_4 = 100;
/**
 * Code for the number pad 5 key.
 */
var KEY_NUMPAD_5 = 101;
/**
 * Code for the number pad 6 key.
 */
var KEY_NUMPAD_6 = 102;
/**
 * Code for the number pad 7 key.
 */
var KEY_NUMPAD_7 = 103;
/**
 * Code for the number pad 8 key.
 */
var KEY_NUMPAD_8 = 104;
/**
 * Code for the number pad 9 key.
 */
var KEY_NUMPAD_9 = 105;
/**
 * Code for the MULTIPLY key.
 */
var KEY_MULTIPLY = 106;
/**
 * Code for the ADD key.
 */
var KEY_ADD = 107;
/**
 * Code for the SUBTRACT key.
 */
var KEY_SUBTRACT = 109;
/**
 * Code for the DECIMAL POINT key.
 */
var KEY_DECIMAL_POINT = 110;
/**
 * Code for the DIVIDE key.
 */
var KEY_DIVIDE = 111;
/**
 * Code for the F1 key.
 */
var KEY_F1 = 112;
/**
 * Code for the F2 key.
 */
var KEY_F2 = 113;
/**
 * Code for the F3 key.
 */
var KEY_F3 = 114;
/**
 * Code for the F4 key.
 */
var KEY_F4 = 115;
/**
 * Code for the F5 key.
 */
var KEY_F5 = 116;
/**
 * Code for the F6 key.
 */
var KEY_F6 = 117;
/**
 * Code for the F7 key.
 */
var KEY_F7 = 118;
/**
 * Code for the F8 key.
 */
var KEY_F8 = 119;
/**
 * Code for the F9 key.
 */
var KEY_F9 = 120;
/**
 * Code for the F10 key.
 */
var KEY_F10 = 121;
/**
 * Code for the F11 key.
 */
var KEY_F11 = 122;
/**
 * Code for the F12 key.
 */
var KEY_F12 = 123;
/**
 * Code for the NUM_LOCK key.
 */
var KEY_NUM_LOCK = 144;
/**
 * Code for the SCROLL_LOCK key.
 */
var KEY_SCROLL_LOCK = 145;
/**
 * Code for the SEMI_COLON key.
 */
var KEY_SEMI_COLON = 186;
/**
 * Code for the EQUAL_SIGN key.
 */
var KEY_EQUAL_SIGN = 187;
/**
 * Code for the COMMA key.
 */
var KEY_COMMA = 188;
/**
 * Code for the DASH key.
 */
var KEY_DASH = 189;
/**
 * Code for the PERIOD key.
 */
var KEY_PERIOD = 190;
/**
 * Code for the FORWARD_SLASH key.
 */
var KEY_FORWARD_SLASH = 191;
/**
 * Code for the GRAVE_ACCENT key.
 */
var KEY_GRAVE_ACCENT = 192;
/**
 * Code for the OPEN_BRACKET key.
 */
var KEY_OPEN_BRACKET = 219;
/**
 * Code for the BACK_SLASH key.
 */
var KEY_BACK_SLASH = 220;
/**
 * Code for the CLOSE_BRACKET key.
 */
var KEY_CLOSE_BRACKET = 221;
/**
 * Code for the SINGLE_QUOTE key.
 */
var KEY_SINGLE_QUOTE = 222;
/**
 * Code for the SPACE key.
 */
var KEY_SPACE = 32;

var keycodes = {
  __proto__: null,
  KEY_BACKSPACE: KEY_BACKSPACE,
  KEY_TAB: KEY_TAB,
  KEY_ENTER: KEY_ENTER,
  KEY_SHIFT: KEY_SHIFT,
  KEY_CTRL: KEY_CTRL,
  KEY_ALT: KEY_ALT,
  KEY_PAUSE_BREAK: KEY_PAUSE_BREAK,
  KEY_CAPS_LOCK: KEY_CAPS_LOCK,
  KEY_ESCAPE: KEY_ESCAPE,
  KEY_PAGE_UP: KEY_PAGE_UP,
  KEY_PAGE_DOWN: KEY_PAGE_DOWN,
  KEY_END: KEY_END,
  KEY_HOME: KEY_HOME,
  KEY_LEFT_ARROW: KEY_LEFT_ARROW,
  KEY_UP_ARROW: KEY_UP_ARROW,
  KEY_RIGHT_ARROW: KEY_RIGHT_ARROW,
  KEY_DOWN_ARROW: KEY_DOWN_ARROW,
  KEY_INSERT: KEY_INSERT,
  KEY_DELETE: KEY_DELETE,
  KEY_NUM_0: KEY_NUM_0,
  KEY_NUM_1: KEY_NUM_1,
  KEY_NUM_2: KEY_NUM_2,
  KEY_NUM_3: KEY_NUM_3,
  KEY_NUM_4: KEY_NUM_4,
  KEY_NUM_5: KEY_NUM_5,
  KEY_NUM_6: KEY_NUM_6,
  KEY_NUM_7: KEY_NUM_7,
  KEY_NUM_8: KEY_NUM_8,
  KEY_NUM_9: KEY_NUM_9,
  KEY_A: KEY_A,
  KEY_B: KEY_B,
  KEY_C: KEY_C,
  KEY_D: KEY_D,
  KEY_E: KEY_E,
  KEY_F: KEY_F,
  KEY_G: KEY_G,
  KEY_H: KEY_H,
  KEY_I: KEY_I,
  KEY_J: KEY_J,
  KEY_K: KEY_K,
  KEY_L: KEY_L,
  KEY_M: KEY_M,
  KEY_N: KEY_N,
  KEY_O: KEY_O,
  KEY_P: KEY_P,
  KEY_Q: KEY_Q,
  KEY_R: KEY_R,
  KEY_S: KEY_S,
  KEY_T: KEY_T,
  KEY_U: KEY_U,
  KEY_V: KEY_V,
  KEY_W: KEY_W,
  KEY_X: KEY_X,
  KEY_Y: KEY_Y,
  KEY_Z: KEY_Z,
  KEY_LEFT_WINDOW: KEY_LEFT_WINDOW,
  KEY_RIGHT_WINDOW: KEY_RIGHT_WINDOW,
  KEY_SELECT_KEY: KEY_SELECT_KEY,
  KEY_NUMPAD_0: KEY_NUMPAD_0,
  KEY_NUMPAD_1: KEY_NUMPAD_1,
  KEY_NUMPAD_2: KEY_NUMPAD_2,
  KEY_NUMPAD_3: KEY_NUMPAD_3,
  KEY_NUMPAD_4: KEY_NUMPAD_4,
  KEY_NUMPAD_5: KEY_NUMPAD_5,
  KEY_NUMPAD_6: KEY_NUMPAD_6,
  KEY_NUMPAD_7: KEY_NUMPAD_7,
  KEY_NUMPAD_8: KEY_NUMPAD_8,
  KEY_NUMPAD_9: KEY_NUMPAD_9,
  KEY_MULTIPLY: KEY_MULTIPLY,
  KEY_ADD: KEY_ADD,
  KEY_SUBTRACT: KEY_SUBTRACT,
  KEY_DECIMAL_POINT: KEY_DECIMAL_POINT,
  KEY_DIVIDE: KEY_DIVIDE,
  KEY_F1: KEY_F1,
  KEY_F2: KEY_F2,
  KEY_F3: KEY_F3,
  KEY_F4: KEY_F4,
  KEY_F5: KEY_F5,
  KEY_F6: KEY_F6,
  KEY_F7: KEY_F7,
  KEY_F8: KEY_F8,
  KEY_F9: KEY_F9,
  KEY_F10: KEY_F10,
  KEY_F11: KEY_F11,
  KEY_F12: KEY_F12,
  KEY_NUM_LOCK: KEY_NUM_LOCK,
  KEY_SCROLL_LOCK: KEY_SCROLL_LOCK,
  KEY_SEMI_COLON: KEY_SEMI_COLON,
  KEY_EQUAL_SIGN: KEY_EQUAL_SIGN,
  KEY_COMMA: KEY_COMMA,
  KEY_DASH: KEY_DASH,
  KEY_PERIOD: KEY_PERIOD,
  KEY_FORWARD_SLASH: KEY_FORWARD_SLASH,
  KEY_GRAVE_ACCENT: KEY_GRAVE_ACCENT,
  KEY_OPEN_BRACKET: KEY_OPEN_BRACKET,
  KEY_BACK_SLASH: KEY_BACK_SLASH,
  KEY_CLOSE_BRACKET: KEY_CLOSE_BRACKET,
  KEY_SINGLE_QUOTE: KEY_SINGLE_QUOTE,
  KEY_SPACE: KEY_SPACE
};

var canvasPos = createVec2();
/**
 * @private
 */
var _view$6 = /*#__PURE__*/_classPrivateFieldLooseKey("view");
var _documentKeyDownHandler$2 = /*#__PURE__*/_classPrivateFieldLooseKey("documentKeyDownHandler");
var _documentKeyUpHandler$1 = /*#__PURE__*/_classPrivateFieldLooseKey("documentKeyUpHandler");
var _mouseDownHandler$1 = /*#__PURE__*/_classPrivateFieldLooseKey("mouseDownHandler");
var _documentMouseMoveHandler$1 = /*#__PURE__*/_classPrivateFieldLooseKey("documentMouseMoveHandler");
var _canvasMouseMoveHandler$1 = /*#__PURE__*/_classPrivateFieldLooseKey("canvasMouseMoveHandler");
var _documentMouseUpHandler$1 = /*#__PURE__*/_classPrivateFieldLooseKey("documentMouseUpHandler");
var _mouseUpHandler$1 = /*#__PURE__*/_classPrivateFieldLooseKey("mouseUpHandler");
var _mouseEnterHandler$1 = /*#__PURE__*/_classPrivateFieldLooseKey("mouseEnterHandler");
var _mouseWheelHandler = /*#__PURE__*/_classPrivateFieldLooseKey("mouseWheelHandler");
var MousePanRotateDollyHandler = /*#__PURE__*/function () {
  function MousePanRotateDollyHandler(components, controllers, configs, states, updates) {
    var _this = this;
    Object.defineProperty(this, _view$6, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _documentKeyDownHandler$2, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _documentKeyUpHandler$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _mouseDownHandler$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _documentMouseMoveHandler$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _canvasMouseMoveHandler$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _documentMouseUpHandler$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _mouseUpHandler$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _mouseEnterHandler$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _mouseWheelHandler, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _view$6)[_view$6] = components.view;
    var pickController = controllers.pickController;
    var lastX = 0;
    var lastY = 0;
    var lastXDown = 0;
    var lastYDown = 0;
    var mouseDownLeft;
    var mouseDownMiddle;
    var mouseDownRight;
    var mouseDownPicked = false;
    var pickedWorldPos = new Float64Array(3);
    var mouseMovedOnViewSinceLastWheel = true;
    var canvasElement = _classPrivateFieldLooseBase(this, _view$6)[_view$6].canvasElement;
    var keyDown = [];
    document.addEventListener("keydown", _classPrivateFieldLooseBase(this, _documentKeyDownHandler$2)[_documentKeyDownHandler$2] = function (e) {
      if (!(configs.active && configs.pointerEnabled) || !configs.keyboardEnabled) {
        return;
      }
      var keyCode = e.keyCode;
      keyDown[keyCode] = true;
    });
    document.addEventListener("keyup", _classPrivateFieldLooseBase(this, _documentKeyUpHandler$1)[_documentKeyUpHandler$1] = function (e) {
      if (!(configs.active && configs.pointerEnabled) || !configs.keyboardEnabled) {
        return;
      }
      var keyCode = e.keyCode;
      keyDown[keyCode] = false;
    });
    function setMousedownState(pick) {
      if (pick === void 0) {
        pick = true;
      }
      canvasElement.style.cursor = "move";
      setMousedownPositions();
      if (pick) {
        setMousedownPick();
      }
    }
    function setMousedownPositions() {
      lastX = states.pointerViewPos[0];
      lastY = states.pointerViewPos[1];
      lastXDown = states.pointerViewPos[0];
      lastYDown = states.pointerViewPos[1];
    }
    function setMousedownPick() {
      pickController.pickCursorPos = states.pointerViewPos;
      pickController.schedulePickSurface = true;
      pickController.update();
      if (pickController.picked && pickController.pickedSurface && pickController.pickResult && pickController.pickResult.worldPos) {
        mouseDownPicked = true;
        pickedWorldPos.set(pickController.pickResult.worldPos);
      } else {
        mouseDownPicked = false;
      }
    }
    canvasElement.addEventListener("mousedown", _classPrivateFieldLooseBase(this, _mouseDownHandler$1)[_mouseDownHandler$1] = function (e) {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      switch (e.which) {
        case 1:
          // Left button
          if (keyDown[KEY_SHIFT] || configs.planView) {
            mouseDownLeft = true;
            setMousedownState();
          } else {
            mouseDownLeft = true;
            setMousedownState(false);
          }
          break;
        case 2:
          // Middle/both buttons
          mouseDownMiddle = true;
          setMousedownState();
          break;
        case 3:
          // Right button
          mouseDownRight = true;
          if (configs.panRightClick) {
            setMousedownState();
          }
          break;
      }
    });
    document.addEventListener("mousemove", _classPrivateFieldLooseBase(this, _documentMouseMoveHandler$1)[_documentMouseMoveHandler$1] = function () {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      if (!mouseDownLeft && !mouseDownMiddle && !mouseDownRight) {
        return;
      }
      // Scaling drag-rotate to canvas boundary
      var canvasBoundary = _classPrivateFieldLooseBase(_this, _view$6)[_view$6].boundary;
      var canvasWidth = canvasBoundary[0];
      var canvasHeight = canvasBoundary[1];
      var x = states.pointerViewPos[0];
      var y = states.pointerViewPos[1];
      var panning = keyDown[KEY_SHIFT] || configs.planView || !configs.panRightClick && mouseDownMiddle || configs.panRightClick && mouseDownRight;
      if (panning) {
        var xPanDelta = x - lastX;
        var yPanDelta = y - lastY;
        var camera = _classPrivateFieldLooseBase(_this, _view$6)[_view$6].camera;
        // We use only canvasHeight here so that aspect ratio does not distort speed
        if (camera.projectionType === PerspectiveProjectionType) {
          var depth = Math.abs(mouseDownPicked ? lenVec3(subVec3(pickedWorldPos, _classPrivateFieldLooseBase(_this, _view$6)[_view$6].camera.eye, [])) : _classPrivateFieldLooseBase(_this, _view$6)[_view$6].camera.eyeLookDist);
          var targetDistance = depth * Math.tan(camera.perspectiveProjection.fov / 2 * Math.PI / 180.0);
          updates.panDeltaX += 1.5 * xPanDelta * targetDistance / canvasHeight;
          updates.panDeltaY += 1.5 * yPanDelta * targetDistance / canvasHeight;
        } else {
          updates.panDeltaX += 0.5 * camera.orthoProjection.scale * (xPanDelta / canvasHeight);
          updates.panDeltaY += 0.5 * camera.orthoProjection.scale * (yPanDelta / canvasHeight);
        }
      } else if (mouseDownLeft && !mouseDownMiddle && !mouseDownRight) {
        if (!configs.planView) {
          // No rotating in plan-view mode
          if (configs.firstPerson) {
            updates.rotateDeltaY -= (x - lastX) / canvasWidth * configs.dragRotationRate / 2;
            updates.rotateDeltaX += (y - lastY) / canvasHeight * (configs.dragRotationRate / 4);
          } else {
            updates.rotateDeltaY -= (x - lastX) / canvasWidth * (configs.dragRotationRate * 1.5);
            updates.rotateDeltaX += (y - lastY) / canvasHeight * (configs.dragRotationRate * 1.5);
          }
        }
      }
      lastX = x;
      lastY = y;
    });
    canvasElement.addEventListener("mousemove", _classPrivateFieldLooseBase(this, _canvasMouseMoveHandler$1)[_canvasMouseMoveHandler$1] = function (e) {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      if (!states.mouseover) {
        return;
      }
      mouseMovedOnViewSinceLastWheel = true;
    });
    document.addEventListener("mouseup", _classPrivateFieldLooseBase(this, _documentMouseUpHandler$1)[_documentMouseUpHandler$1] = function (e) {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      switch (e.which) {
        case 1:
          // Left button
          mouseDownLeft = false;
          mouseDownMiddle = false;
          mouseDownRight = false;
          break;
        case 2:
          // Middle/both buttons
          mouseDownLeft = false;
          mouseDownMiddle = false;
          mouseDownRight = false;
          break;
        case 3:
          // Right button
          mouseDownLeft = false;
          mouseDownMiddle = false;
          mouseDownRight = false;
          break;
      }
    });
    canvasElement.addEventListener("mouseup", _classPrivateFieldLooseBase(this, _mouseUpHandler$1)[_mouseUpHandler$1] = function (e) {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      switch (e.which) {
        case 3:
          // Right button
          getViewPosFromEvent$1(e, canvasPos);
          var x = canvasPos[0];
          var y = canvasPos[1];
          if (Math.abs(x - lastXDown) < 3 && Math.abs(y - lastYDown) < 3) {
            controllers.cameraControl.events.fire("rightClick", {
              pagePos: [Math.round(e.pageX), Math.round(e.pageY)],
              canvasPos: canvasPos,
              event: e
            }, true);
          }
          break;
      }
      canvasElement.style.removeProperty("cursor");
    });
    canvasElement.addEventListener("mouseenter", _classPrivateFieldLooseBase(this, _mouseEnterHandler$1)[_mouseEnterHandler$1] = function () {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
    });
    var maxElapsed = 1 / 20;
    var minElapsed = 1 / 60;
    var secsNowLast = null;
    canvasElement.addEventListener("wheel", _classPrivateFieldLooseBase(this, _mouseWheelHandler)[_mouseWheelHandler] = function (e) {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      var secsNow = performance.now() / 1000.0;
      var secsElapsed = secsNowLast !== null ? secsNow - secsNowLast : 0;
      secsNowLast = secsNow;
      if (secsElapsed > maxElapsed) {
        secsElapsed = maxElapsed;
      }
      if (secsElapsed < minElapsed) {
        secsElapsed = minElapsed;
      }
      var delta = Math.max(-1, Math.min(1, -e.deltaY * 40));
      if (delta === 0) {
        return;
      }
      var normalizedDelta = delta / Math.abs(delta);
      updates.dollyDelta += -normalizedDelta * secsElapsed * configs.mouseWheelDollyRate;
      if (mouseMovedOnViewSinceLastWheel) {
        states.followPointerDirty = true;
        mouseMovedOnViewSinceLastWheel = false;
      }
      e.preventDefault();
    });
  }
  var _proto = MousePanRotateDollyHandler.prototype;
  _proto.reset = function reset() {};
  _proto.destroy = function destroy() {
    var canvasElement = _classPrivateFieldLooseBase(this, _view$6)[_view$6].canvasElement;
    document.removeEventListener("keydown", _classPrivateFieldLooseBase(this, _documentKeyDownHandler$2)[_documentKeyDownHandler$2]);
    document.removeEventListener("keyup", _classPrivateFieldLooseBase(this, _documentKeyUpHandler$1)[_documentKeyUpHandler$1]);
    canvasElement.removeEventListener("mousedown", _classPrivateFieldLooseBase(this, _mouseDownHandler$1)[_mouseDownHandler$1]);
    document.removeEventListener("mousemove", _classPrivateFieldLooseBase(this, _documentMouseMoveHandler$1)[_documentMouseMoveHandler$1]);
    canvasElement.removeEventListener("mousemove", _classPrivateFieldLooseBase(this, _canvasMouseMoveHandler$1)[_canvasMouseMoveHandler$1]);
    document.removeEventListener("mouseup", _classPrivateFieldLooseBase(this, _documentMouseUpHandler$1)[_documentMouseUpHandler$1]);
    canvasElement.removeEventListener("mouseup", _classPrivateFieldLooseBase(this, _mouseUpHandler$1)[_mouseUpHandler$1]);
    canvasElement.removeEventListener("mouseenter", _classPrivateFieldLooseBase(this, _mouseEnterHandler$1)[_mouseEnterHandler$1]);
    canvasElement.removeEventListener("wheel", _classPrivateFieldLooseBase(this, _mouseWheelHandler)[_mouseWheelHandler]);
  };
  return MousePanRotateDollyHandler;
}();
var getViewPosFromEvent$1 = function getViewPosFromEvent(event, canvasPos) {
  if (!event) {
    event = window.event;
    canvasPos[0] = event.x;
    canvasPos[1] = event.y;
  } else {
    var element = event.target;
    var totalOffsetLeft = 0;
    var totalOffsetTop = 0;
    while (element.offsetParent) {
      totalOffsetLeft += element.offsetLeft;
      totalOffsetTop += element.offsetTop;
      element = element.offsetParent;
    }
    canvasPos[0] = event.pageX - totalOffsetLeft;
    canvasPos[1] = event.pageY - totalOffsetTop;
  }
  return canvasPos;
};

var center = createVec3();
var tempVec3a = createVec3();
var tempVec3b = createVec3();
var tempVec3c = createVec3();
var tempVec3d = createVec3();
var tempCameraTarget = {
  eye: new Float64Array(3),
  look: new Float64Array(3),
  up: new Float64Array(3),
  orthoScale: 1
};
/**
 * @private
 */
var _documentKeyDownHandler$1 = /*#__PURE__*/_classPrivateFieldLooseKey("documentKeyDownHandler");
var KeyboardAxisViewHandler = /*#__PURE__*/function () {
  function KeyboardAxisViewHandler(components, controllers, configs, states, updates) {
    Object.defineProperty(this, _documentKeyDownHandler$1, {
      writable: true,
      value: void 0
    });
    var view = components.view;
    var camera = components.camera;
    var cameraControl = controllers.cameraControl;
    document.addEventListener("keydown", _classPrivateFieldLooseBase(this, _documentKeyDownHandler$1)[_documentKeyDownHandler$1] = function (e) {
      if (!(configs.active && configs.pointerEnabled) || !configs.keyboardEnabled) {
        return;
      }
      if (!states.mouseover) {
        return;
      }
      var axisViewRight = cameraControl._isKeyDownForAction(cameraControl.AXIS_VIEW_RIGHT);
      var axisViewBack = cameraControl._isKeyDownForAction(cameraControl.AXIS_VIEW_BACK);
      var axisViewLeft = cameraControl._isKeyDownForAction(cameraControl.AXIS_VIEW_LEFT);
      var axisViewFront = cameraControl._isKeyDownForAction(cameraControl.AXIS_VIEW_FRONT);
      var axisViewTop = cameraControl._isKeyDownForAction(cameraControl.AXIS_VIEW_TOP);
      var axisViewBottom = cameraControl._isKeyDownForAction(cameraControl.AXIS_VIEW_BOTTOM);
      if (!axisViewRight && !axisViewBack && !axisViewLeft && !axisViewFront && !axisViewTop && !axisViewBottom) {
        return;
      }
      var aabb = view.aabb;
      var diag = getAABB3Diag(aabb);
      getAABB3Center(aabb, center);
      var perspectiveDist = Math.abs(diag / Math.tan(controllers.cameraFlight.fitFOV * DEGTORAD));
      var orthoScale = diag * 1.1;
      tempCameraTarget.orthoScale = orthoScale;
      if (axisViewRight) {
        tempCameraTarget.eye.set(addVec3(center, mulVec3Scalar(camera.worldRight, perspectiveDist, tempVec3a), tempVec3d));
        tempCameraTarget.look.set(center);
        tempCameraTarget.up.set(camera.worldUp);
      } else if (axisViewBack) {
        tempCameraTarget.eye.set(addVec3(center, mulVec3Scalar(camera.worldForward, perspectiveDist, tempVec3a), tempVec3d));
        tempCameraTarget.look.set(center);
        tempCameraTarget.up.set(camera.worldUp);
      } else if (axisViewLeft) {
        tempCameraTarget.eye.set(addVec3(center, mulVec3Scalar(camera.worldRight, -perspectiveDist, tempVec3a), tempVec3d));
        tempCameraTarget.look.set(center);
        tempCameraTarget.up.set(camera.worldUp);
      } else if (axisViewFront) {
        tempCameraTarget.eye.set(addVec3(center, mulVec3Scalar(camera.worldForward, -perspectiveDist, tempVec3a), tempVec3d));
        tempCameraTarget.look.set(center);
        tempCameraTarget.up.set(camera.worldUp);
      } else if (axisViewTop) {
        tempCameraTarget.eye.set(addVec3(center, mulVec3Scalar(camera.worldUp, perspectiveDist, tempVec3a), tempVec3d));
        tempCameraTarget.look.set(center);
        tempCameraTarget.up.set(normalizeVec3(mulVec3Scalar(camera.worldForward, 1, tempVec3b), tempVec3c));
      } else if (axisViewBottom) {
        tempCameraTarget.eye.set(addVec3(center, mulVec3Scalar(camera.worldUp, -perspectiveDist, tempVec3a), tempVec3d));
        tempCameraTarget.look.set(center);
        tempCameraTarget.up.set(normalizeVec3(mulVec3Scalar(camera.worldForward, -1, tempVec3b)));
      }
      if (!configs.firstPerson && configs.followPointer) {
        controllers.pivotController.setPivotPos(center);
      }
      if (controllers.cameraFlight.duration > 0) {
        controllers.cameraFlight.flyTo(tempCameraTarget, function () {
          if (controllers.pivotController.getPivoting() && configs.followPointer) {
            controllers.pivotController.showPivot();
          }
        });
      } else {
        controllers.cameraFlight.jumpTo(tempCameraTarget);
        if (controllers.pivotController.getPivoting() && configs.followPointer) {
          controllers.pivotController.showPivot();
        }
      }
    });
  }
  var _proto = KeyboardAxisViewHandler.prototype;
  _proto.reset = function reset() {};
  _proto.destroy = function destroy() {
    document.removeEventListener("keydown", _classPrivateFieldLooseBase(this, _documentKeyDownHandler$1)[_documentKeyDownHandler$1]);
  };
  return KeyboardAxisViewHandler;
}();

/**
 * @private
 */
var _view$5 = /*#__PURE__*/_classPrivateFieldLooseKey("view");
var _clicks = /*#__PURE__*/_classPrivateFieldLooseKey("clicks");
var _timeout = /*#__PURE__*/_classPrivateFieldLooseKey("timeout");
var _lastPickedobjectId = /*#__PURE__*/_classPrivateFieldLooseKey("lastPickedobjectId");
var _canvasMouseMoveHandler = /*#__PURE__*/_classPrivateFieldLooseKey("canvasMouseMoveHandler");
var _canvasMouseDownHandler = /*#__PURE__*/_classPrivateFieldLooseKey("canvasMouseDownHandler");
var _documentMouseUpHandler = /*#__PURE__*/_classPrivateFieldLooseKey("documentMouseUpHandler");
var _canvasMouseUpHandler = /*#__PURE__*/_classPrivateFieldLooseKey("canvasMouseUpHandler");
var MousePickHandler = /*#__PURE__*/function () {
  function MousePickHandler(components, controllers, configs, states, updates) {
    var _this = this;
    Object.defineProperty(this, _view$5, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _clicks, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _timeout, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _lastPickedobjectId, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _canvasMouseMoveHandler, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _canvasMouseDownHandler, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _documentMouseUpHandler, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _canvasMouseUpHandler, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _view$5)[_view$5] = components.view;
    var pickController = controllers.pickController;
    var pivotController = controllers.pivotController;
    var cameraControl = controllers.cameraControl;
    _classPrivateFieldLooseBase(this, _clicks)[_clicks] = 0;
    _classPrivateFieldLooseBase(this, _timeout)[_timeout] = null;
    _classPrivateFieldLooseBase(this, _lastPickedobjectId)[_lastPickedobjectId] = null;
    var leftDown = false;
    var rightDown = false;
    var canvasElement = _classPrivateFieldLooseBase(this, _view$5)[_view$5].canvasElement;
    var flyCameraTo = function flyCameraTo(pickResult) {
      var pos;
      if (pickResult && pickResult.worldPos) {
        pos = pickResult.worldPos;
      }
      var aabb = pickResult && pickResult.viewObject ? pickResult.viewObject.aabb : _classPrivateFieldLooseBase(_this, _view$5)[_view$5].aabb;
      if (pos) {
        // Fly to look at point, don't change eye->look dist
        var camera = _classPrivateFieldLooseBase(_this, _view$5)[_view$5].camera;
        subVec3(camera.eye, camera.look, []);
        controllers.cameraFlight.flyTo({
          // look: pos,
          // eye: xeokit.addVec3(pos, diff, []),
          // up: camera.up,
          aabb: aabb
        });
        // TODO: Option to back off to fit AABB in view
      } else {
        // Fly to fit target boundary in view
        controllers.cameraFlight.flyTo({
          aabb: aabb
        });
      }
    };
    canvasElement.addEventListener("mousemove", _classPrivateFieldLooseBase(this, _canvasMouseMoveHandler)[_canvasMouseMoveHandler] = function (e) {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      if (leftDown || rightDown) {
        return;
      }
      var hoverSubs = cameraControl.events.hasSubs("hover");
      var hoverOutSubs = cameraControl.events.hasSubs("hoverOut");
      var hoverOffSubs = cameraControl.events.hasSubs("hoverOff");
      var hoverSurfaceSubs = cameraControl.events.hasSubs("hoverSurface");
      if (hoverSubs || hoverOutSubs || hoverOffSubs || hoverSurfaceSubs) {
        pickController.pickCursorPos = states.pointerViewPos;
        pickController.schedulePickEntity = true;
        pickController.schedulePickSurface = hoverSurfaceSubs;
        pickController.update();
        if (pickController.pickResult) {
          var pickedobjectId = pickController.pickResult.entity.id;
          if (_classPrivateFieldLooseBase(_this, _lastPickedobjectId)[_lastPickedobjectId] !== pickedobjectId) {
            if (_classPrivateFieldLooseBase(_this, _lastPickedobjectId)[_lastPickedobjectId] !== undefined) {
              cameraControl.events.fire("hoverOut", {
                entity: _classPrivateFieldLooseBase(_this, _view$5)[_view$5].objects[_classPrivateFieldLooseBase(_this, _lastPickedobjectId)[_lastPickedobjectId]]
              }, true);
            }
            cameraControl.events.fire("hoverEnter", pickController.pickResult, true); // Hovering over a new entity
            _classPrivateFieldLooseBase(_this, _lastPickedobjectId)[_lastPickedobjectId] = pickedobjectId;
          }
          cameraControl.events.fire("hover", pickController.pickResult, true);
          if (pickController.pickResult.worldPos) {
            // Hovering the surface of an entity
            cameraControl.events.fire("hoverSurface", pickController.pickResult, true);
          }
        } else {
          if (_classPrivateFieldLooseBase(_this, _lastPickedobjectId)[_lastPickedobjectId] !== undefined) {
            cameraControl.events.fire("hoverOut", {
              entity: _classPrivateFieldLooseBase(_this, _view$5)[_view$5].objects[_classPrivateFieldLooseBase(_this, _lastPickedobjectId)[_lastPickedobjectId]]
            }, true);
            _classPrivateFieldLooseBase(_this, _lastPickedobjectId)[_lastPickedobjectId] = undefined;
          }
          cameraControl.events.fire("hoverOff", {
            canvasPos: pickController.pickCursorPos
          }, true);
        }
      }
    });
    canvasElement.addEventListener('mousedown', _classPrivateFieldLooseBase(this, _canvasMouseDownHandler)[_canvasMouseDownHandler] = function (e) {
      if (e.which === 1) {
        leftDown = true;
      }
      if (e.which === 3) {
        rightDown = true;
      }
      var leftButtonDown = e.which === 1;
      if (!leftButtonDown) {
        return;
      }
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      // Left mouse button down to start pivoting
      states.mouseDownClientX = e.clientX;
      states.mouseDownClientY = e.clientY;
      states.mouseDownCursorX = states.pointerViewPos[0];
      states.mouseDownCursorY = states.pointerViewPos[1];
      if (!configs.firstPerson && configs.followPointer) {
        pickController.pickCursorPos = states.pointerViewPos;
        pickController.schedulePickSurface = true;
        pickController.update();
        if (e.which === 1) {
          // Left button
          var pickResult = pickController.pickResult;
          if (pickResult && pickResult.worldPos) {
            pivotController.setPivotPos(pickResult.worldPos);
            pivotController.startPivot();
          } else {
            if (configs.smartPivot) {
              pivotController.setViewPivotPos(states.pointerViewPos);
            } else {
              pivotController.setPivotPos(_classPrivateFieldLooseBase(_this, _view$5)[_view$5].camera.look);
            }
            pivotController.startPivot();
          }
        }
      }
    });
    document.addEventListener('mouseup', _classPrivateFieldLooseBase(this, _documentMouseUpHandler)[_documentMouseUpHandler] = function (e) {
      if (e.which === 1) {
        leftDown = false;
      }
      if (e.which === 3) {
        rightDown = false;
      }
    });
    canvasElement.addEventListener('mouseup', _classPrivateFieldLooseBase(this, _canvasMouseUpHandler)[_canvasMouseUpHandler] = function (e) {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      var leftButtonUp = e.which === 1;
      if (!leftButtonUp) {
        return;
      }
      // Left mouse button up to possibly pick or double-pick
      pivotController.hidePivot();
      if (Math.abs(e.clientX - states.mouseDownClientX) > 3 || Math.abs(e.clientY - states.mouseDownClientY) > 3) {
        return;
      }
      var pickedSubs = cameraControl.events.hasSubs("picked");
      var pickedNothingSubs = cameraControl.events.hasSubs("pickedNothing");
      var pickedSurfaceSubs = cameraControl.events.hasSubs("pickedSurface");
      var doublePickedSubs = cameraControl.events.hasSubs("doublePicked");
      var doublePickedSurfaceSubs = cameraControl.events.hasSubs("doublePickedSurface");
      var doublePickedNothingSubs = cameraControl.events.hasSubs("doublePickedNothing");
      if (!configs.doublePickFlyTo && !doublePickedSubs && !doublePickedSurfaceSubs && !doublePickedNothingSubs) {
        //  Avoid the single/double click differentiation timeout
        if (pickedSubs || pickedNothingSubs || pickedSurfaceSubs) {
          pickController.pickCursorPos = states.pointerViewPos;
          pickController.schedulePickEntity = true;
          pickController.schedulePickSurface = pickedSurfaceSubs;
          pickController.update();
          if (pickController.pickResult) {
            cameraControl.events.fire("picked", pickController.pickResult, true);
            if (pickController.pickedSurface) {
              cameraControl.events.fire("pickedSurface", pickController.pickResult, true);
            }
          } else {
            cameraControl.events.fire("pickedNothing", {
              canvasPos: states.pointerViewPos
            }, true);
          }
        }
        _classPrivateFieldLooseBase(_this, _clicks)[_clicks] = 0;
        return;
      }
      _classPrivateFieldLooseBase(_this, _clicks)[_clicks]++;
      if (_classPrivateFieldLooseBase(_this, _clicks)[_clicks] === 1) {
        // First click
        _classPrivateFieldLooseBase(_this, _timeout)[_timeout] = setTimeout(function () {
          pickController.pickCursorPos = states.pointerViewPos;
          pickController.schedulePickEntity = configs.doublePickFlyTo;
          pickController.schedulePickSurface = pickedSurfaceSubs;
          pickController.update();
          if (pickController.pickResult) {
            cameraControl.events.fire("picked", pickController.pickResult, true);
            if (pickController.pickedSurface) {
              cameraControl.events.fire("pickedSurface", pickController.pickResult, true);
              if (!configs.firstPerson && configs.followPointer) {
                controllers.pivotController.setPivotPos(pickController.pickResult.worldPos);
                if (controllers.pivotController.startPivot()) {
                  controllers.pivotController.showPivot();
                }
              }
            }
          } else {
            cameraControl.events.fire("pickedNothing", {
              canvasPos: states.pointerViewPos
            }, true);
          }
          _classPrivateFieldLooseBase(_this, _clicks)[_clicks] = 0;
        }, 250); // FIXME: Too short for track pads
      } else {
        // Second click
        if (_classPrivateFieldLooseBase(_this, _timeout)[_timeout] !== null) {
          window.clearTimeout(_classPrivateFieldLooseBase(_this, _timeout)[_timeout]);
          _classPrivateFieldLooseBase(_this, _timeout)[_timeout] = null;
        }
        pickController.pickCursorPos = states.pointerViewPos;
        pickController.schedulePickEntity = configs.doublePickFlyTo || doublePickedSubs || doublePickedSurfaceSubs;
        pickController.schedulePickSurface = pickController.schedulePickEntity && doublePickedSurfaceSubs;
        pickController.update();
        if (pickController.pickResult) {
          cameraControl.events.fire("doublePicked", pickController.pickResult, true);
          if (pickController.pickedSurface) {
            cameraControl.onDoublePickedSurface.dispatch(pickController.pickResult, true);
          }
          if (configs.doublePickFlyTo) {
            flyCameraTo(pickController.pickResult);
            if (!configs.firstPerson && configs.followPointer) {
              var pickedEntityAABB = pickController.pickResult.entity.aabb;
              var pickedEntityCenterPos = getAABB3Center(pickedEntityAABB);
              controllers.pivotController.setPivotPos(pickedEntityCenterPos);
              if (controllers.pivotController.startPivot()) {
                controllers.pivotController.showPivot();
              }
            }
          }
        } else {
          cameraControl.events.fire("doublePickedNothing", {
            canvasPos: states.pointerViewPos
          }, true);
          if (configs.doublePickFlyTo) {
            flyCameraTo();
            if (!configs.firstPerson && configs.followPointer) {
              var viewAABB = _classPrivateFieldLooseBase(_this, _view$5)[_view$5].aabb;
              var viewCenterPos = getAABB3Center(viewAABB);
              controllers.pivotController.setPivotPos(viewCenterPos);
              if (controllers.pivotController.startPivot()) {
                controllers.pivotController.showPivot();
              }
            }
          }
        }
        _classPrivateFieldLooseBase(_this, _clicks)[_clicks] = 0;
      }
    }, false);
  }
  var _proto = MousePickHandler.prototype;
  _proto.reset = function reset() {
    _classPrivateFieldLooseBase(this, _clicks)[_clicks] = 0;
    _classPrivateFieldLooseBase(this, _lastPickedobjectId)[_lastPickedobjectId] = null;
    if (_classPrivateFieldLooseBase(this, _timeout)[_timeout]) {
      window.clearTimeout(_classPrivateFieldLooseBase(this, _timeout)[_timeout]);
      _classPrivateFieldLooseBase(this, _timeout)[_timeout] = null;
    }
  };
  _proto.destroy = function destroy() {
    var canvasElement = _classPrivateFieldLooseBase(this, _view$5)[_view$5].canvasElement;
    canvasElement.removeEventListener("mousemove", _classPrivateFieldLooseBase(this, _canvasMouseMoveHandler)[_canvasMouseMoveHandler]);
    canvasElement.removeEventListener("mousedown", _classPrivateFieldLooseBase(this, _canvasMouseDownHandler)[_canvasMouseDownHandler]);
    document.removeEventListener("mouseup", _classPrivateFieldLooseBase(this, _documentMouseUpHandler)[_documentMouseUpHandler]);
    canvasElement.removeEventListener("mouseup", _classPrivateFieldLooseBase(this, _canvasMouseUpHandler)[_canvasMouseUpHandler]);
    if (_classPrivateFieldLooseBase(this, _timeout)[_timeout]) {
      window.clearTimeout(_classPrivateFieldLooseBase(this, _timeout)[_timeout]);
      _classPrivateFieldLooseBase(this, _timeout)[_timeout] = null;
    }
  };
  return MousePickHandler;
}();

/**
 * @private
 */
var _view$4 = /*#__PURE__*/_classPrivateFieldLooseKey("view");
var _documentMouseMoveHandler = /*#__PURE__*/_classPrivateFieldLooseKey("documentMouseMoveHandler");
var _documentKeyDownHandler = /*#__PURE__*/_classPrivateFieldLooseKey("documentKeyDownHandler");
var _documentKeyUpHandler = /*#__PURE__*/_classPrivateFieldLooseKey("documentKeyUpHandler");
var _onTick$2 = /*#__PURE__*/_classPrivateFieldLooseKey("onTick");
var KeyboardPanRotateDollyHandler = /*#__PURE__*/function () {
  function KeyboardPanRotateDollyHandler(components, controllers, configs, states, updates) {
    Object.defineProperty(this, _view$4, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _documentMouseMoveHandler, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _documentKeyDownHandler, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _documentKeyUpHandler, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _onTick$2, {
      writable: true,
      value: void 0
    });
    ///////////////////
    // >>> FIX constructor sigs
    /////////////////////
    this.keycodes = void 0;
    _classPrivateFieldLooseBase(this, _view$4)[_view$4] = components.view;
    var keyDownMap = [];
    var canvasElement = components.view.canvasElement;
    var mouseMovedSinceLastKeyboardDolly = true;
    document.addEventListener("mousemove", _classPrivateFieldLooseBase(this, _documentMouseMoveHandler)[_documentMouseMoveHandler] = function () {
      mouseMovedSinceLastKeyboardDolly = true;
    });
    document.addEventListener("keydown", _classPrivateFieldLooseBase(this, _documentKeyDownHandler)[_documentKeyDownHandler] = function (e) {
      if (!(configs.active && configs.pointerEnabled) || !configs.keyboardEnabled) {
        return;
      }
      if (!states.mouseover) {
        return;
      }
      var keyCode = e.keyCode;
      keyDownMap[keyCode] = true;
      if (keyCode === KEY_SHIFT) {
        canvasElement.style.cursor = "move";
      }
    });
    document.addEventListener("keyup", _classPrivateFieldLooseBase(this, _documentKeyUpHandler)[_documentKeyUpHandler] = function (e) {
      if (!(configs.active && configs.pointerEnabled) || !configs.keyboardEnabled) {
        return;
      }
      if (!states.mouseover) {
        return;
      }
      var keyCode = e.keyCode;
      keyDownMap[keyCode] = false;
      if (keyCode === KEY_SHIFT) {
        canvasElement.style.cursor = null;
      }
    });
    _classPrivateFieldLooseBase(this, _onTick$2)[_onTick$2] = components.view.viewer.events.on("tick", function (e) {
      if (!(configs.active && configs.pointerEnabled) || !configs.keyboardEnabled) {
        return;
      }
      if (!states.mouseover) {
        return;
      }
      var cameraControl = controllers.cameraControl;
      var elapsedSecs = e.deltaTime / 1000.0;
      //-------------------------------------------------------------------------------------------------
      // Keyboard rotation
      //-------------------------------------------------------------------------------------------------
      if (!configs.planView) {
        var rotateYPos = cameraControl._isKeyDownForAction(cameraControl.ROTATE_Y_POS, keyDownMap);
        var rotateYNeg = cameraControl._isKeyDownForAction(cameraControl.ROTATE_Y_NEG, keyDownMap);
        var rotateXPos = cameraControl._isKeyDownForAction(cameraControl.ROTATE_X_POS, keyDownMap);
        var rotateXNeg = cameraControl._isKeyDownForAction(cameraControl.ROTATE_X_NEG, keyDownMap);
        var orbitDelta = elapsedSecs * configs.keyboardRotationRate;
        if (rotateYPos || rotateYNeg || rotateXPos || rotateXNeg) {
          if (!configs.firstPerson && configs.followPointer) {
            controllers.pivotController.startPivot();
          }
          if (rotateYPos) {
            updates.rotateDeltaY += orbitDelta;
          } else if (rotateYNeg) {
            updates.rotateDeltaY -= orbitDelta;
          }
          if (rotateXPos) {
            updates.rotateDeltaX += orbitDelta;
          } else if (rotateXNeg) {
            updates.rotateDeltaX -= orbitDelta;
          }
          if (!configs.firstPerson && configs.followPointer) {
            controllers.pivotController.startPivot();
          }
        }
      }
      //-------------------------------------------------------------------------------------------------
      // Keyboard panning
      //-------------------------------------------------------------------------------------------------
      if (!keyDownMap[KEY_CTRL] && !keyDownMap[KEY_ALT]) {
        var dollyBackwards = cameraControl._isKeyDownForAction(cameraControl.DOLLY_BACKWARDS, keyDownMap);
        var dollyForwards = cameraControl._isKeyDownForAction(cameraControl.DOLLY_FORWARDS, keyDownMap);
        if (dollyBackwards || dollyForwards) {
          var dollyDelta = elapsedSecs * configs.keyboardDollyRate;
          if (!configs.firstPerson && configs.followPointer) {
            controllers.pivotController.startPivot();
          }
          if (dollyForwards) {
            updates.dollyDelta -= dollyDelta;
          } else if (dollyBackwards) {
            updates.dollyDelta += dollyDelta;
          }
          if (mouseMovedSinceLastKeyboardDolly) {
            states.followPointerDirty = true;
            mouseMovedSinceLastKeyboardDolly = false;
          }
        }
      }
      var panForwards = cameraControl._isKeyDownForAction(cameraControl.PAN_FORWARDS, keyDownMap);
      var panBackwards = cameraControl._isKeyDownForAction(cameraControl.PAN_BACKWARDS, keyDownMap);
      var panLeft = cameraControl._isKeyDownForAction(cameraControl.PAN_LEFT, keyDownMap);
      var panRight = cameraControl._isKeyDownForAction(cameraControl.PAN_RIGHT, keyDownMap);
      var panUp = cameraControl._isKeyDownForAction(cameraControl.PAN_UP, keyDownMap);
      var panDown = cameraControl._isKeyDownForAction(cameraControl.PAN_DOWN, keyDownMap);
      var panDelta = (keyDownMap[KEY_ALT] ? 0.3 : 1.0) * elapsedSecs * configs.keyboardPanRate; // ALT for slower pan rate
      if (panForwards || panBackwards || panLeft || panRight || panUp || panDown) {
        if (!configs.firstPerson && configs.followPointer) {
          controllers.pivotController.startPivot();
        }
        if (panDown) {
          updates.panDeltaY += panDelta;
        } else if (panUp) {
          updates.panDeltaY += -panDelta;
        }
        if (panRight) {
          updates.panDeltaX += -panDelta;
        } else if (panLeft) {
          updates.panDeltaX += panDelta;
        }
        if (panBackwards) {
          updates.panDeltaZ += panDelta;
        } else if (panForwards) {
          updates.panDeltaZ += -panDelta;
        }
      }
    });
  }
  var _proto = KeyboardPanRotateDollyHandler.prototype;
  _proto.reset = function reset() {};
  _proto.destroy = function destroy() {
    _classPrivateFieldLooseBase(this, _view$4)[_view$4].viewer.onTick.unsubscribe(_classPrivateFieldLooseBase(this, _onTick$2)[_onTick$2]);
    document.removeEventListener("mousemove", _classPrivateFieldLooseBase(this, _documentMouseMoveHandler)[_documentMouseMoveHandler]);
    document.removeEventListener("keydown", _classPrivateFieldLooseBase(this, _documentKeyDownHandler)[_documentKeyDownHandler]);
    document.removeEventListener("keyup", _classPrivateFieldLooseBase(this, _documentKeyUpHandler)[_documentKeyUpHandler]);
  };
  return KeyboardPanRotateDollyHandler;
}();

var SCALE_DOLLY_EACH_FRAME = 1; // Recalculate dolly speed for eye->target distance on each Nth frame
var EPSILON = 0.001;
var tempVec3 = createVec3();
/**
 * Handles camera updates on each "tick" that were scheduled by the various controllers.
 *
 * @private
 */
var _onTick$1 = /*#__PURE__*/_classPrivateFieldLooseKey("onTick");
var _view$3 = /*#__PURE__*/_classPrivateFieldLooseKey("view");
var CameraUpdater = /*#__PURE__*/function () {
  function CameraUpdater(view, controllers, configs, states, updates) {
    Object.defineProperty(this, _onTick$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _view$3, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _view$3)[_view$3] = view;
    var camera = view.camera;
    var pickController = controllers.pickController;
    var pivotController = controllers.pivotController;
    var panController = controllers.panController;
    var countDown = SCALE_DOLLY_EACH_FRAME; // Decrements on each tick
    var dollyDistFactor = 1.0; // Calculated when countDown is zero
    var followPointerWorldPos = null; // Holds the pointer's World position when configs.followPointer is true
    _classPrivateFieldLooseBase(this, _onTick$1)[_onTick$1] = view.viewer.onTick.subscribe(function () {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      var cursorType = "default";
      //----------------------------------------------------------------------------------------------------------
      // Dolly decay
      //------------------------------------------------------------------------------------  ----------------------
      if (Math.abs(updates.dollyDelta) < EPSILON) {
        updates.dollyDelta = 0;
      }
      //----------------------------------------------------------------------------------------------------------
      // Rotation decay
      //----------------------------------------------------------------------------------------------------------
      if (Math.abs(updates.rotateDeltaX) < EPSILON) {
        updates.rotateDeltaX = 0;
      }
      if (Math.abs(updates.rotateDeltaY) < EPSILON) {
        updates.rotateDeltaY = 0;
      }
      if (updates.rotateDeltaX !== 0 || updates.rotateDeltaY !== 0) {
        updates.dollyDelta = 0;
      }
      //----------------------------------------------------------------------------------------------------------
      // Dolly speed eye->look scaling
      //
      // If pointer is over an object, then dolly speed is proportional to the distance to that object.
      //
      // If pointer is not over an object, then dolly speed is proportional to the distance to the last
      // object the pointer was over. This is so that we can dolly to structures that may have gaps through
      // which empty background shows, that the pointer may inadvertently be over. In these cases, we don't
      // want dolly speed wildly varying depending on how accurately the user avoids the gaps with the pointer.
      //----------------------------------------------------------------------------------------------------------
      if (configs.followPointer) {
        if (--countDown <= 0) {
          countDown = SCALE_DOLLY_EACH_FRAME;
          if (updates.dollyDelta !== 0) {
            if (updates.rotateDeltaY === 0 && updates.rotateDeltaX === 0) {
              if (configs.followPointer && states.followPointerDirty) {
                pickController.pickCursorPos = states.pointerViewPos;
                pickController.schedulePickSurface = true;
                pickController.update();
                if (pickController.pickResult && pickController.pickResult.worldPos) {
                  followPointerWorldPos = pickController.pickResult.worldPos;
                } else {
                  dollyDistFactor = 1.0;
                  followPointerWorldPos = null;
                }
                states.followPointerDirty = false;
              }
            }
            if (followPointerWorldPos) {
              var dist = Math.abs(lenVec3(subVec3(followPointerWorldPos, view.camera.eye, tempVec3)));
              dollyDistFactor = dist / configs.dollyProximityThreshold;
            }
            if (dollyDistFactor < configs.dollyMinSpeed) {
              dollyDistFactor = configs.dollyMinSpeed;
            }
          }
        }
      }
      var dollyDeltaForDist = updates.dollyDelta * dollyDistFactor;
      //----------------------------------------------------------------------------------------------------------
      // Rotation
      //----------------------------------------------------------------------------------------------------------
      if (updates.rotateDeltaY !== 0 || updates.rotateDeltaX !== 0) {
        if (!configs.firstPerson && configs.followPointer && pivotController.getPivoting()) {
          pivotController.continuePivot(updates.rotateDeltaY, updates.rotateDeltaX);
          pivotController.showPivot();
        } else {
          if (updates.rotateDeltaX !== 0) {
            if (configs.firstPerson) {
              camera.pitch(-updates.rotateDeltaX);
            } else {
              camera.orbitPitch(updates.rotateDeltaX);
            }
          }
          if (updates.rotateDeltaY !== 0) {
            if (configs.firstPerson) {
              camera.yaw(updates.rotateDeltaY);
            } else {
              camera.orbitYaw(updates.rotateDeltaY);
            }
          }
        }
        updates.rotateDeltaX *= configs.rotationInertia;
        updates.rotateDeltaY *= configs.rotationInertia;
        cursorType = "grabbing";
      }
      //----------------------------------------------------------------------------------------------------------
      // Panning
      //----------------------------------------------------------------------------------------------------------
      if (Math.abs(updates.panDeltaX) < EPSILON) {
        updates.panDeltaX = 0;
      }
      if (Math.abs(updates.panDeltaY) < EPSILON) {
        updates.panDeltaY = 0;
      }
      if (Math.abs(updates.panDeltaZ) < EPSILON) {
        updates.panDeltaZ = 0;
      }
      if (updates.panDeltaX !== 0 || updates.panDeltaY !== 0 || updates.panDeltaZ !== 0) {
        var vec = createVec3();
        vec[0] = updates.panDeltaX;
        vec[1] = updates.panDeltaY;
        vec[2] = updates.panDeltaZ;
        var verticalEye;
        var verticalLook;
        if (configs.constrainVertical) {
          if (camera.xUp) {
            verticalEye = camera.eye[0];
            verticalLook = camera.look[0];
          } else if (camera.yUp) {
            verticalEye = camera.eye[1];
            verticalLook = camera.look[1];
          } else if (camera.zUp) {
            verticalEye = camera.eye[2];
            verticalLook = camera.look[2];
          }
          camera.pan(vec);
          var eye = camera.eye;
          var look = camera.look;
          if (camera.xUp) {
            eye[0] = verticalEye;
            look[0] = verticalLook;
          } else if (camera.yUp) {
            eye[1] = verticalEye;
            look[1] = verticalLook;
          } else if (camera.zUp) {
            eye[2] = verticalEye;
            look[2] = verticalLook;
          }
          camera.eye = eye;
          camera.look = look;
        } else {
          camera.pan(vec);
        }
        cursorType = "grabbing";
      }
      updates.panDeltaX *= configs.panInertia;
      updates.panDeltaY *= configs.panInertia;
      updates.panDeltaZ *= configs.panInertia;
      //----------------------------------------------------------------------------------------------------------
      // Dollying
      //----------------------------------------------------------------------------------------------------------
      if (dollyDeltaForDist !== 0) {
        if (dollyDeltaForDist < 0) {
          cursorType = "zoom-in";
        } else {
          cursorType = "zoom-out";
        }
        if (configs.firstPerson) {
          var _verticalEye;
          var _verticalLook;
          if (configs.constrainVertical) {
            if (camera.xUp) {
              _verticalEye = camera.eye[0];
              _verticalLook = camera.look[0];
            } else if (camera.yUp) {
              _verticalEye = camera.eye[1];
              _verticalLook = camera.look[1];
            } else if (camera.zUp) {
              _verticalEye = camera.eye[2];
              _verticalLook = camera.look[2];
            }
          }
          if (configs.followPointer) {
            var dolliedThroughSurface = panController.dollyToViewPos(followPointerWorldPos, states.pointerViewPos, -dollyDeltaForDist);
            if (dolliedThroughSurface) {
              states.followPointerDirty = true;
            }
          } else {
            camera.pan([0, 0, dollyDeltaForDist]);
            camera.orthoProjection.scale = camera.orthoProjection.scale - dollyDeltaForDist;
          }
          if (configs.constrainVertical) {
            var _eye = camera.eye;
            var _look = camera.look;
            if (camera.xUp) {
              _eye[0] = _verticalEye;
              _look[0] = _verticalLook;
            } else if (camera.yUp) {
              _eye[1] = _verticalEye;
              _look[1] = _verticalLook;
            } else if (camera.zUp) {
              _eye[2] = _verticalEye;
              _look[2] = _verticalLook;
            }
            camera.eye = _eye;
            camera.look = _look;
          }
        } else if (configs.planView) {
          if (configs.followPointer) {
            var _dolliedThroughSurface = panController.dollyToViewPos(followPointerWorldPos, states.pointerViewPos, -dollyDeltaForDist);
            if (_dolliedThroughSurface) {
              states.followPointerDirty = true;
            }
          } else {
            camera.orthoProjection.scale = camera.orthoProjection.scale + dollyDeltaForDist;
            camera.zoom(dollyDeltaForDist);
          }
        } else {
          // Orbiting
          if (configs.followPointer) {
            var _dolliedThroughSurface2 = panController.dollyToViewPos(followPointerWorldPos, states.pointerViewPos, -dollyDeltaForDist);
            if (_dolliedThroughSurface2) {
              states.followPointerDirty = true;
            }
          } else {
            camera.orthoProjection.scale = camera.orthoProjection.scale + dollyDeltaForDist;
            camera.zoom(dollyDeltaForDist);
          }
        }
        updates.dollyDelta *= configs.dollyInertia;
      }
      pickController.fireEvents();
      document.body.style.cursor = cursorType;
    });
  }
  var _proto = CameraUpdater.prototype;
  _proto.destroy = function destroy() {
    _classPrivateFieldLooseBase(this, _view$3)[_view$3].viewer.onTick.unsubscribe(_classPrivateFieldLooseBase(this, _onTick$1)[_onTick$1]);
  };
  return CameraUpdater;
}();

var _view$2 = /*#__PURE__*/_classPrivateFieldLooseKey("view");
var _mouseEnterHandler = /*#__PURE__*/_classPrivateFieldLooseKey("mouseEnterHandler");
var _mouseMoveHandler = /*#__PURE__*/_classPrivateFieldLooseKey("mouseMoveHandler");
var _mouseLeaveHandler = /*#__PURE__*/_classPrivateFieldLooseKey("mouseLeaveHandler");
var _mouseDownHandler = /*#__PURE__*/_classPrivateFieldLooseKey("mouseDownHandler");
var _mouseUpHandler = /*#__PURE__*/_classPrivateFieldLooseKey("mouseUpHandler");
/**
 * @private
 */
var MouseMiscHandler = /*#__PURE__*/function () {
  function MouseMiscHandler(components, controllers, configs, states, updates) {
    Object.defineProperty(this, _view$2, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _mouseEnterHandler, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _mouseMoveHandler, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _mouseLeaveHandler, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _mouseDownHandler, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _mouseUpHandler, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _view$2)[_view$2] = components.view;
    var canvasElement = _classPrivateFieldLooseBase(this, _view$2)[_view$2].canvasElement;
    canvasElement.addEventListener("mouseenter", _classPrivateFieldLooseBase(this, _mouseEnterHandler)[_mouseEnterHandler] = function () {
      states.mouseover = true;
    });
    canvasElement.addEventListener("mouseleave", _classPrivateFieldLooseBase(this, _mouseLeaveHandler)[_mouseLeaveHandler] = function () {
      states.mouseover = false;
      // @ts-ignore
      canvasElement.style.cursor = null;
    });
    document.addEventListener("mousemove", _classPrivateFieldLooseBase(this, _mouseMoveHandler)[_mouseMoveHandler] = function (e) {
      getViewPosFromEvent(e, canvasElement, states.pointerViewPos);
    });
    canvasElement.addEventListener("mousedown", _classPrivateFieldLooseBase(this, _mouseDownHandler)[_mouseDownHandler] = function (e) {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      getViewPosFromEvent(e, canvasElement, states.pointerViewPos);
      states.mouseover = true;
    });
    canvasElement.addEventListener("mouseup", _classPrivateFieldLooseBase(this, _mouseUpHandler)[_mouseUpHandler] = function (e) {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
    });
  }
  var _proto = MouseMiscHandler.prototype;
  _proto.reset = function reset() {};
  _proto.destroy = function destroy() {
    var canvasElement = _classPrivateFieldLooseBase(this, _view$2)[_view$2].canvasElement;
    document.removeEventListener("mousemove", _classPrivateFieldLooseBase(this, _mouseMoveHandler)[_mouseMoveHandler]);
    canvasElement.removeEventListener("mouseenter", _classPrivateFieldLooseBase(this, _mouseEnterHandler)[_mouseEnterHandler]);
    canvasElement.removeEventListener("mouseleave", _classPrivateFieldLooseBase(this, _mouseLeaveHandler)[_mouseLeaveHandler]);
    canvasElement.removeEventListener("mousedown", _classPrivateFieldLooseBase(this, _mouseDownHandler)[_mouseDownHandler]);
    canvasElement.removeEventListener("mouseup", _classPrivateFieldLooseBase(this, _mouseUpHandler)[_mouseUpHandler]);
  };
  return MouseMiscHandler;
}();
function getViewPosFromEvent(event, canvasElement, canvasPos) {
  if (!event) {
    event = window.event;
    canvasPos[0] = event.x;
    canvasPos[1] = event.y;
  } else {
    var _canvasElement$getBou = canvasElement.getBoundingClientRect(),
      x = _canvasElement$getBou.x,
      y = _canvasElement$getBou.y;
    canvasPos[0] = event.clientX - x;
    canvasPos[1] = event.clientY - y;
  }
  return canvasPos;
}

var getCanvasPosFromEvent = function getCanvasPosFromEvent(event, canvasPos) {
  if (!event) {
    event = window.event;
    canvasPos[0] = event.x;
    canvasPos[1] = event.y;
  } else {
    var element = event.target;
    var totalOffsetLeft = 0;
    var totalOffsetTop = 0;
    while (element.offsetParent) {
      totalOffsetLeft += element.offsetLeft;
      totalOffsetTop += element.offsetTop;
      element = element.offsetParent;
    }
    canvasPos[0] = event.pageX - totalOffsetLeft;
    canvasPos[1] = event.pageY - totalOffsetTop;
  }
  return canvasPos;
};
/**
 * @private
 */
var _view$1 = /*#__PURE__*/_classPrivateFieldLooseKey("view");
var _onTick = /*#__PURE__*/_classPrivateFieldLooseKey("onTick");
var _canvasTouchStartHandler = /*#__PURE__*/_classPrivateFieldLooseKey("canvasTouchStartHandler");
var _canvasTouchMoveHandler = /*#__PURE__*/_classPrivateFieldLooseKey("canvasTouchMoveHandler");
var TouchPanRotateAndDollyHandler = /*#__PURE__*/function () {
  function TouchPanRotateAndDollyHandler(components, controllers, configs, states, updates) {
    var _this = this;
    Object.defineProperty(this, _view$1, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _onTick, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _canvasTouchStartHandler, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _canvasTouchMoveHandler, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _view$1)[_view$1] = components.view;
    var pickController = controllers.pickController;
    var pivotController = controllers.pivotController;
    var tapStartCanvasPos = createVec2();
    var tapCanvasPos0 = createVec2();
    var tapCanvasPos1 = createVec2();
    var touch0Vec = createVec2();
    var lastCanvasTouchPosList = [];
    var canvasElement = _classPrivateFieldLooseBase(this, _view$1)[_view$1].canvasElement;
    var numTouches = 0;
    var waitForTick = false;
    _classPrivateFieldLooseBase(this, _onTick)[_onTick] = _classPrivateFieldLooseBase(this, _view$1)[_view$1].viewer.onTick.subscribe(function () {
      waitForTick = false;
    });
    canvasElement.addEventListener("touchstart", _classPrivateFieldLooseBase(this, _canvasTouchStartHandler)[_canvasTouchStartHandler] = function (event) {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      event.preventDefault();
      var touches = event.touches;
      var changedTouches = event.changedTouches;
      states.touchStartTime = Date.now();
      if (touches.length === 1 && changedTouches.length === 1) {
        getCanvasPosFromEvent(touches[0], tapStartCanvasPos);
        if (configs.followPointer) {
          pickController.pickCursorPos = tapStartCanvasPos;
          pickController.schedulePickSurface = true;
          pickController.update();
          if (!configs.planView) {
            if (pickController.picked && pickController.pickedSurface && pickController.pickResult && pickController.pickResult.worldPos) {
              pivotController.setPivotPos(pickController.pickResult.worldPos);
              if (!configs.firstPerson && pivotController.startPivot()) {
                pivotController.showPivot();
              }
            } else {
              if (configs.smartPivot) {
                pivotController.setCanvasPivotPos(states.pointerCanvasPos);
              } else {
                pivotController.setPivotPos(_classPrivateFieldLooseBase(_this, _view$1)[_view$1].camera.look);
              }
              if (!configs.firstPerson && pivotController.startPivot()) {
                pivotController.showPivot();
              }
            }
          }
        }
      }
      while (lastCanvasTouchPosList.length < touches.length) {
        lastCanvasTouchPosList.push(createVec2());
      }
      for (var i = 0, len = touches.length; i < len; ++i) {
        getCanvasPosFromEvent(touches[i], lastCanvasTouchPosList[i]);
      }
      numTouches = touches.length;
    });
    canvasElement.addEventListener("touchmove", _classPrivateFieldLooseBase(this, _canvasTouchMoveHandler)[_canvasTouchMoveHandler] = function (event) {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      if (waitForTick) {
        // Limit changes detection to one per frame
        return;
      }
      waitForTick = true;
      // Scaling drag-rotate to canvas boundary
      var canvasBoundary = _classPrivateFieldLooseBase(_this, _view$1)[_view$1].boundary;
      var canvasWidth = canvasBoundary[0];
      var canvasHeight = canvasBoundary[1];
      var touches = event.touches;
      if (event.touches.length !== numTouches) {
        // Two fingers were pressed, then one of them is removed
        // We don't want to rotate in this case (weird behavior)
        return;
      }
      if (numTouches === 1) {
        getCanvasPosFromEvent(touches[0], tapCanvasPos0);
        //-----------------------------------------------------------------------------------------------
        // Drag rotation
        //-----------------------------------------------------------------------------------------------
        subVec2(tapCanvasPos0, lastCanvasTouchPosList[0], touch0Vec);
        var xPanDelta = touch0Vec[0];
        var yPanDelta = touch0Vec[1];
        if (states.longTouchTimeout !== null && (Math.abs(xPanDelta) > configs.longTapRadius || Math.abs(yPanDelta) > configs.longTapRadius)) {
          clearTimeout(states.longTouchTimeout);
          states.longTouchTimeout = null;
        }
        if (configs.planView) {
          // No rotating in plan-view mode
          var camera = _classPrivateFieldLooseBase(_this, _view$1)[_view$1].camera;
          // We use only canvasHeight here so that aspect ratio does not distort speed
          if (camera.projectionType === PerspectiveProjectionType) {
            var touchPicked = false;
            var pickedWorldPos = [0, 0, 0];
            var depth = Math.abs(touchPicked ? lenVec3(subVec3(pickedWorldPos, _classPrivateFieldLooseBase(_this, _view$1)[_view$1].camera.eye, [])) : _classPrivateFieldLooseBase(_this, _view$1)[_view$1].camera.eyeLookDist);
            var targetDistance = depth * Math.tan(camera.perspectiveProjection.fov / 2 * Math.PI / 180.0);
            updates.panDeltaX += xPanDelta * targetDistance / canvasHeight * configs.touchPanRate;
            updates.panDeltaY += yPanDelta * targetDistance / canvasHeight * configs.touchPanRate;
          } else {
            updates.panDeltaX += 0.5 * camera.orthoProjection.scale * (xPanDelta / canvasHeight) * configs.touchPanRate;
            updates.panDeltaY += 0.5 * camera.orthoProjection.scale * (yPanDelta / canvasHeight) * configs.touchPanRate;
          }
        } else {
          updates.rotateDeltaY -= xPanDelta / canvasWidth * (configs.dragRotationRate * 1.0); // Full horizontal rotation
          updates.rotateDeltaX += yPanDelta / canvasHeight * (configs.dragRotationRate * 1.5); // Half vertical rotation
        }
      } else if (numTouches === 2) {
        var touch0 = touches[0];
        var touch1 = touches[1];
        getCanvasPosFromEvent(touch0, tapCanvasPos0);
        getCanvasPosFromEvent(touch1, tapCanvasPos1);
        var lastMiddleTouch = geometricMeanVec2(lastCanvasTouchPosList[0], lastCanvasTouchPosList[1]);
        var currentMiddleTouch = geometricMeanVec2(tapCanvasPos0, tapCanvasPos1);
        var touchDelta = createVec2();
        subVec2(lastMiddleTouch, currentMiddleTouch, touchDelta);
        var _xPanDelta = touchDelta[0];
        var _yPanDelta = touchDelta[1];
        var _camera = _classPrivateFieldLooseBase(_this, _view$1)[_view$1].camera;
        // Dollying
        var d1 = distVec2([touch0.pageX, touch0.pageY], [touch1.pageX, touch1.pageY]);
        var d2 = distVec2(lastCanvasTouchPosList[0], lastCanvasTouchPosList[1]);
        var dollyDelta = (d2 - d1) * configs.touchDollyRate;
        updates.dollyDelta = dollyDelta;
        if (Math.abs(dollyDelta) < 1.0) {
          // We use only canvasHeight here so that aspect ratio does not distort speed
          if (_camera.projectionType === PerspectiveProjectionType) {
            var _pickedWorldPos = pickController.pickResult ? pickController.pickResult.worldPos : getAABB3Center(_classPrivateFieldLooseBase(_this, _view$1)[_view$1].aabb);
            var _depth = Math.abs(lenVec3(subVec3(_pickedWorldPos, _classPrivateFieldLooseBase(_this, _view$1)[_view$1].camera.eye, [])));
            var _targetDistance = _depth * Math.tan(_camera.perspectiveProjection.fov / 2 * Math.PI / 180.0);
            updates.panDeltaX -= _xPanDelta * _targetDistance / canvasHeight * configs.touchPanRate;
            updates.panDeltaY -= _yPanDelta * _targetDistance / canvasHeight * configs.touchPanRate;
          } else {
            updates.panDeltaX -= 0.5 * _camera.orthoProjection.scale * (_xPanDelta / canvasHeight) * configs.touchPanRate;
            updates.panDeltaY -= 0.5 * _camera.orthoProjection.scale * (_yPanDelta / canvasHeight) * configs.touchPanRate;
          }
        }
        states.pointerCanvasPos = currentMiddleTouch;
      }
      for (var i = 0; i < numTouches; ++i) {
        getCanvasPosFromEvent(touches[i], lastCanvasTouchPosList[i]);
      }
    });
  }
  var _proto = TouchPanRotateAndDollyHandler.prototype;
  _proto.reset = function reset() {};
  _proto.destroy = function destroy() {
    var canvasElement = _classPrivateFieldLooseBase(this, _view$1)[_view$1].canvasElement;
    canvasElement.removeEventListener("touchstart", _classPrivateFieldLooseBase(this, _canvasTouchStartHandler)[_canvasTouchStartHandler]);
    canvasElement.removeEventListener("touchmove", _classPrivateFieldLooseBase(this, _canvasTouchMoveHandler)[_canvasTouchMoveHandler]);
    _classPrivateFieldLooseBase(this, _view$1)[_view$1].viewer.onTick.unsubscribe(_classPrivateFieldLooseBase(this, _onTick)[_onTick]);
  };
  return TouchPanRotateAndDollyHandler;
}();

var TAP_INTERVAL = 150;
var DBL_TAP_INTERVAL = 325;
var TAP_DISTANCE_THRESHOLD = 4;
/**
 * @private
 */
var _view = /*#__PURE__*/_classPrivateFieldLooseKey("view");
var TouchPickHandler = /*#__PURE__*/function () {
  function TouchPickHandler(components, controllers, configs, states, updates) {
    var _this = this;
    Object.defineProperty(this, _view, {
      writable: true,
      value: void 0
    });
    this._canvasTouchStartHandler = void 0;
    this._canvasTouchEndHandler = void 0;
    _classPrivateFieldLooseBase(this, _view)[_view] = components.view;
    var pickController = controllers.pickController;
    var cameraControl = controllers.cameraControl;
    var touchStartTime;
    var activeTouches = [];
    var tapStartPos = new Float32Array(2);
    var tapStartTime = -1;
    var lastTapTime = -1;
    var canvas = _classPrivateFieldLooseBase(this, _view)[_view].canvas.canvas;
    var flyCameraTo = function flyCameraTo(pickResult) {
      var pos;
      if (pickResult && pickResult.worldPos) {
        pos = pickResult.worldPos;
      }
      var aabb = pickResult && pickResult.viewObject ? pickResult.viewObject.aabb : _classPrivateFieldLooseBase(_this, _view)[_view].viewer.aabb;
      if (pos) {
        // Fly to look at point, don't change eye->look dist
        var camera = _classPrivateFieldLooseBase(_this, _view)[_view].camera;
        subVec3(camera.eye, camera.look, []);
        controllers.cameraFlight.flyTo({
          aabb: aabb
        });
        // TODO: Option to back off to fit AABB in view
      } else {
        // Fly to fit target boundary in view
        controllers.cameraFlight.flyTo({
          aabb: aabb
        });
      }
    };
    canvas.addEventListener("touchstart", this._canvasTouchStartHandler = function (e) {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      if (states.longTouchTimeout !== null) {
        clearTimeout(states.longTouchTimeout);
        states.longTouchTimeout = null;
      }
      var touches = e.touches;
      var changedTouches = e.changedTouches;
      touchStartTime = Date.now();
      if (touches.length === 1 && changedTouches.length === 1) {
        tapStartTime = touchStartTime;
        tapStartPos[0] = touches[0].pageX;
        tapStartPos[1] = touches[0].pageY;
        var rightClickClientX = touches[0].clientX;
        var rightClickClientY = touches[0].clientY;
        var rightClickPageX = touches[0].pageX;
        var rightClickPageY = touches[0].pageY;
        states.longTouchTimeout = setTimeout(function () {
          controllers.cameraControl.onRightClick.dispatch(cameraControl, {
            pagePos: [Math.round(rightClickPageX), Math.round(rightClickPageY)],
            canvasPos: [Math.round(rightClickClientX), Math.round(rightClickClientY)],
            event: e
          });
          states.longTouchTimeout = null;
        }, configs.longTapTimeout);
      } else {
        tapStartTime = -1;
      }
      while (activeTouches.length < touches.length) {
        activeTouches.push(new Float32Array(2));
      }
      for (var i = 0, len = touches.length; i < len; ++i) {
        activeTouches[i][0] = touches[i].pageX;
        activeTouches[i][1] = touches[i].pageY;
      }
      activeTouches.length = touches.length;
    }, {
      passive: true
    });
    canvas.addEventListener("touchend", this._canvasTouchEndHandler = function (e) {
      if (!(configs.active && configs.pointerEnabled)) {
        return;
      }
      var currentTime = Date.now();
      var touches = e.touches;
      var changedTouches = e.changedTouches;
      var pickedSurfaceSubs = cameraControl.events.hasSubs("pickedSurface");
      if (states.longTouchTimeout !== null) {
        clearTimeout(states.longTouchTimeout);
        states.longTouchTimeout = null;
      }
      // process tap
      if (touches.length === 0 && changedTouches.length === 1) {
        if (tapStartTime > -1 && currentTime - tapStartTime < TAP_INTERVAL) {
          if (lastTapTime > -1 && tapStartTime - lastTapTime < DBL_TAP_INTERVAL) {
            // Double-tap
            pickController.pickCursorPos[0] = Math.round(changedTouches[0].clientX);
            pickController.pickCursorPos[1] = Math.round(changedTouches[0].clientY);
            pickController.schedulePickEntity = true;
            pickController.schedulePickSurface = pickedSurfaceSubs;
            pickController.update();
            if (pickController.pickResult) {
              cameraControl.onDoublePickedSurface.dispatch(cameraControl, pickController.pickResult);
              if (pickController.pickedSurface) {
                cameraControl.onPickedSurface.dispatch(cameraControl, pickController.pickResult);
              }
              if (configs.doublePickFlyTo) {
                flyCameraTo(pickController.pickResult);
              }
            } else {
              cameraControl.onDoublePickedNothing.dispatch(cameraControl, null);
              if (configs.doublePickFlyTo) {
                flyCameraTo();
              }
            }
            lastTapTime = -1;
          } else if (distVec2(activeTouches[0], tapStartPos) < TAP_DISTANCE_THRESHOLD) {
            // Single-tap
            pickController.pickCursorPos[0] = Math.round(changedTouches[0].clientX);
            pickController.pickCursorPos[1] = Math.round(changedTouches[0].clientY);
            pickController.schedulePickEntity = true;
            pickController.schedulePickSurface = pickedSurfaceSubs;
            pickController.update();
            if (pickController.pickResult) {
              cameraControl.onPicked.dispatch(cameraControl, pickController.pickResult);
              if (pickController.pickedSurface) {
                cameraControl.onPickedSurface.dispatch(cameraControl, pickController.pickResult);
              }
            } else {
              cameraControl.onPickedNothing.dispatch(cameraControl);
            }
            lastTapTime = currentTime;
          }
          tapStartTime = -1;
        }
      }
      activeTouches.length = touches.length;
      for (var i = 0, len = touches.length; i < len; ++i) {
        activeTouches[i][0] = touches[i].pageX;
        activeTouches[i][1] = touches[i].pageY;
      }
      e.stopPropagation();
    }, {
      passive: true
    });
  }
  var _proto = TouchPickHandler.prototype;
  _proto.reset = function reset() {
    // TODO
    // tapStartTime = -1;
    // lastTapTime = -1;
  };
  _proto.destroy = function destroy() {
    var canvas = _classPrivateFieldLooseBase(this, _view)[_view].canvas.canvas;
    canvas.removeEventListener("touchstart", this._canvasTouchStartHandler);
    canvas.removeEventListener("touchend", this._canvasTouchEndHandler);
  };
  return TouchPickHandler;
}();

/**
 * Controls a {@link @xeokit/viewer!Camera | Camera}  with user input.
 *
 * See {@link @xeokit/cameracontrol} for usage.
 */
var _components = /*#__PURE__*/_classPrivateFieldLooseKey("components");
var _configs = /*#__PURE__*/_classPrivateFieldLooseKey("configs");
var _states = /*#__PURE__*/_classPrivateFieldLooseKey("states");
var _updates = /*#__PURE__*/_classPrivateFieldLooseKey("updates");
var _controllers = /*#__PURE__*/_classPrivateFieldLooseKey("controllers");
var _handlers = /*#__PURE__*/_classPrivateFieldLooseKey("handlers");
var _cameraUpdater = /*#__PURE__*/_classPrivateFieldLooseKey("cameraUpdater");
var _reset = /*#__PURE__*/_classPrivateFieldLooseKey("reset");
var _destroyHandlers = /*#__PURE__*/_classPrivateFieldLooseKey("destroyHandlers");
var _destroyControllers = /*#__PURE__*/_classPrivateFieldLooseKey("destroyControllers");
var CameraControl = /*#__PURE__*/function (_Component) {
  _inheritsLoose(CameraControl, _Component);
  /**
   * TODO
   */
  function CameraControl(view, cfg) {
    var _this;
    _this = _Component.call(this, view, cfg) || this;
    Object.defineProperty(_assertThisInitialized(_this), _destroyControllers, {
      value: _destroyControllers2
    });
    Object.defineProperty(_assertThisInitialized(_this), _destroyHandlers, {
      value: _destroyHandlers2
    });
    Object.defineProperty(_assertThisInitialized(_this), _reset, {
      value: _reset2
    });
    /**
     * The View that owns this CameraControl.
     */
    _this.view = void 0;
    /**
     * The View where this CameraContol listens for input.
     */
    _this.canvasElement = void 0;
    /**
     * The Camera this CameraControl controls.
     */
    _this.camera = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _components, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _configs, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _states, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _updates, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _controllers, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _handlers, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _cameraUpdater, {
      writable: true,
      value: void 0
    });
    /**
     * Event fired when we right-click.
     *
     * @event
     */
    _this.onRightClick = void 0;
    /**
     * Event fired when the pointer moves while over a {@link @xeokit/viewer!ViewObject}.
     *
     * @event
     */
    _this.onHover = void 0;
    /**
     * Event fired when the pointer moves while over a {@link @xeokit/viewer!ViewObject}.
     *
     * @event
     */
    _this.onHoverSurface = void 0;
    /**
     * Event fired when the pointer moves while over empty space.
     *
     * @event
     */
    _this.onHoverOff = void 0;
    /**
     * Event fired when the pointer moves onto a {@link @xeokit/viewer!ViewObject}.
     *
     * @event
     */
    _this.onHoverEnter = void 0;
    /**
     * Event fired when the pointer moves off a {@link @xeokit/viewer!ViewObject}.
     *
     * @event
     */
    _this.onHoverOut = void 0;
    /**
     * Event fired when a {@link @xeokit/viewer!ViewObject} is picked.
     *
     * @event
     */
    _this.onPicked = void 0;
    /**
     * Event fired when empty space is picked.
     *
     * @event
     */
    _this.onPickedSurface = void 0;
    /**
     * Event fired when empty space is picked.
     *
     * @event
     */
    _this.onPickedNothing = void 0;
    /**
     * Event fired when a surface is double-picked.
     *
     * @event
     */
    _this.onDoublePickedSurface = void 0;
    /**
     * Event fired when empty space is double-picked.
     *
     * @event
     */
    _this.onDoublePickedNothing = void 0;
    _this.view = view;
    _this.camera = view.camera;
    view.canvasElement.oncontextmenu = function (e) {
      e.preventDefault();
    };
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _components)[_components] = {
      view: view,
      camera: _this.camera
    };
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _configs)[_configs] = {
      longTapTimeout: 600,
      longTapRadius: 5,
      active: true,
      keyboardLayout: "qwerty",
      navMode: OrbitNavigationMode,
      planView: false,
      firstPerson: false,
      followPointer: true,
      doublePickFlyTo: true,
      panRightClick: true,
      showPivot: false,
      pointerEnabled: true,
      constrainVertical: false,
      smartPivot: false,
      dragRotationRate: 360.0,
      keyboardRotationRate: 90.0,
      rotationInertia: 0.0,
      keyboardPanRate: 1.0,
      touchPanRate: 1.0,
      panInertia: 0.5,
      keyboardDollyRate: 10,
      mouseWheelDollyRate: 100,
      touchDollyRate: 0.2,
      dollyInertia: 0,
      dollyProximityThreshold: 30.0,
      dollyMinSpeed: 0.04,
      keyboardEnabled: true,
      keyMap: {}
    };
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _states)[_states] = {
      pointerCanvasPos: createVec2(),
      mouseover: false,
      followPointerDirty: true,
      mouseDownClientX: 0,
      mouseDownClientY: 0,
      mouseDownCursorX: 0,
      mouseDownCursorY: 0,
      touchStartTime: null,
      activeTouches: [],
      tapStartPos: createVec2(),
      tapStartTime: -1,
      lastTapTime: -1,
      longTouchTimeout: null,
      altDown: false,
      ctrlDown: false,
      keyDown: [],
      shiftDown: false
    };
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _updates)[_updates] = {
      rotateDeltaX: 0,
      rotateDeltaY: 0,
      panDeltaX: 0,
      panDeltaY: 0,
      panDeltaZ: 0,
      dollyDelta: 0
    };
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _controllers)[_controllers] = {
      cameraControl: _assertThisInitialized(_this),
      pickController: new PickController(_assertThisInitialized(_this), _classPrivateFieldLooseBase(_assertThisInitialized(_this), _configs)[_configs]),
      pivotController: new PivotController(_assertThisInitialized(_this), _classPrivateFieldLooseBase(_assertThisInitialized(_this), _configs)[_configs]),
      panController: new PanController(_assertThisInitialized(_this)),
      cameraFlight: new CameraFlightAnimation(_this.view, {
        duration: 0.5
      })
    };
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _handlers)[_handlers] = [new MouseMiscHandler(_classPrivateFieldLooseBase(_assertThisInitialized(_this), _components)[_components], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _controllers)[_controllers], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _configs)[_configs], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _states)[_states], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _updates)[_updates]), new TouchPanRotateAndDollyHandler(_classPrivateFieldLooseBase(_assertThisInitialized(_this), _components)[_components], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _controllers)[_controllers], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _configs)[_configs], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _states)[_states], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _updates)[_updates]), new MousePanRotateDollyHandler(_classPrivateFieldLooseBase(_assertThisInitialized(_this), _components)[_components], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _controllers)[_controllers], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _configs)[_configs], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _states)[_states], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _updates)[_updates]), new KeyboardAxisViewHandler(_classPrivateFieldLooseBase(_assertThisInitialized(_this), _components)[_components], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _controllers)[_controllers], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _configs)[_configs], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _states)[_states], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _updates)[_updates]), new MousePickHandler(_classPrivateFieldLooseBase(_assertThisInitialized(_this), _components)[_components], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _controllers)[_controllers], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _configs)[_configs], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _states)[_states], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _updates)[_updates]), new TouchPickHandler(_classPrivateFieldLooseBase(_assertThisInitialized(_this), _components)[_components], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _controllers)[_controllers], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _configs)[_configs], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _states)[_states], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _updates)[_updates]), new KeyboardPanRotateDollyHandler(_classPrivateFieldLooseBase(_assertThisInitialized(_this), _components)[_components], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _controllers)[_controllers], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _configs)[_configs], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _states)[_states], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _updates)[_updates])];
    // Applies scheduled updates to the Camera on each Scene "tick" event
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _cameraUpdater)[_cameraUpdater] = new CameraUpdater(_assertThisInitialized(_this), _classPrivateFieldLooseBase(_assertThisInitialized(_this), _controllers)[_controllers], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _configs)[_configs], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _states)[_states], _classPrivateFieldLooseBase(_assertThisInitialized(_this), _updates)[_updates]);
    _this.onHover = new EventEmitter(new dist.EventDispatcher());
    _this.onHoverOff = new EventEmitter(new dist.EventDispatcher());
    _this.onHoverEnter = new EventEmitter(new dist.EventDispatcher());
    _this.onHoverOut = new EventEmitter(new dist.EventDispatcher());
    // Set initial user configurations
    _this.navMode = cfg.navMode;
    _this.constrainVertical = cfg.constrainVertical;
    _this.keyMap = cfg.keyMap;
    _this.doublePickFlyTo = cfg.doublePickFlyTo;
    _this.panRightClick = cfg.panRightClick;
    _this.active = cfg.active;
    _this.followPointer = cfg.followPointer;
    _this.rotationInertia = cfg.rotationInertia;
    _this.keyboardPanRate = cfg.keyboardPanRate;
    _this.touchPanRate = cfg.touchPanRate;
    _this.keyboardRotationRate = cfg.keyboardRotationRate;
    _this.dragRotationRate = cfg.dragRotationRate;
    _this.touchDollyRate = cfg.touchDollyRate;
    _this.dollyInertia = cfg.dollyInertia;
    _this.dollyProximityThreshold = cfg.dollyProximityThreshold;
    _this.dollyMinSpeed = cfg.dollyMinSpeed;
    _this.panInertia = cfg.panInertia;
    _this.pointerEnabled = true;
    _this.keyboardDollyRate = cfg.keyboardDollyRate;
    _this.mouseWheelDollyRate = cfg.mouseWheelDollyRate;
    _this.keyboardEnabled = cfg.keyboardEnabled;
    return _this;
  }
  /**
   * Gets custom mappings of keys to {@link CameraControl} actions.
   *
   * @returns Current key mappings.
   */
  var _proto = CameraControl.prototype;
  /**
   * Returns true if any keys configured for the given action are down.
   * @param action
   * @param keyDownMap
   * @private
   */
  _proto._isKeyDownForAction = function _isKeyDownForAction(action, keyDownMap) {
    var keys = _classPrivateFieldLooseBase(this, _configs)[_configs].keyMap[action];
    if (!keys) {
      return false;
    }
    if (!keyDownMap) {
      keyDownMap = _classPrivateFieldLooseBase(this, _states)[_states].keyDown;
    }
    for (var i = 0, len = keys.length; i < len; i++) {
      var key = keys[i];
      if (keyDownMap[key]) {
        return true;
      }
    }
    return false;
  };
  /**
   * Destroys this ````CameraControl````.
   * @private
   */
  _proto.destroy = function destroy() {
    _classPrivateFieldLooseBase(this, _destroyHandlers)[_destroyHandlers]();
    _classPrivateFieldLooseBase(this, _destroyControllers)[_destroyControllers]();
    _classPrivateFieldLooseBase(this, _cameraUpdater)[_cameraUpdater].destroy();
    this.onHover.clear();
    this.onHoverOff.clear();
    this.onHoverEnter.clear();
    this.onHoverOut.clear();
    _Component.prototype.destroy.call(this);
  };
  _createClass(CameraControl, [{
    key: "keyMap",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].keyMap;
    }
    /**
     * Sets custom mappings of keys to ````CameraControl```` actions.
     *
     * See class docs for usage.
     *
     * @param value Either a set of new key mappings, or a string to select a keyboard layout,
     * which causes ````CameraControl```` to use the default key mappings for that layout.
     */,
    set: function set(value) {
      value = value || "qwerty";
      if (isString(value)) {
        var keyMap = {};
        switch (value) {
          default:
            this.error("Unsupported value for 'keyMap': " + value + " defaulting to 'qwerty'");
          // Intentional fall-through to "qwerty"
          case "qwerty":
            keyMap[CameraControl.PAN_LEFT] = [KEY_A];
            keyMap[CameraControl.PAN_RIGHT] = [KEY_D];
            keyMap[CameraControl.PAN_UP] = [KEY_Z];
            keyMap[CameraControl.PAN_DOWN] = [KEY_X];
            keyMap[CameraControl.PAN_BACKWARDS] = [];
            keyMap[CameraControl.PAN_FORWARDS] = [];
            keyMap[CameraControl.DOLLY_FORWARDS] = [KEY_W, KEY_ADD];
            keyMap[CameraControl.DOLLY_BACKWARDS] = [KEY_S, KEY_SUBTRACT];
            keyMap[CameraControl.ROTATE_X_POS] = [KEY_DOWN_ARROW];
            keyMap[CameraControl.ROTATE_X_NEG] = [KEY_UP_ARROW];
            keyMap[CameraControl.ROTATE_Y_POS] = [KEY_Q, KEY_LEFT_ARROW];
            keyMap[CameraControl.ROTATE_Y_NEG] = [KEY_E, KEY_RIGHT_ARROW];
            keyMap[CameraControl.AXIS_VIEW_RIGHT] = [KEY_NUM_1];
            keyMap[CameraControl.AXIS_VIEW_BACK] = [KEY_NUM_2];
            keyMap[CameraControl.AXIS_VIEW_LEFT] = [KEY_NUM_3];
            keyMap[CameraControl.AXIS_VIEW_FRONT] = [KEY_NUM_4];
            keyMap[CameraControl.AXIS_VIEW_TOP] = [KEY_NUM_5];
            keyMap[CameraControl.AXIS_VIEW_BOTTOM] = [KEY_NUM_6];
            break;
          case "azerty":
            keyMap[CameraControl.PAN_LEFT] = [KEY_Q];
            keyMap[CameraControl.PAN_RIGHT] = [KEY_D];
            keyMap[CameraControl.PAN_UP] = [KEY_W];
            keyMap[CameraControl.PAN_DOWN] = [KEY_X];
            keyMap[CameraControl.PAN_BACKWARDS] = [];
            keyMap[CameraControl.PAN_FORWARDS] = [];
            keyMap[CameraControl.DOLLY_FORWARDS] = [KEY_Z, KEY_ADD];
            keyMap[CameraControl.DOLLY_BACKWARDS] = [KEY_S, KEY_SUBTRACT];
            keyMap[CameraControl.ROTATE_X_POS] = [KEY_DOWN_ARROW];
            keyMap[CameraControl.ROTATE_X_NEG] = [KEY_UP_ARROW];
            keyMap[CameraControl.ROTATE_Y_POS] = [KEY_A, KEY_LEFT_ARROW];
            keyMap[CameraControl.ROTATE_Y_NEG] = [KEY_E, KEY_RIGHT_ARROW];
            keyMap[CameraControl.AXIS_VIEW_RIGHT] = [KEY_NUM_1];
            keyMap[CameraControl.AXIS_VIEW_BACK] = [KEY_NUM_2];
            keyMap[CameraControl.AXIS_VIEW_LEFT] = [KEY_NUM_3];
            keyMap[CameraControl.AXIS_VIEW_FRONT] = [KEY_NUM_4];
            keyMap[CameraControl.AXIS_VIEW_TOP] = [KEY_NUM_5];
            keyMap[CameraControl.AXIS_VIEW_BOTTOM] = [KEY_NUM_6];
            break;
        }
        _classPrivateFieldLooseBase(this, _configs)[_configs].keyMap = keyMap;
      } else {
        var _keyMap = value;
        _classPrivateFieldLooseBase(this, _configs)[_configs].keyMap = _keyMap;
      }
    }
    /**
     * Sets the HTMl element to represent the pivot point when {@link @xeokit/cameracontrol!CameraControl.followPointer | CameraControl.followPointer} is true.
     *
     * See class comments for an example.
     *
     * @param  element HTML element representing the pivot point.
     */
  }, {
    key: "pivotElement",
    set: function set(element) {
      _classPrivateFieldLooseBase(this, _controllers)[_controllers].pivotController.setPivotElement(element);
    }
    /**
     * Gets if this ````CameraControl```` is active or not.
     *
     * When inactive, the ````CameraControl```` will not react to input.
     *
     * Default is ````true````.
     *
     * @returns ````true```` if this ````CameraControl```` is active.
     */
  }, {
    key: "active",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].active;
    }
    /**
     *  Sets if this ````CameraControl```` is active or not.
     *
     * When inactive, the ````CameraControl```` will not react to input.
     *
     * Default is ````true````.
     *
     * @param value Set ````true```` to activate this ````CameraControl````.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].active = value !== false;
    }
    /**
     * Gets the current navigation mode.
     *
     * Returned values are:
     *
     * * {@link @xeokit/constants!OrbitNavigationMode} - rotation orbits about the current target or pivot point,
     * * {@link @xeokit/constants!FirstPersonNavigationMode} - rotation is about the current eye position,
     * * {@link @xeokit/constants!PlanViewNavigationMode} - rotation is disabled.
     *
     * @returns {number} The navigation mode: OrbitNavigationMode, FirstPersonNavigationMode or PlanViewNavigationMode.
     */
  }, {
    key: "navMode",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].navMode;
    }
    /**
     * Sets the current navigation mode.
     *
     * Accepted values are:
     *
     * * {@link @xeokit/constants!OrbitNavigationMode} - rotation orbits about the current target or pivot point,
     * * {@link @xeokit/constants!FirstPersonNavigationMode} - rotation is about the current eye position,
     * * {@link @xeokit/constants!PlanViewNavigationMode} - rotation is disabled.
     *
     * See class comments for more info.
     *
     * @param navMode The navigation mode: OrbitNavigationMode, FirstPersonNavigationMode or PlanViewNavigationMode.
     */,
    set: function set(navMode) {
      navMode = navMode || OrbitNavigationMode;
      if (navMode !== FirstPersonNavigationMode && navMode !== OrbitNavigationMode && navMode !== PlanViewNavigationMode) {
        this.error("Unsupported value for navMode: " + navMode + " - supported values are 'orbit', 'firstPerson' and 'planView' - defaulting to 'orbit'");
        navMode = OrbitNavigationMode;
      }
      _classPrivateFieldLooseBase(this, _configs)[_configs].firstPerson = navMode === FirstPersonNavigationMode;
      _classPrivateFieldLooseBase(this, _configs)[_configs].planView = navMode === PlanViewNavigationMode;
      if (_classPrivateFieldLooseBase(this, _configs)[_configs].firstPerson || _classPrivateFieldLooseBase(this, _configs)[_configs].planView) {
        _classPrivateFieldLooseBase(this, _controllers)[_controllers].pivotController.hidePivot();
        _classPrivateFieldLooseBase(this, _controllers)[_controllers].pivotController.endPivot();
      }
      _classPrivateFieldLooseBase(this, _configs)[_configs].navMode = navMode;
    }
    /**
     * Gets whether mouse and touch input is enabled.
     *
     * Default is ````true````.
     *
     * Disabling mouse and touch input on ````CameraControl```` is desirable when we want to temporarily use mouse or
     * touch input to interact with some other 3D control, without interfering with the {@link @xeokit/viewer!Camera}.
     *
     * @returns {Boolean} Returns ````true```` if mouse and touch input is enabled.
     */
  }, {
    key: "pointerEnabled",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].pointerEnabled;
    }
    /**
     * Sets whether mouse and touch input is enabled.
     *
     * Default is ````true````.
     *
     * Disabling mouse and touch input on ````CameraControl```` is useful when we want to temporarily use mouse or
     * touch input to interact with some other 3D control, without disturbing the {@link @xeokit/viewer!Camera}.
     *
     * @param value Set ````true```` to enable mouse and touch input.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _reset)[_reset]();
      _classPrivateFieldLooseBase(this, _configs)[_configs].pointerEnabled = !!value;
    }
    /**
     * Sets whether the {@link @xeokit/viewer!Camera}  follows the mouse/touch pointer.
     *
     * In orbiting mode, the Camera will orbit about the pointer, and will dolly to and from the pointer.
     *
     * In fly-to mode, the Camera will dolly to and from the pointer, however the World will always rotate about the Camera position.
     *
     * In plan-view mode, the Camera will dolly to and from the pointer, however the Camera will not rotate.
     *
     * Default is ````true````.
     *
     * See class comments for more info.
     *
     * @returns {Boolean} Returns ````true```` if the Camera follows the pointer.
     */
  }, {
    key: "followPointer",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].followPointer;
    }
    /**
     * Sets whether the {@link @xeokit/viewer!Camera}  follows the mouse/touch pointer.
     *
     * In orbiting mode, the Camera will orbit about the pointer, and will dolly to and from the pointer.
     *
     * In fly-to mode, the Camera will dolly to and from the pointer, however the World will always rotate about the Camera position.
     *
     * In plan-view mode, the Camera will dolly to and from the pointer, however the Camera will not rotate.
     *
     * Default is ````true````.
     *
     * See class comments for more info.
     *
     * @param value Set ````true```` to enable the Camera to follow the pointer.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].followPointer = value !== false;
    }
    /**
     * Gets the current World-space 3D pivot position.
     *
     * Only applies when {@link @xeokit/cameracontrol!CameraControl.followPointer | CameraControl.followPointer} is ````true````.
     *
     * @return {Number[]} worldPos The current World-space 3D pivot position.
     */
  }, {
    key: "pivotPos",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _controllers)[_controllers].pivotController.getPivotPos();
    }
    /**
     * Sets the current World-space 3D target position.
     *
     * Only applies when {@link @xeokit/cameracontrol!CameraControl.followPointer | CameraControl.followPointer} is ````true````.
     *
     * @param worldPos The new World-space 3D target position.
     */,
    set: function set(worldPos) {
      _classPrivateFieldLooseBase(this, _controllers)[_controllers].pivotController.setPivotPos(worldPos);
    }
    /**
     * @deprecated
     * @returns {Boolean} Returns ````true```` if dolly-to-pointer behaviour is enabled.
     */
  }, {
    key: "dollyToPointer",
    get: function get() {
      this.warn("dollyToPointer property is deprecated - replaced with followPointer");
      return this.followPointer;
    }
    /**
     * @deprecated
     * @param value Set ````true```` to enable dolly-to-pointer behaviour.
     */,
    set: function set(value) {
      this.warn("dollyToPointer property is deprecated - replaced with followPointer");
      this.followPointer = value;
    }
    /**
     * @deprecated
     * @returns {Boolean} Returns ````true```` if dolly-to-pointer behaviour is enabled.
     */
  }, {
    key: "panToPointer",
    get: function get() {
      this.warn("panToPointer property is deprecated - replaced with followPointer");
      return false;
    }
    /**
     * @deprecated
     * @param value Set ````true```` to enable dolly-to-pointer behaviour.
     */,
    set: function set(value) {
      this.warn("panToPointer property is deprecated - replaced with followPointer");
    }
    /**
     * Gets whether this ````CameraControl```` is in plan-view mode.
     *
     * When in plan-view mode, rotation is disabled.
     *
     * Default is ````false````.
     *
     * Deprecated - use {@link @xeokit/cameracontrol!CameraControl.navMode | CameraControl.navMode} instead.
     *
     * @returns {Boolean} Returns ````true```` if plan-view mode is enabled.
     * @deprecated
     */
  }, {
    key: "planView",
    get: function get() {
      this.warn("planView property is deprecated - replaced with navMode");
      return _classPrivateFieldLooseBase(this, _configs)[_configs].planView;
    }
    /**
     * Sets whether this ````CameraControl```` is in plan-view mode.
     *
     * When in plan-view mode, rotation is disabled.
     *
     * Default is ````false````.
     *
     * Deprecated - use {@link @xeokit/cameracontrol!CameraControl.navMode | CameraControl.navMode} instead.
     *
     * @param value Set ````true```` to enable plan-view mode.
     * @deprecated
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].planView = !!value;
      _classPrivateFieldLooseBase(this, _configs)[_configs].firstPerson = false;
      if (_classPrivateFieldLooseBase(this, _configs)[_configs].planView) {
        _classPrivateFieldLooseBase(this, _controllers)[_controllers].pivotController.hidePivot();
        _classPrivateFieldLooseBase(this, _controllers)[_controllers].pivotController.endPivot();
      }
      this.warn("planView property is deprecated - replaced with navMode");
    }
    /**
     * Gets whether this ````CameraControl```` is in first-person mode.
     *
     * In "first person" mode (disabled by default) the look position rotates about the eye position. Otherwise,  {@link @xeokit/viewer!Camera.eye | Camera.eye} rotates about {@link @xeokit/viewer!Camera.look | Camera.look}.
     *
     * Default is ````false````.
     *
     * Deprecated - use {@link @xeokit/cameracontrol!CameraControl.navMode | CameraControl.navMode} instead.
     *
     * @returns {Boolean} Returns ````true```` if first-person mode is enabled.
     * @deprecated
     */
  }, {
    key: "firstPerson",
    get: function get() {
      this.warn("firstPerson property is deprecated - replaced with navMode");
      return _classPrivateFieldLooseBase(this, _configs)[_configs].firstPerson;
    }
    /**
     * Sets whether this ````CameraControl```` is in first-person mode.
     *
     * In "first person" mode (disabled by default) the look position rotates about the eye position. Otherwise,  {@link @xeokit/viewer!Camera.eye | Camera.eye} rotates about {@link @xeokit/viewer!Camera.look | Camera.look}.
     *
     * Default is ````false````.
     *
     * Deprecated - use {@link @xeokit/cameracontrol!CameraControl.navMode | CameraControl.navMode} instead.
     *
     * @param value Set ````true```` to enable first-person mode.
     * @deprecated
     */,
    set: function set(value) {
      this.warn("firstPerson property is deprecated - replaced with navMode");
      _classPrivateFieldLooseBase(this, _configs)[_configs].firstPerson = !!value;
      _classPrivateFieldLooseBase(this, _configs)[_configs].planView = false;
      if (_classPrivateFieldLooseBase(this, _configs)[_configs].firstPerson) {
        _classPrivateFieldLooseBase(this, _controllers)[_controllers].pivotController.hidePivot();
        _classPrivateFieldLooseBase(this, _controllers)[_controllers].pivotController.endPivot();
      }
    }
    /**
     * Gets whether to vertically constrain the {@link @xeokit/viewer!Camera}  position for first-person navigation.
     *
     * When set ````true````, this constrains {@link @xeokit/viewer!Camera.eye | Camera.eye} to its current vertical position.
     *
     * Only applies when {@link @xeokit/cameracontrol!CameraControl.navMode | CameraControl.navMode} is ````FirstPersonNavigationMode````.
     *
     * Default is ````false````.
     *
     * @returns {Boolean} ````true```` when Camera is vertically constrained.
     */
  }, {
    key: "constrainVertical",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].constrainVertical;
    }
    /**
     * Sets whether to vertically constrain the {@link @xeokit/viewer!Camera}  position for first-person navigation.
     *
     * When set ````true````, this constrains {@link @xeokit/viewer!Camera.eye | Camera.eye} to its current vertical position.
     *
     * Only applies when {@link @xeokit/cameracontrol!CameraControl.navMode | CameraControl.navMode} is ````FirstPersonNavigationMode````.
     *
     * Default is ````false````.
     *
     * @param value Set ````true```` to vertically constrain the Camera.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].constrainVertical = !!value;
    }
    /**
     * Gets whether double-picking a {@link @xeokit/viewer!ViewObject} causes the {@link @xeokit/viewer!Camera}  to fly to its boundary.
     *
     * Default is ````false````.
     *
     * @returns {Boolean} Returns ````true```` when double-pick-fly-to mode is enabled.
     */
  }, {
    key: "doublePickFlyTo",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].doublePickFlyTo;
    }
    /**
     * Sets whether double-picking a {@link @xeokit/viewer!ViewObject} causes the {@link @xeokit/viewer!Camera}  to fly to its boundary.
     *
     * Default is ````false````.
     *
     * @param value Set ````true```` to enable double-pick-fly-to mode.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].doublePickFlyTo = value !== false;
    }
    /**
     * Gets whether right-clicking pans the {@link @xeokit/viewer!Camera} .
     *
     * Default is ````true````.
     *
     * @returns {Boolean} Returns ````false```` when pan on right-click is disabled.
     */
  }, {
    key: "panRightClick",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].panRightClick;
    }
    /**
     * Sets whether either right-clicking (true) or middle-clicking (false) pans the {@link @xeokit/viewer!Camera} .
     *
     * Default is ````true````.
     *
     * @param value Set ````false```` to disable pan on right-click.
     */,
    set: function set(value) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].panRightClick = value !== false;
    }
    /**
     * Gets the rotation inertia factor.
     *
     * Default is ````0.0````.
     *
     * Does not apply when {@link @xeokit/cameracontrol!CameraControl.navMode | CameraControl.navMode} is ````PlanViewNavigationMode````, which disallows rotation.
     *
     * @returns {Number} The inertia factor.
     */
  }, {
    key: "rotationInertia",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].rotationInertia;
    }
    /**
     * Sets a factor in range ````[0..1]```` indicating how much the {@link @xeokit/viewer!Camera}  keeps moving after you
     * finish rotating it.
     *
     * A value of ````0.0```` causes it to immediately stop, ````0.5```` causes its movement to decay 50% on each tick,
     * while ````1.0```` causes no decay, allowing it to continue moving, by the current rate of rotation.
     *
     * You may choose an inertia of zero when you want to be able to precisely rotate the Camera,
     * without interference from inertia. Zero inertia can also mean that fewer frames are rendered while
     * you are rotating the Camera.
     *
     * Default is ````0.0````.
     *
     * Does not apply when {@link @xeokit/cameracontrol!CameraControl.navMode | CameraControl.navMode} is ````PlanViewNavigationMode````,
     * which disallows rotation.
     *
     * @param rotationInertia New inertial factor.
     */,
    set: function set(rotationInertia) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].rotationInertia = rotationInertia !== undefined && rotationInertia !== null ? rotationInertia : 0.0;
    }
    /**
     * Gets how fast the {@link @xeokit/viewer!Camera}  pans on touch panning
     *
     * Default is ````1.0````.
     *
     * @returns {Number} The current touch pan rate.
     */
  }, {
    key: "touchPanRate",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].touchPanRate;
    }
    /**
     * Sets how fast the camera pans on touch panning
     *
     * @param touchPanRate The new touch pan rate.
     */,
    set: function set(touchPanRate) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].touchPanRate = touchPanRate !== null && touchPanRate !== undefined ? touchPanRate : 1.0;
    }
    /**
     * Gets how much the {@link @xeokit/viewer!Camera}  pans each second with keyboard input.
     *
     * Default is ````5.0````.
     *
     * @returns {Number} The current keyboard pan rate.
     */
  }, {
    key: "keyboardPanRate",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].keyboardPanRate;
    }
    /**
     * Sets how much the {@link @xeokit/viewer!Camera}  pans each second with keyboard input.
     *
     * Default is ````5.0````, to pan the Camera ````5.0```` World-space units every second that
     * a panning key is depressed. See the ````CameraControl```` class documentation for which keys control
     * panning.
     *
     * Panning direction is aligned to our Camera's orientation. When we pan horizontally, we pan
     * to our left and right, when we pan vertically, we pan upwards and downwards, and when we pan forwards
     * and backwards, we pan along the direction the Camera is pointing.
     *
     * Unlike dollying when {@link followPointer} is ````true````, panning does not follow the pointer.
     *
     * @param keyboardPanRate The new keyboard pan rate.
     */,
    set: function set(keyboardPanRate) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].keyboardPanRate = keyboardPanRate !== null && keyboardPanRate !== undefined ? keyboardPanRate : 5.0;
    }
    /**
     * Sets how many degrees per second the {@link @xeokit/viewer!Camera} rotates/orbits with keyboard input.
     *
     * Default is ````90.0````.
     *
     * @returns {Number} The current keyboard rotation rate.
     */
  }, {
    key: "keyboardRotationRate",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].keyboardRotationRate;
    }
    /**
     * Sets how many degrees per second the {@link @xeokit/viewer!Camera}  rotates/orbits with keyboard input.
     *
     * Default is ````90.0````, to rotate/orbit the Camera ````90.0```` degrees every second that
     * a rotation key is depressed. See the ````CameraControl```` class documentation for which keys control
     * rotation/orbit.
     *
     * @param keyboardRotationRate The new keyboard rotation rate.
     */,
    set: function set(keyboardRotationRate) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].keyboardRotationRate = keyboardRotationRate !== null && keyboardRotationRate !== undefined ? keyboardRotationRate : 90.0;
    }
    /**
     * Gets the current drag rotation rate.
     *
     * Default is ````360.0````.
     *
     * @returns {Number} The current drag rotation rate.
     */
  }, {
    key: "dragRotationRate",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].dragRotationRate;
    }
    /**
     * Sets the current drag rotation rate.
     *
     * This configures how many degrees the {@link @xeokit/viewer!Camera}  rotates/orbits for a full sweep of the canvas by mouse or
     * touch dragging.
     *
     * For example, a value of ````360.0```` indicates that the ````Camera```` rotates/orbits ````360.0```` degrees horizontally
     * when we sweep the entire width of the canvas.
     *
     * ````CameraControl```` makes vertical rotation half as sensitive as horizontal rotation, so that we don't tend to
     * flip upside-down. Therefore, a value of ````360.0```` rotates/orbits the ````Camera```` through ````180.0```` degrees
     * vertically when we sweep the entire height of the canvas.
     *
     * Default is ````360.0````.
     *
     * @param dragRotationRate The new drag rotation rate.
     */,
    set: function set(dragRotationRate) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].dragRotationRate = dragRotationRate !== null && dragRotationRate !== undefined ? dragRotationRate : 360.0;
    }
    /**
     * Gets how much the {@link @xeokit/viewer!Camera}  dollys each second with keyboard input.
     *
     * Default is ````15.0````.
     *
     * @returns {Number} The current keyboard dolly rate.
     */
  }, {
    key: "keyboardDollyRate",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].keyboardDollyRate;
    }
    /**
     * Sets how much the {@link @xeokit/viewer!Camera}  dollys each second with keyboard input.
     *
     * Default is ````15.0````, to dolly the {@link @xeokit/viewer!Camera}  ````15.0```` World-space units per second while we hold down
     * the ````+```` and ````-```` keys.
     *
     * @param keyboardDollyRate The new keyboard dolly rate.
     */,
    set: function set(keyboardDollyRate) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].keyboardDollyRate = keyboardDollyRate !== null && keyboardDollyRate !== undefined ? keyboardDollyRate : 15.0;
    }
    /**
     * Gets how much the {@link @xeokit/viewer!Camera}  dollys each second with touch input.
     *
     * Default is ````0.2````.
     *
     * @returns {Number} The current touch dolly rate.
     */
  }, {
    key: "touchDollyRate",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].touchDollyRate;
    }
    /**
     * Sets how much the {@link @xeokit/viewer!Camera}  dollys with touch input.
     *
     * Default is ````0.2````
     *
     * @param touchDollyRate The new touch dolly rate.
     */,
    set: function set(touchDollyRate) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].touchDollyRate = touchDollyRate !== null && touchDollyRate !== undefined ? touchDollyRate : 0.2;
    }
    /**
     * Gets how much the {@link @xeokit/viewer!Camera}  dollys each second while the mouse wheel is spinning.
     *
     * Default is ````100.0````.
     *
     * @returns {Number} The current mouseWheel dolly rate.
     */
  }, {
    key: "mouseWheelDollyRate",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].mouseWheelDollyRate;
    }
    /**
     * Sets how much the {@link @xeokit/viewer!Camera}  dollys each second while the mouse wheel is spinning.
     *
     * Default is ````100.0````, to dolly the {@link @xeokit/viewer!Camera}  ````10.0```` World-space units per second as we spin
     * the mouse wheel.
     *
     * @param mouseWheelDollyRate The new mouse wheel dolly rate.
     */,
    set: function set(mouseWheelDollyRate) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].mouseWheelDollyRate = mouseWheelDollyRate !== null && mouseWheelDollyRate !== undefined ? mouseWheelDollyRate : 100.0;
    }
    /**
     * Gets the dolly inertia factor.
     *
     * Default is ````0````.
     *
     * @returns {Number} The current dolly inertia factor.
     */
  }, {
    key: "dollyInertia",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].dollyInertia;
    }
    /**
     * Sets the dolly inertia factor.
     *
     * This factor configures how much the {@link @xeokit/viewer!Camera}  keeps moving after you finish dollying it.
     *
     * This factor is a value in range ````[0..1]````. A value of ````0.0```` causes dollying to immediately stop,
     * ````0.5```` causes dollying to decay 50% on each animation frame, while ````1.0```` causes no decay, which allows dollying
     * to continue until further input stops it.
     *
     * You might set ````dollyInertia```` to zero when you want to be able to precisely position or rotate the Camera,
     * without interference from inertia. This also means that xeokit renders fewer frames while dollying the Camera,
     * which can improve rendering performance.
     *
     * Default is ````0````.
     *
     * @param dollyInertia New dolly inertia factor.
     */,
    set: function set(dollyInertia) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].dollyInertia = dollyInertia !== undefined && dollyInertia !== null ? dollyInertia : 0;
    }
    /**
     * Gets the proximity to the closest object below which dolly speed decreases, and above which dolly speed increases.
     *
     * Default is ````35.0````.
     *
     * @returns {Number} The current dolly proximity threshold.
     */
  }, {
    key: "dollyProximityThreshold",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].dollyProximityThreshold;
    }
    /**
     * Sets the proximity to the closest object below which dolly speed decreases, and above which dolly speed increases.
     *
     * Default is ````35.0````.
     *
     * @param dollyProximityThreshold New dolly proximity threshold.
     */,
    set: function set(dollyProximityThreshold) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].dollyProximityThreshold = dollyProximityThreshold !== undefined && dollyProximityThreshold !== null ? dollyProximityThreshold : 35.0;
    }
    /**
     * Gets the minimum dolly speed.
     *
     * Default is ````0.04````.
     *
     * @returns {Number} The current minimum dolly speed.
     */
  }, {
    key: "dollyMinSpeed",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].dollyMinSpeed;
    }
    /**
     * Sets the minimum dolly speed.
     *
     * Default is ````0.04````.
     *
     * @param dollyMinSpeed New dolly minimum speed.
     */,
    set: function set(dollyMinSpeed) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].dollyMinSpeed = dollyMinSpeed !== undefined && dollyMinSpeed !== null ? dollyMinSpeed : 0.04;
    }
    /**
     * Gets the pan inertia factor.
     *
     * Default is ````0.5````.
     *
     * @returns {Number} The current pan inertia factor.
     */
  }, {
    key: "panInertia",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].panInertia;
    }
    /**
     * Sets the pan inertia factor.
     *
     * This factor configures how much the {@link @xeokit/viewer!Camera}  keeps moving after you finish panning it.
     *
     * This factor is a value in range ````[0..1]````. A value of ````0.0```` causes panning to immediately stop,
     * ````0.5```` causes panning to decay 50% on each animation frame, while ````1.0```` causes no decay, which allows panning
     * to continue until further input stops it.
     *
     * You might set ````panInertia```` to zero when you want to be able to precisely position or rotate the Camera,
     * without interference from inertia. This also means that xeokit renders fewer frames while panning the Camera,
     * wich can improve rendering performance.
     *
     * Default is ````0.5````.
     *
     * @param panInertia New pan inertia factor.
     */,
    set: function set(panInertia) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].panInertia = panInertia !== undefined && panInertia !== null ? panInertia : 0.5;
    }
    /**
     * Gets the keyboard layout.
     *
     * Supported layouts are:
     *
     * * ````"qwerty"```` (default)
     * * ````"azerty"````
     *
     * @deprecated
     * @returns {String} The current keyboard layout.
     */
  }, {
    key: "keyboardLayout",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].keyboardLayout;
    }
    /**
     * Sets the keyboard layout.
     *
     * Supported layouts are:
     *
     * * ````"qwerty"```` (default)
     * * ````"azerty"````
     *
     * @deprecated
     * @param value Selects the keyboard layout.
     */,
    set: function set(value) {
      // this.warn("keyboardLayout property is deprecated - use keyMap property instead");
      value = value || "qwerty";
      if (value !== "qwerty" && value !== "azerty") {
        this.error("Unsupported value for keyboardLayout - defaulting to 'qwerty'");
        value = "qwerty";
      }
      _classPrivateFieldLooseBase(this, _configs)[_configs].keyboardLayout = value;
      this.keyMap = _classPrivateFieldLooseBase(this, _configs)[_configs].keyboardLayout;
    }
    /**
     * Gets whether smart default pivoting is enabled.
     *
     * When ````true````, we'll pivot by default about the 3D position of the mouse/touch pointer on an
     * imaginary sphere that's centered at {@link @xeokit/viewer!Camera.eye | Camera.eye} and sized to the
     * {@link @xeokit/scene!Scene} boundary.
     *
     * When ````false````, we'll pivot by default about {@link @xeokit/viewer!Camera.look | Camera.look}.
     *
     * Default is ````false````.
     *
     * @returns {Boolean} Returns ````true```` when pivoting by default about the selected point on the virtual
     * sphere, or ````false```` when pivoting by default about {@link @xeokit/viewer!Camera.look | Camera.look}.
     */
  }, {
    key: "smartPivot",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].smartPivot;
    }
    /**
     * Sets whether smart default pivoting is enabled.
     *
     * When ````true````, we'll pivot by default about the 3D position of the mouse/touch pointer on an
     * imaginary sphere that's centered at {@link @xeokit/viewer!Camera.eye | Camera.eye} and sized to
     * the {@link @xeokit/scene!Scene} boundary.
     *
     * When ````false````, we'll pivot by default about {@link @xeokit/viewer!Camera.look | Camera.look}.
     *
     * Default is ````false````.
     *
     * @param enabled Set ````true```` to pivot by default about the selected point on the virtual sphere,
     * or ````false```` to pivot by default about {@link @xeokit/viewer!Camera.look | Camera.look}.
     */,
    set: function set(enabled) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].smartPivot = enabled !== false;
    }
    /**
     * Gets whether keyboard input is enabled.
     */
  }, {
    key: "keyboardEnabled",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _configs)[_configs].keyboardEnabled;
    }
    /**
     * Sets whether keyboard input is enabled.
     */,
    set: function set(enabled) {
      _classPrivateFieldLooseBase(this, _configs)[_configs].keyboardEnabled = enabled !== false;
    }
  }]);
  return CameraControl;
}(Component);
function _reset2() {
  for (var i = 0, len = _classPrivateFieldLooseBase(this, _handlers)[_handlers].length; i < len; i++) {
    var handler = _classPrivateFieldLooseBase(this, _handlers)[_handlers][i];
    if (handler.reset) {
      handler.reset();
    }
  }
  _classPrivateFieldLooseBase(this, _updates)[_updates].panDeltaX = 0;
  _classPrivateFieldLooseBase(this, _updates)[_updates].panDeltaY = 0;
  _classPrivateFieldLooseBase(this, _updates)[_updates].rotateDeltaX = 0;
  _classPrivateFieldLooseBase(this, _updates)[_updates].rotateDeltaY = 0;
  _classPrivateFieldLooseBase(this, _updates)[_updates].dollyDelta = 0;
}
function _destroyHandlers2() {
  for (var i = 0, len = _classPrivateFieldLooseBase(this, _handlers)[_handlers].length; i < len; i++) {
    var handler = _classPrivateFieldLooseBase(this, _handlers)[_handlers][i];
    if (handler.destroy) {
      handler.destroy();
    }
  }
}
function _destroyControllers2() {
  for (var key in _classPrivateFieldLooseBase(this, _controllers)[_controllers]) {
    // @ts-ignore
    var controller = _classPrivateFieldLooseBase(this, _controllers)[_controllers][key];
    if (controller.destroy) {
      controller.destroy();
    }
  }
}
/**
 * Identifies the *leftwards panning* action, in which the {@link @xeokit/viewer!Camera}  moves leftwards along its local axis.
 */
CameraControl.PAN_LEFT = 0;
/**
 * Identifies the *rightwards panning* action, in which the {@link @xeokit/viewer!Camera}  moves rightwards along its local axis.
 */
CameraControl.PAN_RIGHT = 1;
/**
 * Identifies the *upwards panning* action, in which the {@link @xeokit/viewer!Camera}  moves upwards along its local vertical axis.
 */
CameraControl.PAN_UP = 2;
/**
 * Identifies the *downwards panning* action, in which the {@link @xeokit/viewer!Camera}  moves downwards along its local vertical axis.
 */
CameraControl.PAN_DOWN = 3;
/**
 * Identifies the *forwards panning* action, in which the {@link @xeokit/viewer!Camera}  advances forwards along its current view direction.
 */
CameraControl.PAN_FORWARDS = 4;
/**
 * Identifies the *backwards panning* action, in which the {@link @xeokit/viewer!Camera}  retreats backwards along its current view direction.
 */
CameraControl.PAN_BACKWARDS = 5;
/**
 * Identifies the *positive-rotation-about-X-axis* action.
 */
CameraControl.ROTATE_X_POS = 6;
/**
 * Identifies the *negative-rotation-about-X-axis* action.
 */
CameraControl.ROTATE_X_NEG = 7;
/**
 * Identifies the *positive-rotation-about-Y-axis* action.
 */
CameraControl.ROTATE_Y_POS = 8;
/**
 * Identifies the *negative-rotation-about-Y-axis* action.
 */
CameraControl.ROTATE_Y_NEG = 9;
/**
 * Identifies the *dolly forwards* action.
 */
CameraControl.DOLLY_FORWARDS = 10;
/**
 * Identifies the *dolly backwards* action.
 */
CameraControl.DOLLY_BACKWARDS = 11;
/**
 * Identifies the *axis-view-right* action.
 */
CameraControl.AXIS_VIEW_RIGHT = 12;
/**
 * Identifies the *axis-view-back* action.
 */
CameraControl.AXIS_VIEW_BACK = 13;
/**
 * Identifies the *axis-view-left* action.
 */
CameraControl.AXIS_VIEW_LEFT = 14;
/**
 * Identifies the *axis-view-front* action.
 */
CameraControl.AXIS_VIEW_FRONT = 15;
/**
 * Identifies the *axis-view-top* action.
 */
CameraControl.AXIS_VIEW_TOP = 16;
/**
 * Identifies the *axis-view-bottom* action.
 */
CameraControl.AXIS_VIEW_BOTTOM = 17;

/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2Fcontrols.svg)](https://badge.fury.io/js/%40xeokit%2Fcontrols)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/cameracontrol/badge)](https://www.jsdelivr.com/package/npm/@xeokit/cameracontrol)
 *
 * <img style="padding:30px" src="media://images/xeokit_controls_icon.png"/>
 *
 * # xeokit Camera Controls
 *
 * ---
 *
 * ### *Navigate a Viewer's camera with mouse and touch input*
 *
 * ---
 *
 * * Use {@link CameraControl} to control a {@link @xeokit/viewer!Camera}, which belongs to a {@link @xeokit/viewer!View | View}, which belongs to a {@link @xeokit/viewer!Viewer | Viewer}.
 * * Reads touch, mouse and keyboard input
 * * Three navigation modes:  {@link @xeokit/constants!OrbitNavigationMode}, {@link @xeokit/constants!FirstPersonNavigationMode} and {@link @xeokit/constants!PlanViewNavigationMode}.
 * * Dynamic key mapping
 * * Smart-pivot
 * * Move-to-pointer
 * * Distance-scaled rate of movement
 * * Inertia
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/cameracontrol
 * ````
 *
 * ## Usage
 *
 * Using a {@link CameraControl} to control a {@link @xeokit/viewer!View | View's} {@link @xeokit/viewer!Camera} :
 *
 * ````javascript
 * import {Viewer} from "@xeokit/viewer";
 * import {WebGLRenderer} from "@xeokit/webglrenderer";
 * import {CameraControl} from "@xeokit/cameracontrol";
 *
 * const myViewer = new Viewer({
 *     id: "myViewer",
 *     renderer: new WebGLRenderer({
 *         //...
 *     })
 * });
 *
 * const myView = myViewer.createView({
 *     id: "myView",
 *     canvasId: "myView1"
 * });
 *
 * const myCameraControl = new CameraControl({
 *      view: myView
 * });
 *
 * //...
 * ````
 *
 * @module @xeokit/cameracontrol
 */

var index$2 = {
  __proto__: null,
  keycodes: keycodes,
  CameraControl: CameraControl
};

/**
 * Loads a {@link @xeokit/bcf!BCFViewpoint} into a {@link @xeokit/viewer!View | View} or a {@link @xeokit/viewer!ViewLayer | ViewLayer}.
 *
 * See {@link "@xeokit/bcf"} for usage.
 *
 * @param params BCF viewpoint loading paremeters.
 */
function loadBCFViewpoint(params) {}

/**
 * Saves a {@link @xeokit/viewer!View | View} or a {@link @xeokit/viewer!ViewLayer | ViewLayer} to a {@link @xeokit/bcf!BCFViewpoint}.
 *
 * See {@link @xeokit/bcf} for usage.
 *
 * @param params BCF saving parameers.
 * @returns The BCF viewpoint.
 */
function saveBCFViewpoint(params) {
  return {};
}

/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2Fbcf.svg)](https://badge.fury.io/js/%40xeokit%2Fbcf)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/bcf/badge)](https://www.jsdelivr.com/package/npm/@xeokit/bcf)
 *
 * <img style="padding:20px; padding-bottom:10px; " src="media://images/xeokit_bcf_logo.png"/>
 *
 * # xeokit BCF Viewpoint Importer and Exporter
 *
 * ---
 *
 * ### *Interoperate with other BIM software through the exchange of BCF viewpoints*
 *
 * ---
 *
 * The xeokit SDK uses the [BCF](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#bcf) format to exchange bookmarks of Viewer state with other
 * BIM software. BCF (Building Collaboration Format) is an open file format that enables data exchange and collaboration on 3D models and building
 * information. A *BCF viewpoint* is a snapshot of a specific issue related to a building project, containing information such as the
 * problem description, location, and proposed solutions. It is used to facilitate communication and collaboration among
 * project stakeholders in BIM workflows.
 *
 * To import a JSON-encoded BCF viewpoint into a {@link @xeokit/viewer!View | View} belonging to a {@link @xeokit/viewer!Viewer | Viewer}, use the
 * {@link @xeokit/bcf!loadBCFViewpoint} function. Similarly, to export the state of a View as a JSON-encoded BCF viewpoint, use
 * the {@link @xeokit/bcf!saveBCFViewpoint} function.
 *
 * Refer to {@link @xeokit/bcf!BCFViewpoint} for information on the BCF viewpoint format.
 *
 * <br>
 *
 * [![](https://mermaid.ink/img/pako:eNqlVFFP2zAQ_ivRPUJADe2oZKE-UMRTJlWrxsNmhNz4CkaJbcVOR1f1v2O7SUiyaGJaH1rfd9999-Uu9QEyxREIZDkz5k6w55IVVFLJRYmZFUpG6Tcfh3z0IPAXltGBysh9zqOdiw2Vxz6jTQvenHK2x_JPZurhaISvNq-ufb8gVYzfLu99nVZC2hVzXk1TfXOjfYwWy8Wikdlk25be9dw2dNIVx7R2dwLxrQd2HOQDBx-9t5UM0_KtOwVrtsN_tPwf9syg21_snRZJIaFwcbGgcEbhITQO30M49KJyfAEUJjU7aUQ-QeymqRwOtmGNC5Hou0ETtcMz_onGRz1i7hPEvrnhWBvWuNCouWZDXXq9nNNStSNq_4fb4VPmCktGPHn1AS8D2q3JhUQTaKk7_Xzs5jbCFkyfsrfh3M9nudBayOcnnbNGZVljKw_16UY6sRdlA29dBz09VWglUdpaqg3D-wYxOPMFE9zdNOG5KdgXLJACcUeOW1blloIjOyqrrFrvZQbElhXGUGnOLNZ3E5Aty41DNZNADvAGZBLDHsg0uZwm1_PJbH41mU3nX2ZXxxh-K-UqkhiQC6vKr_Vd53-Cwo-Q922O73wUsH8?type=png)](https://mermaid.live/edit#pako:eNqlVFFP2zAQ_ivRPUJADe2oZKE-UMRTJlWrxsNmhNz4CkaJbcVOR1f1v2O7SUiyaGJaH1rfd9999-Uu9QEyxREIZDkz5k6w55IVVFLJRYmZFUpG6Tcfh3z0IPAXltGBysh9zqOdiw2Vxz6jTQvenHK2x_JPZurhaISvNq-ufb8gVYzfLu99nVZC2hVzXk1TfXOjfYwWy8Wikdlk25be9dw2dNIVx7R2dwLxrQd2HOQDBx-9t5UM0_KtOwVrtsN_tPwf9syg21_snRZJIaFwcbGgcEbhITQO30M49KJyfAEUJjU7aUQ-QeymqRwOtmGNC5Hou0ETtcMz_onGRz1i7hPEvrnhWBvWuNCouWZDXXq9nNNStSNq_4fb4VPmCktGPHn1AS8D2q3JhUQTaKk7_Xzs5jbCFkyfsrfh3M9nudBayOcnnbNGZVljKw_16UY6sRdlA29dBz09VWglUdpaqg3D-wYxOPMFE9zdNOG5KdgXLJACcUeOW1blloIjOyqrrFrvZQbElhXGUGnOLNZ3E5Aty41DNZNADvAGZBLDHsg0uZwm1_PJbH41mU3nX2ZXxxh-K-UqkhiQC6vKr_Vd53-Cwo-Q922O73wUsH8)
 *
 * <br>
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/bcf
 * ````
 *
 * ## Usage
 *
 * ### Saving and Loading a View as BCF
 *
 * In this example we'll set up a xeokit Viewer in a web browser, load a BIM model into it, and then demonstrate how we
 * can save and load bookmarks of our Viewer state as BCF viewpoints, using the model.
 *
 * We'll start with these steps:
 *
 * * create a {@link @xeokit/scene!Scene | Scene} and a {@link @xeokit/data!Data | Data},
 * * initialize a Viewer with the Scene and a {@link @xeokit/webglrenderer!WebGLRenderer | WebGLRenderer},
 * * create a new {@link @xeokit/viewer!View | View}, {@link @xeokit/scene!SceneModel | SceneModel} and {@link @xeokit/data!DataModel | DataModel},
 * * load an [XKT](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#xkt) file using the {@link @xeokit/xkt!loadXKT | loadXKT} function, and
 * * build the Scene and Data models, rendering the 3D model in the web browser.
 *
 * ````javascript
 * import {Scene} from "@xeokit/scene";
 * import {Data} from "@xeoki/data";
 * import {Viewer} from "@xeokit/viewer";
 * import {WebGLRenderer} from "@xeokit/webglrenderer";
 * import {loadXKT} from "@xeokit/loadXKT";
 * import {saveBCFViewpoint, loadBCFViewpoint} from "@xeokit/bcf";
 * import * as ifcTypes from "@xeokit/ifctypes";
 *
 * const scene = new Scene();
 * const data = new Data();
 *
 * const viewer = new Viewer({
 *      scene,
 *      renderer: new WebGLRenderer()
 * });
 *
 * const view = viewer.createView({
 *     id: "myView",
 *     canvasId: "myCanvas"
 * });
 *
 * const sceneModel = scene.createModel({
 *     id: "myModel"
 * });
 *
 * const dataModel = data.createModel({
 *     id: "myModel"
 * });
 *
 * fetch("myModel.xkt").then(response => {
 *     response.arrayBuffer().then(data => {
 *
 *          loadXKT({ data, sceneModel, dataModel });
 *
 *          sceneModel.build();
 *          dataModel.build();
 *     });
 * });
 * ````
 *
 * When our [XKT](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#xkt) has loaded, that call to {@link @xeokit/scene!SceneModel.build | SceneModel.build} will finalize our SceneModel
 * and cause it to immediately appear in the View's canvas.
 *
 * That call will also trigger {@link @xeokit/scene!SceneModel.onBuilt | SceneModel.onBuilt} and
 * {@link @xeokit/data!DataModel.onBuilt | DataModel.onBuilt} events.
 *
 * On the DataModel.onBuilt event, we'll customize the View by arranging the {@link @xeokit/viewer!Camera} and applying
 * an X-ray effect tp a couple of objects, then we'll use {@link @xeokit/bcf!saveBCFViewpoint} to save the state of the View to
 * a BCF viewpoint.
 *
 * Once the SceneModel and DataModel have been built, we can no longer add anything to them.
 *
 * ````javascript
 * dataModel.onBuilt.one(()=>{
 *
 *     view.camera.eye = [0,0,-33];
 *     view.camera.look = [0,0,0];
 *     view.camera.up = [0,0,0];
 *
 *     view.setObjectsVisible(view.objectIds, false);
 *     view.setObjectsVisible(["myObject1", "myObject2", "myObject3", ...], true);
 *
 *     view.setObjectsXRayed(["myObject1", "myObject", ...], true);
 *
 *     const bcfViewpoint = saveBCFViewpoint({
 *         view: view
 *     });
 *
 * });
 * ````
 *
 * Now that we've saved the {@link @xeokit/bcf!BCFViewpoint}, we could now use {@link @xeokit/bcf!loadBCFViewpoint} to load
 * the {@link @xeokit/bcf!BCFViewpoint} back into the {@link @xeokit/viewer!View | View}:
 *
 * ````javascript
 * loadBCFViewpoint({
 *     bcfViewpoint,
 *     view
 * });
 * ````
 *
 * ### Saving and Loading a ViewLayer as BCF
 *
 * As before, let's create a Viewer with a View and a SceneModel.
 *
 * This time, we'll add two {@link @xeokit/viewer!ViewLayer | ViewLayers} to our View, and we'll associate our SceneModel with one of those
 * ViewLayers. ViewLayers allow us to partition our ViewObjects into bins, so that we can conveniently focus certain operations (eg. import/export
 * BCF) only on the relevant ViewObjects.
 *
 * ````javascript
 * import {Scene} from "@xeokit/scene";
 * import {Data} from "@xeoki/data";
 * import {Viewer} from "@xeokit/viewer";
 * import {WebGLRenderer} from "@xeokit/webglrenderer";
 * import {loadBCFViewpoint} from "@xeokit/bcf";
 *
 * const viewer = new Viewer({
 *     id: "myViewer",
 *     scene,
 *     renderer: new WebGLRenderer({
 *         //...
 *     })
 * });
 *
 * const view = viewer.createView({
 *     id: "myView",
 *     canvasId: "myView1"
 * });
 *
 * const foregroundViewLayer = view.createLayer({
 *     id: "foreground"
 * });
 *
 * const backgroundViewLayer = view.createLayer({
 *     id: "background"
 * });
 *
 * const sceneModel = scene.createModel({
 *      id: "myModel",
 *      layerId: "foreground"
 * });
 *
 * //...create some objects, load XKT etc
 *
 * sceneModel.build();
 *
 * const myOtherSceneModel = scene.createModel({
 *      id: "myOtherModel",
 *      layerId: "background"
 * });
 *
 * //...create some objects, load XKT etc
 *
 * myOtherSceneModel.build();
 * ````
 *
 * Now we can use {@link @xeokit/bcf!saveBCFViewpoint} to save the states of only the {@link @xeokit/viewer!ViewObject | ViewObjects} in the
 * {@link @xeokit/viewer!ViewLayer | ViewLayer} that contains our SceneModel to a {@link @xeokit/bcf!BCFViewpoint}, while ignoring the
 * other ViewLayer:
 *
 * ````javascript
 * const bcfViewpoint = saveBCFViewpoint({
 *      view,
 *      includeViewLayerIds: ["foreground"],
 *      excludeViewLayerIds: ["background"] // Unnecessary, but we'll show it anyway
 * });
 * ````
 *
 * Use {@link @xeokit/bcf!loadBCFViewpoint} to load the {@link @xeokit/bcf!BCFViewpoint} back into the {@link @xeokit/viewer!ViewLayer | ViewLayer}:
 *
 * ````javascript
 * loadBCFViewpoint({
 *     bcfViewpoint,
 *     view,
 *     includeViewLayerIds: ["foreground"],
 *     excludeViewLayerIds: ["background"]
 * });
 * ````
 *
 * @module @xeokit/bcf
 */

var index$1 = {
  __proto__: null,
  loadBCFViewpoint: loadBCFViewpoint,
  saveBCFViewpoint: saveBCFViewpoint
};

/**
 * An HTMl tree view that navigates the {@link @xeokit/data!DataObject | DataObjects} in the given
 * {@link @xeokit/data!Data | Data}, while controlling the visibility of their corresponding
 * {@link @xeokit/viewer!ViewObject | ViewObjects} in the given {@link @xeokit/viewer!View | View}.
 *
 * See {@link "@xeokit/treeview"} for usage.
 */
var _linkType = /*#__PURE__*/_classPrivateFieldLooseKey("linkType");
var _groupTypes = /*#__PURE__*/_classPrivateFieldLooseKey("groupTypes");
var _containerElement = /*#__PURE__*/_classPrivateFieldLooseKey("containerElement");
var _hierarchy = /*#__PURE__*/_classPrivateFieldLooseKey("hierarchy");
var _dataModels = /*#__PURE__*/_classPrivateFieldLooseKey("dataModels");
var _autoAddModels = /*#__PURE__*/_classPrivateFieldLooseKey("autoAddModels");
var _autoExpandDepth = /*#__PURE__*/_classPrivateFieldLooseKey("autoExpandDepth");
var _sortNodes = /*#__PURE__*/_classPrivateFieldLooseKey("sortNodes");
var _pruneEmptyNodes = /*#__PURE__*/_classPrivateFieldLooseKey("pruneEmptyNodes");
var _viewer = /*#__PURE__*/_classPrivateFieldLooseKey("viewer");
var _rootElement = /*#__PURE__*/_classPrivateFieldLooseKey("rootElement");
var _muteSceneEvents = /*#__PURE__*/_classPrivateFieldLooseKey("muteSceneEvents");
var _muteTreeEvents = /*#__PURE__*/_classPrivateFieldLooseKey("muteTreeEvents");
var _rootNodes = /*#__PURE__*/_classPrivateFieldLooseKey("rootNodes");
var _objectNodes = /*#__PURE__*/_classPrivateFieldLooseKey("objectNodes");
var _rootName = /*#__PURE__*/_classPrivateFieldLooseKey("rootName");
var _showListItemElementId = /*#__PURE__*/_classPrivateFieldLooseKey("showListItemElementId");
var _spatialSortFunc = /*#__PURE__*/_classPrivateFieldLooseKey("spatialSortFunc");
var _switchExpandHandler = /*#__PURE__*/_classPrivateFieldLooseKey("switchExpandHandler");
var _switchCollapseHandler = /*#__PURE__*/_classPrivateFieldLooseKey("switchCollapseHandler");
var _checkboxChangeHandler = /*#__PURE__*/_classPrivateFieldLooseKey("checkboxChangeHandler");
var _destroyed = /*#__PURE__*/_classPrivateFieldLooseKey("destroyed");
var _onViewObjectVisibility = /*#__PURE__*/_classPrivateFieldLooseKey("onViewObjectVisibility");
var _onViewObjectXRayed = /*#__PURE__*/_classPrivateFieldLooseKey("onViewObjectXRayed");
var _dataObjectSceneObjectCounts = /*#__PURE__*/_classPrivateFieldLooseKey("dataObjectSceneObjectCounts");
var _addModel = /*#__PURE__*/_classPrivateFieldLooseKey("addModel");
var _removeModel = /*#__PURE__*/_classPrivateFieldLooseKey("removeModel");
var _rebuildNodes = /*#__PURE__*/_classPrivateFieldLooseKey("rebuildNodes");
var _validate = /*#__PURE__*/_classPrivateFieldLooseKey("validate");
var _validateMetaModelForStoreysHierarchy = /*#__PURE__*/_classPrivateFieldLooseKey("validateMetaModelForStoreysHierarchy");
var _createEnabledNodes = /*#__PURE__*/_classPrivateFieldLooseKey("createEnabledNodes");
var _createDisabledNodes = /*#__PURE__*/_classPrivateFieldLooseKey("createDisabledNodes");
var _findEmptyNodes = /*#__PURE__*/_classPrivateFieldLooseKey("findEmptyNodes");
var _findEmptyNodes3 = /*#__PURE__*/_classPrivateFieldLooseKey("findEmptyNodes2");
var _buildGroupsNodes = /*#__PURE__*/_classPrivateFieldLooseKey("buildGroupsNodes");
var _buildGroupsNodes3 = /*#__PURE__*/_classPrivateFieldLooseKey("buildGroupsNodes2");
var _buildTypesNodes = /*#__PURE__*/_classPrivateFieldLooseKey("buildTypesNodes");
var _buildTypesNodes3 = /*#__PURE__*/_classPrivateFieldLooseKey("buildTypesNodes2");
var _buildAggregationNodes = /*#__PURE__*/_classPrivateFieldLooseKey("buildAggregationNodes");
var _buildAggregationNodes3 = /*#__PURE__*/_classPrivateFieldLooseKey("buildAggregationNodes2");
var _doSortNodes = /*#__PURE__*/_classPrivateFieldLooseKey("doSortNodes");
var _sortChildNodes = /*#__PURE__*/_classPrivateFieldLooseKey("sortChildNodes");
var _getSpatialSortFunc = /*#__PURE__*/_classPrivateFieldLooseKey("getSpatialSortFunc");
var _alphaSortFunc = /*#__PURE__*/_classPrivateFieldLooseKey("alphaSortFunc");
var _synchNodesToEntities = /*#__PURE__*/_classPrivateFieldLooseKey("synchNodesToEntities");
var _withNodeTree = /*#__PURE__*/_classPrivateFieldLooseKey("withNodeTree");
var _createNodeElements = /*#__PURE__*/_classPrivateFieldLooseKey("createNodeElements");
var _createNodeElement = /*#__PURE__*/_classPrivateFieldLooseKey("createNodeElement");
var _expandSwitchElement = /*#__PURE__*/_classPrivateFieldLooseKey("expandSwitchElement");
var _collapseNode = /*#__PURE__*/_classPrivateFieldLooseKey("collapseNode");
var _collapseSwitchElement = /*#__PURE__*/_classPrivateFieldLooseKey("collapseSwitchElement");
var TreeView = /*#__PURE__*/function (_Component) {
  _inheritsLoose(TreeView, _Component);
  /**
   *
   * TODO
   *
   * @param params
   */
  function TreeView(params) {
    var _this;
    _this = _Component.call(this, null) || this;
    Object.defineProperty(_assertThisInitialized(_this), _collapseSwitchElement, {
      value: _collapseSwitchElement2
    });
    Object.defineProperty(_assertThisInitialized(_this), _collapseNode, {
      value: _collapseNode2
    });
    Object.defineProperty(_assertThisInitialized(_this), _expandSwitchElement, {
      value: _expandSwitchElement2
    });
    Object.defineProperty(_assertThisInitialized(_this), _createNodeElement, {
      value: _createNodeElement2
    });
    Object.defineProperty(_assertThisInitialized(_this), _createNodeElements, {
      value: _createNodeElements2
    });
    Object.defineProperty(_assertThisInitialized(_this), _withNodeTree, {
      value: _withNodeTree2
    });
    Object.defineProperty(_assertThisInitialized(_this), _synchNodesToEntities, {
      value: _synchNodesToEntities2
    });
    Object.defineProperty(_assertThisInitialized(_this), _alphaSortFunc, {
      value: _alphaSortFunc2
    });
    Object.defineProperty(_assertThisInitialized(_this), _getSpatialSortFunc, {
      value: _getSpatialSortFunc2
    });
    Object.defineProperty(_assertThisInitialized(_this), _sortChildNodes, {
      value: _sortChildNodes2
    });
    Object.defineProperty(_assertThisInitialized(_this), _doSortNodes, {
      value: _doSortNodes2
    });
    Object.defineProperty(_assertThisInitialized(_this), _buildAggregationNodes3, {
      value: _buildAggregationNodes4
    });
    Object.defineProperty(_assertThisInitialized(_this), _buildAggregationNodes, {
      value: _buildAggregationNodes2
    });
    Object.defineProperty(_assertThisInitialized(_this), _buildTypesNodes3, {
      value: _buildTypesNodes4
    });
    Object.defineProperty(_assertThisInitialized(_this), _buildTypesNodes, {
      value: _buildTypesNodes2
    });
    Object.defineProperty(_assertThisInitialized(_this), _buildGroupsNodes3, {
      value: _buildGroupsNodes4
    });
    Object.defineProperty(_assertThisInitialized(_this), _buildGroupsNodes, {
      value: _buildGroupsNodes2
    });
    Object.defineProperty(_assertThisInitialized(_this), _findEmptyNodes3, {
      value: _findEmptyNodes4
    });
    Object.defineProperty(_assertThisInitialized(_this), _findEmptyNodes, {
      value: _findEmptyNodes2
    });
    Object.defineProperty(_assertThisInitialized(_this), _createDisabledNodes, {
      value: _createDisabledNodes2
    });
    Object.defineProperty(_assertThisInitialized(_this), _createEnabledNodes, {
      value: _createEnabledNodes2
    });
    Object.defineProperty(_assertThisInitialized(_this), _validateMetaModelForStoreysHierarchy, {
      value: _validateMetaModelForStoreysHierarchy2
    });
    Object.defineProperty(_assertThisInitialized(_this), _validate, {
      value: _validate2
    });
    Object.defineProperty(_assertThisInitialized(_this), _rebuildNodes, {
      value: _rebuildNodes2
    });
    /**
     * Removes a model from this tree view.
     *
     * @private
     * @param {String} modelId ID of a model {@link viewObject} in {@link @xeokit/scene!Scene#models}.
     */
    Object.defineProperty(_assertThisInitialized(_this), _removeModel, {
      value: _removeModel2
    });
    /**
     * Adds a model to this tree view.
     *
     * @private
     * @param {String} modelId ID of a model {@link viewObject} in {@link @xeokit/scene!Scene#models}.
     * @param {Object} [options] Options for model in the tree view.
     * @param {String} [options.rootName] Optional display name for the root node. Ordinary, for "containment"
     * and {@link @xeokit/treeview!TreeView.GroupsHierarchy | GroupsHierarchy} hierarchy types, the tree would derive the root node name from the model's "IfcProject" element
     * name. This option allows to override that name when it is not suitable as a display name.
     */
    Object.defineProperty(_assertThisInitialized(_this), _addModel, {
      value: _addModel2
    });
    /**
     * The semantic {@link @xeokit/data!Data | Data} model that determines the structure of this TreeView.
     */
    _this.data = void 0;
    /**
     * The {@link @xeokit/viewer!View | View} that contains the {@link @xeokit/viewer!ViewObject | ViewObjects}
     * navigated by this TreeView.
     */
    _this.view = void 0;
    /**
     * Emits an event each time the title of a node is clicked in the tree view.
     *
     * @event
     */
    _this.onNodeTitleClicked = void 0;
    /**
     * Emits an event each time we right-click on a tree node.
     *
     * @event
     */
    _this.onContextMenu = void 0;
    Object.defineProperty(_assertThisInitialized(_this), _linkType, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _groupTypes, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _containerElement, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _hierarchy, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _dataModels, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _autoAddModels, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _autoExpandDepth, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _sortNodes, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _pruneEmptyNodes, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _viewer, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _rootElement, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _muteSceneEvents, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _muteTreeEvents, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _rootNodes, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _objectNodes, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _rootName, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _showListItemElementId, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _spatialSortFunc, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _switchExpandHandler, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _switchCollapseHandler, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _checkboxChangeHandler, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _destroyed, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _onViewObjectVisibility, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _onViewObjectXRayed, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized(_this), _dataObjectSceneObjectCounts, {
      writable: true,
      value: void 0
    });
    if (!params.containerElement) {
      throw new Error("Config expected: containerElement");
    }
    if (!params.data) {
      throw new Error("Config expected: data");
    }
    if (!params.view) {
      throw new Error("Config expected: view");
    }
    _this.data = params.data;
    _this.view = params.view;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _viewer)[_viewer] = params.view.viewer;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _linkType)[_linkType] = params.linkType;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _groupTypes)[_groupTypes] = params.groupTypes;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _hierarchy)[_hierarchy] = TreeView.AggregationHierarchy;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _containerElement)[_containerElement] = params.containerElement;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _dataModels)[_dataModels] = {};
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _autoExpandDepth)[_autoExpandDepth] = params.autoExpandDepth || 0;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _sortNodes)[_sortNodes] = params.sortNodes !== false;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _pruneEmptyNodes)[_pruneEmptyNodes] = params.pruneEmptyNodes !== false;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _rootElement)[_rootElement] = null;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _muteSceneEvents)[_muteSceneEvents] = false;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _muteTreeEvents)[_muteTreeEvents] = false;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _rootNodes)[_rootNodes] = [];
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _objectNodes)[_objectNodes] = {}; // Object ID -> TreeViewNode
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _rootName)[_rootName] = params.rootName;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _sortNodes)[_sortNodes] = params.sortNodes;
    // @ts-ignore
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _pruneEmptyNodes)[_pruneEmptyNodes] = params.pruneEmptyNodes;
    // @ts-ignore
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _showListItemElementId)[_showListItemElementId] = null;
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _destroyed)[_destroyed] = false;
    _this.onNodeTitleClicked = new EventEmitter(new dist.EventDispatcher());
    _this.onContextMenu = new EventEmitter(new dist.EventDispatcher());
    _this.onDestroyed = new EventEmitter(new dist.EventDispatcher());
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _containerElement)[_containerElement].oncontextmenu = function (e) {
      e.preventDefault();
    };
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _onViewObjectVisibility)[_onViewObjectVisibility] = _this.view.onObjectVisibility.subscribe(function (view, viewObject) {
      if (_classPrivateFieldLooseBase(_assertThisInitialized(_this), _muteSceneEvents)[_muteSceneEvents]) {
        return;
      }
      var objectId = viewObject.id;
      // @ts-ignore
      var node = _classPrivateFieldLooseBase(_assertThisInitialized(_this), _objectNodes)[_objectNodes][objectId];
      if (!node) {
        return; // Not in this tree
      }

      var visible = viewObject.visible;
      var updated = visible !== node.checked;
      if (!updated) {
        return;
      }
      _classPrivateFieldLooseBase(_assertThisInitialized(_this), _muteTreeEvents)[_muteTreeEvents] = true;
      node.checked = visible;
      if (visible) {
        node.numVisibleViewObjects++;
      } else {
        node.numVisibleViewObjects--;
      }
      var checkbox = document.getElementById(node.nodeId);
      if (checkbox) {
        checkbox.checked = visible;
      }
      var parentNode = node.parentNode;
      while (parentNode) {
        parentNode.checked = visible;
        if (visible) {
          parentNode.numVisibleViewObjects++;
        } else {
          parentNode.numVisibleViewObjects--;
        }
        var parentCheckbox = document.getElementById(parentNode.nodeId);
        if (parentCheckbox) {
          var newChecked = parentNode.numVisibleViewObjects > 0;
          if (newChecked !== parentCheckbox.checked) {
            parentCheckbox.checked = newChecked;
          }
        }
        parentNode = parentNode.parentNode;
      }
      _classPrivateFieldLooseBase(_assertThisInitialized(_this), _muteTreeEvents)[_muteTreeEvents] = false;
    });
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _onViewObjectXRayed)[_onViewObjectXRayed] = _this.view.onObjectXRayed.subscribe(function (view, viewObject) {
      if (_classPrivateFieldLooseBase(_assertThisInitialized(_this), _muteSceneEvents)[_muteSceneEvents]) {
        return;
      }
      var objectId = viewObject.id;
      var node = _classPrivateFieldLooseBase(_assertThisInitialized(_this), _objectNodes)[_objectNodes][objectId];
      if (!node) {
        return; // Not in this tree
      }

      _classPrivateFieldLooseBase(_assertThisInitialized(_this), _muteTreeEvents)[_muteTreeEvents] = true;
      var xrayed = viewObject.xrayed;
      var updated = xrayed !== node.xrayed;
      if (!updated) {
        return;
      }
      node.xrayed = xrayed;
      var listItemElementId = 'node-' + node.nodeId;
      var listItemElement = document.getElementById(listItemElementId);
      if (listItemElement !== null) {
        if (xrayed) {
          listItemElement.classList.add('xrayed-node');
        } else {
          listItemElement.classList.remove('xrayed-node');
        }
      }
      _classPrivateFieldLooseBase(_assertThisInitialized(_this), _muteTreeEvents)[_muteTreeEvents] = false;
    });
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _switchExpandHandler)[_switchExpandHandler] = function (event) {
      event.preventDefault();
      event.stopPropagation();
      var switchElement = event.target;
      _classPrivateFieldLooseBase(_assertThisInitialized(_this), _expandSwitchElement)[_expandSwitchElement](switchElement);
    };
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _switchCollapseHandler)[_switchCollapseHandler] = function (event) {
      event.preventDefault();
      event.stopPropagation();
      var switchElement = event.target;
      _classPrivateFieldLooseBase(_assertThisInitialized(_this), _collapseSwitchElement)[_collapseSwitchElement](switchElement);
    };
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _checkboxChangeHandler)[_checkboxChangeHandler] = function (event) {
      if (_classPrivateFieldLooseBase(_assertThisInitialized(_this), _muteTreeEvents)[_muteTreeEvents]) {
        return;
      }
      _classPrivateFieldLooseBase(_assertThisInitialized(_this), _muteSceneEvents)[_muteSceneEvents] = true;
      var checkbox = event.target;
      var visible = checkbox.checked;
      var nodeId = checkbox.id;
      var checkedObjectId = nodeId;
      var checkedNode = _classPrivateFieldLooseBase(_assertThisInitialized(_this), _objectNodes)[_objectNodes][checkedObjectId];
      var objects = _this.view.objects;
      var numUpdated = 0;
      _classPrivateFieldLooseBase(_assertThisInitialized(_this), _withNodeTree)[_withNodeTree](checkedNode, function (node) {
        var objectId = node.objectId;
        var checkBoxId = node.nodeId;
        var viewObject = objects[objectId];
        var isLeaf = node.childNodes.length === 0;
        node.numVisibleViewObjects = visible ? node.numViewObjects : 0;
        if (isLeaf && visible !== node.checked) {
          numUpdated++;
        }
        node.checked = visible;
        var checkbox2 = document.getElementById(checkBoxId);
        if (checkbox2) {
          checkbox2.checked = visible;
        }
        if (viewObject) {
          viewObject.visible = visible;
        }
      });
      var parentNode = checkedNode.parentNode;
      while (parentNode) {
        parentNode.checked = visible;
        var checkbox2 = document.getElementById(parentNode.nodeId); // Parent checkboxes are always in DOM
        if (visible) {
          parentNode.numVisibleViewObjects += numUpdated;
        } else {
          parentNode.numVisibleViewObjects -= numUpdated;
        }
        var newChecked = parentNode.numVisibleViewObjects > 0;
        if (newChecked !== checkbox2.checked) {
          checkbox2.checked = newChecked;
        }
        parentNode = parentNode.parentNode;
      }
      _classPrivateFieldLooseBase(_assertThisInitialized(_this), _muteSceneEvents)[_muteSceneEvents] = false;
    };
    _this.hierarchy = params.hierarchy;
    var modelIds = Object.keys(_this.data.models);
    for (var i = 0, len = modelIds.length; i < len; i++) {
      var modelId = modelIds[i];
      _classPrivateFieldLooseBase(_assertThisInitialized(_this), _addModel)[_addModel](modelId);
    }
    _classPrivateFieldLooseBase(_assertThisInitialized(_this), _viewer)[_viewer].scene.onModelCreated.subscribe(function (scene, sceneModel) {
      if (_this.data.models[sceneModel.id]) {
        _classPrivateFieldLooseBase(_assertThisInitialized(_this), _addModel)[_addModel](sceneModel.id);
      }
    });
    return _this;
  }
  /**
   * Gets how the nodes are organized within this tree view.
   *
   * Accepted values are:
   *
   * * {@link TreeView.AggregationHierarchy} (default)
   * * {@link TreeView.TypesHierarchy}
   * * {@link TreeView.GroupsHierarchy}
   */
  var _proto = TreeView.prototype;
  /**
   * Highlights the tree view node that represents the given object {@link viewObject}.
   *
   * This causes the tree view to collapse, then expand to reveal the node, then highlight the node.
   *
   * If a node is previously highlighted, de-highlights that node and collapses the tree first.
   *
   * Note that if the TreeView was configured with ````pruneEmptyNodes: true```` (default configuration), then the
   * node won't exist in the tree if it has no viewObjects in the {@link @xeokit/scene!Scene}. in that case, nothing will happen.
   *
   * Within the DOM, the node is represented by an ````<li>```` element. This method will add a ````.highlighted-node```` class to
   * the element to make it appear highlighted, removing that class when de-highlighting it again. See the CSS rules
   * in the TreeView ifcviewer for an example of that class.
   *
   * @param {String} objectId ID of the {@link viewObject}.
   */
  _proto.showNode = function showNode(objectId) {
    if (_classPrivateFieldLooseBase(this, _showListItemElementId)[_showListItemElementId]) {
      this.unShowNode();
    }
    var node = _classPrivateFieldLooseBase(this, _objectNodes)[_objectNodes][objectId];
    if (!node) {
      return; // TreeViewNode may not exist for the given object if (this.#pruneEmptyNodes == true)
    }

    var nodeId = node.nodeId;
    var switchElementId = "switch-" + nodeId;
    var switchElement = document.getElementById(switchElementId);
    if (switchElement) {
      _classPrivateFieldLooseBase(this, _expandSwitchElement)[_expandSwitchElement](switchElement);
      switchElement.scrollIntoView();
      return;
    }
    var path = [];
    path.unshift(node);
    var parentNode = node.parentNode;
    while (parentNode) {
      path.unshift(parentNode);
      parentNode = parentNode.parentNode;
    }
    for (var i = 0, len = path.length; i < len; i++) {
      var _node = path[i];
      var _nodeId = _node.nodeId;
      var _switchElementId = "switch-" + _nodeId;
      var _switchElement = document.getElementById(_switchElementId);
      if (_switchElement) {
        _classPrivateFieldLooseBase(this, _expandSwitchElement)[_expandSwitchElement](_switchElement);
      }
    }
    var listItemElementId = 'node-' + nodeId;
    var listItemElement = document.getElementById(listItemElementId);
    // @ts-ignore
    listItemElement.scrollIntoView({
      block: "center"
    });
    // @ts-ignore
    listItemElement.classList.add("highlighted-node");
    _classPrivateFieldLooseBase(this, _showListItemElementId)[_showListItemElementId] = listItemElementId;
  }
  /**
   * De-highlights the node previously shown with {@link TreeView#showNode}.
   *
   * Does nothing if no node is currently shown.
   *
   * If the node is currently scrolled into view, keeps the node in view.
   */;
  _proto.unShowNode = function unShowNode() {
    if (!_classPrivateFieldLooseBase(this, _showListItemElementId)[_showListItemElementId]) {
      return;
    }
    var listItemElement = document.getElementById(_classPrivateFieldLooseBase(this, _showListItemElementId)[_showListItemElementId]);
    if (!listItemElement) {
      _classPrivateFieldLooseBase(this, _showListItemElementId)[_showListItemElementId] = null;
      return;
    }
    listItemElement.classList.remove("highlighted-node");
    _classPrivateFieldLooseBase(this, _showListItemElementId)[_showListItemElementId] = null;
  }
  /**
   * Expands the tree to the given depth.
   *
   * Collapses the tree first.
   *
   * @param depth Depth to expand to.
   */;
  _proto.expandToDepth = function expandToDepth(depth) {
    var _this2 = this;
    this.collapse();
    var expand = function expand(node, countDepth) {
      if (countDepth === depth) {
        return;
      }
      var nodeId = node.nodeId;
      var switchElementId = "switch-" + nodeId;
      var switchElement = document.getElementById(switchElementId);
      if (switchElement) {
        _classPrivateFieldLooseBase(_this2, _expandSwitchElement)[_expandSwitchElement](switchElement);
        var childNodes = node.childNodes;
        for (var i = 0, len = childNodes.length; i < len; i++) {
          var childNode = childNodes[i];
          expand(childNode, countDepth + 1);
        }
      }
    };
    for (var i = 0, len = _classPrivateFieldLooseBase(this, _rootNodes)[_rootNodes].length; i < len; i++) {
      var rootNode = _classPrivateFieldLooseBase(this, _rootNodes)[_rootNodes][i];
      expand(rootNode, 0);
    }
  }
  /**
   * Closes all the nodes in the tree.
   */;
  _proto.collapse = function collapse() {
    for (var i = 0, len = _classPrivateFieldLooseBase(this, _rootNodes)[_rootNodes].length; i < len; i++) {
      var rootNode = _classPrivateFieldLooseBase(this, _rootNodes)[_rootNodes][i];
      var objectId = rootNode.objectId;
      _classPrivateFieldLooseBase(this, _collapseNode)[_collapseNode](objectId);
    }
  }
  /**
   * Destroys this TreeView.
   */;
  _proto.destroy = function destroy() {
    if (!_classPrivateFieldLooseBase(this, _containerElement)[_containerElement]) {
      return;
    }
    _classPrivateFieldLooseBase(this, _dataModels)[_dataModels] = {};
    if (_classPrivateFieldLooseBase(this, _rootElement)[_rootElement] && !_classPrivateFieldLooseBase(this, _destroyed)[_destroyed]) {
      // @ts-ignore
      _classPrivateFieldLooseBase(this, _rootElement)[_rootElement].parentNode.removeChild(_classPrivateFieldLooseBase(this, _rootElement)[_rootElement]);
      this.view.onObjectVisibility.unsubscribe(_classPrivateFieldLooseBase(this, _onViewObjectVisibility)[_onViewObjectVisibility]);
      this.view.onObjectXRayed.unsubscribe(_classPrivateFieldLooseBase(this, _onViewObjectXRayed)[_onViewObjectXRayed]);
      _classPrivateFieldLooseBase(this, _destroyed)[_destroyed] = true;
    }
    _Component.prototype.destroy.call(this);
  };
  _createClass(TreeView, [{
    key: "hierarchy",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _hierarchy)[_hierarchy];
    }
    /**
     * Sets how the nodes are organized within this tree view.
     *
     * Accepted values are:
     *
     * * {@link TreeView.AggregationHierarchy} (default)
     * * {@link TreeView.TypesHierarchy}
     * * {@link TreeView.GroupsHierarchy}
     */,
    set: function set(hierarchy) {
      hierarchy = hierarchy !== null && hierarchy !== undefined ? hierarchy : TreeView.AggregationHierarchy;
      if (hierarchy !== TreeView.AggregationHierarchy && hierarchy !== TreeView.GroupsHierarchy && hierarchy !== TreeView.TypesHierarchy) {
        this.error("Unsupported value for `hierarchy' - defaulting to TreeView.AggregationHierarchy ");
        hierarchy = TreeView.AggregationHierarchy;
      }
      if (_classPrivateFieldLooseBase(this, _hierarchy)[_hierarchy] === hierarchy) {
        return;
      }
      _classPrivateFieldLooseBase(this, _hierarchy)[_hierarchy] = hierarchy;
      _classPrivateFieldLooseBase(this, _rebuildNodes)[_rebuildNodes]();
    }
    /**
     * When traversing the {@link @xeokit/data!Data | Data} to build the tree UI nodes, at each
     * {@link @xeokit/data!DataObject | DataObjects}, the TreeView will traverse only the outgoing
     * {@link @xeokit/data!Relationship | Relationships} of this type in
     * {@link @xeokit/data!DataObject.relating | DataObject.relating}.
     */
  }, {
    key: "linkType",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _linkType)[_linkType];
    }
    /**
     * When traversing the {@link @xeokit/data!Data | Data} to build the tree UI nodes, at each
     * {@link @xeokit/data!DataObject | DataObjects}, the TreeView will traverse only the outgoing
     * {@link @xeokit/data!Relationship | Relationships} of this type in
     * {@link @xeokit/data!DataObject.relating | DataObject.relating}.
     */,
    set: function set(linkType) {
      if (_classPrivateFieldLooseBase(this, _linkType)[_linkType] === linkType) {
        return;
      }
      _classPrivateFieldLooseBase(this, _linkType)[_linkType] = linkType;
      _classPrivateFieldLooseBase(this, _rebuildNodes)[_rebuildNodes]();
    }
    /**
     * When traversing the {@link @xeokit/data!Data | Data} to build the tree UI nodes for
     * a {@link TreeView.GroupsHierarchy}, these are the values
     * of {@link @xeokit/data!DataObject.type | DataObject.type} that the
     * TreeView groups and subgroups the {@link @xeokit/data!DataObject | DataObjects} on.
     *
     * The grouping for {@link TreeView.GroupsHierarchy} has two levels. The major grouping type is given
     * in ````groupTypes[0]```` and the minor grouping type is given in ````storeyGroups[1]````.
     *
     * Example: ````[IfcBuilding, IfcBuildingStorey]````.
     */
  }, {
    key: "groupTypes",
    get: function get() {
      return _classPrivateFieldLooseBase(this, _groupTypes)[_groupTypes];
    }
    /**
     * When traversing the {@link @xeokit/data!Data | Data} to build the tree UI nodes for
     * a {@link TreeView.GroupsHierarchy}, these are the values
     * of {@link @xeokit/data!DataObject.type | DataObject.type} that the
     * TreeView groups and subgroups the {@link @xeokit/data!DataObject | DataObjects} on.
     *
     * The grouping for the {@link @xeokit/treeview!TreeView.GroupsHierarchy | GroupsHierarchy} hierarchy has two levels. The major grouping type is given
     * in ````groupTypes[0]```` and the minor grouping type is given in ````storeyGroups[1]````.
     *
     * Example: ````[IfcBuilding, IfcBuildingStorey]````.
     */,
    set: function set(groupTypes) {
      if (_classPrivateFieldLooseBase(this, _groupTypes)[_groupTypes] === groupTypes) {
        return;
      }
      _classPrivateFieldLooseBase(this, _groupTypes)[_groupTypes] = groupTypes;
      if (_classPrivateFieldLooseBase(this, _hierarchy)[_hierarchy] === TreeView.GroupsHierarchy) {
        _classPrivateFieldLooseBase(this, _rebuildNodes)[_rebuildNodes]();
      }
    }
  }]);
  return TreeView;
}(Component);
function _addModel2(modelId, options) {
  var _this3 = this;
  if (!_classPrivateFieldLooseBase(this, _containerElement)[_containerElement]) {
    return;
  }
  var model = _classPrivateFieldLooseBase(this, _viewer)[_viewer].scene.models[modelId];
  if (!model) {
    this.error("SceneModel not found: " + modelId);
    return;
  }
  var dataModel = this.data.models[modelId];
  if (!dataModel) {
    this.error("DataModel not found: " + modelId);
    return;
  }
  if (_classPrivateFieldLooseBase(this, _dataModels)[_dataModels][modelId]) {
    this.error("Model already added: " + modelId);
    return;
  }
  _classPrivateFieldLooseBase(this, _dataModels)[_dataModels][modelId] = dataModel;
  model.onDestroyed.one(function () {
    _classPrivateFieldLooseBase(_this3, _removeModel)[_removeModel](model.id);
  });
  _classPrivateFieldLooseBase(this, _rebuildNodes)[_rebuildNodes]();
}
function _removeModel2(modelId) {
  if (!_classPrivateFieldLooseBase(this, _containerElement)[_containerElement]) {
    return;
  }
  var dataModel = _classPrivateFieldLooseBase(this, _dataModels)[_dataModels][modelId];
  if (!dataModel) {
    return;
  }
  delete _classPrivateFieldLooseBase(this, _dataModels)[_dataModels][modelId];
  _classPrivateFieldLooseBase(this, _rebuildNodes)[_rebuildNodes]();
}
function _rebuildNodes2() {
  if (_classPrivateFieldLooseBase(this, _rootElement)[_rootElement]) {
    // @ts-ignore
    _classPrivateFieldLooseBase(this, _rootElement)[_rootElement].parentNode.removeChild(_classPrivateFieldLooseBase(this, _rootElement)[_rootElement]);
    _classPrivateFieldLooseBase(this, _rootElement)[_rootElement] = null;
  }
  _classPrivateFieldLooseBase(this, _rootNodes)[_rootNodes] = [];
  _classPrivateFieldLooseBase(this, _objectNodes)[_objectNodes] = {};
  if (_classPrivateFieldLooseBase(this, _validate)[_validate]()) {
    _classPrivateFieldLooseBase(this, _createEnabledNodes)[_createEnabledNodes]();
  } else {
    _classPrivateFieldLooseBase(this, _createDisabledNodes)[_createDisabledNodes]();
  }
}
function _validate2() {
  var valid = true;
  switch (_classPrivateFieldLooseBase(this, _hierarchy)[_hierarchy]) {
    case TreeView.GroupsHierarchy:
      valid = _classPrivateFieldLooseBase(this, _rootNodes)[_rootNodes].length > 0;
      //   valid = this.#validateMetaModelForStoreysHierarchy();
      break;
    case TreeView.TypesHierarchy:
      valid = _classPrivateFieldLooseBase(this, _rootNodes)[_rootNodes].length > 0;
      break;
    case TreeView.AggregationHierarchy:
    default:
      valid = _classPrivateFieldLooseBase(this, _rootNodes)[_rootNodes].length > 0;
      break;
  }
  return valid;
}
function _validateMetaModelForStoreysHierarchy2(level, ctx, buildingNode) {
  // ctx = ctx || {
  //     foundIFCBuildingStoreys: false
  // };
  // const dataObjectType = dataObject.type;
  // const children = dataObject.children;
  // if (dataObjectType === "IfcBuilding") {
  //     buildingNode = true;
  // } else if (dataObjectType === "IfcBuildingStorey") {
  //     if (!buildingNode) {
  //         errors.push("Can't build storeys hierarchy: IfcBuildingStorey found without parent IfcBuilding");
  //         return false;
  //     }
  //     ctx.foundIFCBuildingStoreys = true;
  // }
  // if (children) {
  //     for (let i = 0, len = children.length; i < len; i++) {
  //         const aggregatedDataObject = children[i];
  //         if (!this.#validateMetaModelForStoreysHierarchy(aggregatedDataObject, errors, level + 1, ctx, buildingNode)) {
  //             return false;
  //         }
  //     }
  // }
  // if (level === 0) {
  //     if (!ctx.foundIFCBuildingStoreys) {
  //         // errors.push("Can't build storeys hierarchy: no IfcBuildingStoreys found");
  //     }
  // }
  return true;
}
function _createEnabledNodes2() {
  if (_classPrivateFieldLooseBase(this, _pruneEmptyNodes)[_pruneEmptyNodes]) {
    _classPrivateFieldLooseBase(this, _findEmptyNodes)[_findEmptyNodes]();
  }
  switch (_classPrivateFieldLooseBase(this, _hierarchy)[_hierarchy]) {
    case TreeView.GroupsHierarchy:
      _classPrivateFieldLooseBase(this, _buildGroupsNodes)[_buildGroupsNodes]();
      if (_classPrivateFieldLooseBase(this, _rootNodes)[_rootNodes].length === 0) {
        this.error("Failed to build hierarchy TreeView.GroupsHierarchy");
      }
      break;
    case TreeView.TypesHierarchy:
      _classPrivateFieldLooseBase(this, _buildTypesNodes)[_buildTypesNodes]();
      break;
    case TreeView.AggregationHierarchy:
    default:
      _classPrivateFieldLooseBase(this, _buildAggregationNodes)[_buildAggregationNodes]();
  }
  if (_classPrivateFieldLooseBase(this, _sortNodes)[_sortNodes]) {
    _classPrivateFieldLooseBase(this, _doSortNodes)[_doSortNodes]();
  }
  _classPrivateFieldLooseBase(this, _synchNodesToEntities)[_synchNodesToEntities]();
  _classPrivateFieldLooseBase(this, _createNodeElements)[_createNodeElements]();
  this.expandToDepth(_classPrivateFieldLooseBase(this, _autoExpandDepth)[_autoExpandDepth]);
}
function _createDisabledNodes2() {
  var rootDataObjects = this.data.rootObjects;
  for (var objectId in rootDataObjects) {
    var dataObject = rootDataObjects[objectId];
    var dataObjectType = dataObject.type;
    var name = dataObject.name;
    var rootName = name && name !== "" && name !== "Undefined" && name !== "Default" ? name : "" + dataObjectType; // TODO: type is a number - needs to be human-readable
    var ul = document.createElement('ul');
    var li = document.createElement('li');
    ul.appendChild(li);
    _classPrivateFieldLooseBase(this, _containerElement)[_containerElement].appendChild(ul);
    _classPrivateFieldLooseBase(this, _rootElement)[_rootElement] = ul;
    var switchElement = document.createElement('a');
    switchElement.href = '#';
    switchElement.textContent = '!';
    switchElement.classList.add('warn');
    switchElement.classList.add('warning');
    li.appendChild(switchElement);
    var span = document.createElement('span');
    span.textContent = rootName;
    li.appendChild(span);
  }
}
function _findEmptyNodes2() {
  var rootDataObjects = this.data.rootObjects;
  for (var objectId in rootDataObjects) {
    _classPrivateFieldLooseBase(this, _findEmptyNodes3)[_findEmptyNodes3](rootDataObjects[objectId]);
  }
}
function _findEmptyNodes4(dataObject) {
  var viewer = _classPrivateFieldLooseBase(this, _viewer)[_viewer];
  var scene = viewer.scene;
  var aggregations = dataObject.related[_classPrivateFieldLooseBase(this, _linkType)[_linkType]];
  var objectId = dataObject.id;
  var viewObject = scene.objects[objectId];
  var sceneObjectCounts = 0;
  if (viewObject) {
    sceneObjectCounts++;
  }
  if (aggregations) {
    for (var i = 0, len = aggregations.length; i < len; i++) {
      var aggregation = aggregations[i];
      var aggregatedDataObject = aggregation.relatedObject;
      var aggregatedCount = _classPrivateFieldLooseBase(this, _findEmptyNodes3)[_findEmptyNodes3](aggregatedDataObject);
      _classPrivateFieldLooseBase(this, _dataObjectSceneObjectCounts)[_dataObjectSceneObjectCounts][aggregatedDataObject.id] = aggregatedCount;
      sceneObjectCounts += aggregatedCount;
    }
  }
  _classPrivateFieldLooseBase(this, _dataObjectSceneObjectCounts)[_dataObjectSceneObjectCounts][dataObject.id] = sceneObjectCounts;
  return sceneObjectCounts;
}
function _buildGroupsNodes2() {
  var rootDataObjects = this.data.rootObjects;
  for (var id in rootDataObjects) {
    _classPrivateFieldLooseBase(this, _buildGroupsNodes3)[_buildGroupsNodes3](rootDataObjects[id], [], null, null, null);
  }
}
function _buildGroupsNodes4(dataObject, pathNodes, buildingNode, storeyNode, typeNodes) {
  if (_classPrivateFieldLooseBase(this, _pruneEmptyNodes)[_pruneEmptyNodes] && !_classPrivateFieldLooseBase(this, _dataObjectSceneObjectCounts)[_dataObjectSceneObjectCounts][dataObject.id]) {
    return;
  }
  var objectId = dataObject.id;
  var type = dataObject.type;
  var name = dataObject.name;
  var aggregations = dataObject.related[_classPrivateFieldLooseBase(this, _linkType)[_linkType]];
  if (pathNodes.length < _classPrivateFieldLooseBase(this, _groupTypes)[_groupTypes].length) {
    var groupType = _classPrivateFieldLooseBase(this, _groupTypes)[_groupTypes][pathNodes.length];
    if (pathNodes.length === 0) {
      if (type === groupType) {
        var node = {
          nodeId: objectId,
          objectId: objectId,
          title: _classPrivateFieldLooseBase(this, _rootName)[_rootName] || (name && name !== "" && name !== "Undefined" && name !== "Default" ? name : type),
          type: type,
          parentNode: null,
          numViewObjects: 0,
          numVisibleViewObjects: 0,
          checked: false,
          xrayed: false,
          childNodes: []
        };
        pathNodes.push(node);
        _classPrivateFieldLooseBase(this, _rootNodes)[_rootNodes].push(node);
        _classPrivateFieldLooseBase(this, _objectNodes)[_objectNodes][node.objectId] = node;
      }
    } else {
      if (type === groupType) {
        var parentNode = pathNodes[pathNodes.length - 1];
        var _node2 = {
          nodeId: objectId,
          objectId: objectId,
          title: name && name !== "" && name !== "Undefined" && name !== "Default" ? name : "" + type,
          type: type,
          parentNode: parentNode,
          numViewObjects: 0,
          numVisibleViewObjects: 0,
          checked: false,
          xrayed: false,
          childNodes: []
        };
        parentNode.childNodes.push(_node2);
        pathNodes.push(_node2);
        _classPrivateFieldLooseBase(this, _objectNodes)[_objectNodes][_node2.objectId] = _node2;
      }
    }
  } else {
    var _parentNode = pathNodes[pathNodes.length - 1];
    var viewObjects = this.view.objects;
    var viewObject = viewObjects[objectId];
    // TODO: makes assumptions about leaves having ViewObjects; can be more flexible
    // TODO: Only makes nodes for objects that have geometric representations, ie. ViewObjects
    if (viewObject) {
      // Grouped leaf nodes, only for nodes that have ViewObjects
      typeNodes = typeNodes || {};
      var typeNode = typeNodes[type];
      if (!typeNode) {
        var typeNodeObjectId = _parentNode.objectId + "." + type;
        var typeNodeNodeId = typeNodeObjectId;
        typeNode = {
          nodeId: typeNodeNodeId,
          objectId: typeNodeObjectId,
          title: "" + type,
          type: type,
          parentNode: _parentNode,
          numViewObjects: 0,
          numVisibleViewObjects: 0,
          checked: false,
          xrayed: false,
          childNodes: []
        };
        _parentNode.childNodes.push(typeNode);
        _classPrivateFieldLooseBase(this, _objectNodes)[_objectNodes][typeNodeObjectId] = typeNode;
        typeNodes[type] = typeNode;
      }
      var leafNode = {
        nodeId: objectId,
        objectId: objectId,
        title: name && name !== "" && name !== "Undefined" && name !== "Default" ? name : "" + type,
        type: type,
        parentNode: typeNode,
        numViewObjects: 0,
        numVisibleViewObjects: 0,
        checked: false,
        xrayed: false,
        childNodes: []
      };
      typeNode.childNodes.push(leafNode);
      _classPrivateFieldLooseBase(this, _objectNodes)[_objectNodes][leafNode.objectId] = leafNode;
    }
  }
  if (aggregations) {
    for (var i = 0, len = aggregations.length; i < len; i++) {
      var aggregation = aggregations[i];
      var aggregatedDataObject = aggregation.relatedObject;
      _classPrivateFieldLooseBase(this, _buildGroupsNodes3)[_buildGroupsNodes3](aggregatedDataObject, pathNodes, buildingNode, storeyNode, typeNodes);
    }
  }
}
function _buildTypesNodes2() {
  var rootDataObjects = this.data.rootObjects;
  for (var id in rootDataObjects) {
    _classPrivateFieldLooseBase(this, _buildTypesNodes3)[_buildTypesNodes3](rootDataObjects[id], null, null);
  }
}
function _buildTypesNodes4(dataObject, rootNode, typeNodes) {
  if (_classPrivateFieldLooseBase(this, _pruneEmptyNodes)[_pruneEmptyNodes] && !_classPrivateFieldLooseBase(this, _dataObjectSceneObjectCounts)[_dataObjectSceneObjectCounts][dataObject.id]) {
    return;
  }
  var aggregations = dataObject.related[_classPrivateFieldLooseBase(this, _linkType)[_linkType]];
  // if (dataObject.id === this.#rootdataObject.id) {
  //     rootNode = {
  //         nodeId: objectId,
  //         objectId: objectId,
  //         title: this.#rootName || ((name && name !== "" && name !== "Undefined" && name !== "Default")
  //             ? name
  //             : type),
  //         type: type,
  //         parentNode: null,
  //         numViewObjects: 0,
  //         numVisibleViewObjects: 0,
  //         checked: false,
  //         xrayed: false,
  //         childNodes: []
  //     };
  //     this.#rootNodes.push(rootNode);
  //     this.#objectNodes[rootNode.objectId] = rootNode;
  //     typeNodes = {};
  // } else {
  //     if (rootNode) {
  //         const objects = this.#viewer.scene.objects;
  //         const object = objects[objectId];
  //         if (object) {
  //             let typeNode = typeNodes[type];
  //             if (!typeNode) {
  //                 typeNode = {
  //                     nodeId: rootNode.objectId + "." + type,
  //                     objectId: rootNode.objectId + "." + type,
  //                     title: `${type}`,
  //                     type: type,
  //                     parentNode: rootNode,
  //                     numViewObjects: 0,
  //                     numVisibleViewObjects: 0,
  //                     checked: false,
  //                     xrayed: false,
  //                     childNodes: []
  //                 };
  //                 rootNode.childNodes.push(typeNode);
  //                 this.#objectNodes[typeNode.objectId] = typeNode;
  //                 typeNodes[type] = typeNode;
  //             }
  //             const node: TreeViewNode = {
  //                 nodeId: objectId,
  //                 objectId: objectId,
  //                 title: (name && name !== "" && name !== "Default")
  //                     ? name
  //                     : `${type}`,
  //                 type: type,
  //                 parentNode: typeNode,
  //                 numViewObjects: 0,
  //                 numVisibleViewObjects: 0,
  //                 checked: false,
  //                 xrayed: false,
  //                 childNodes: []
  //             };
  //             typeNode.childNodes.push(node);
  //             this.#objectNodes[node.objectId] = node;
  //         }
  //     }
  // }
  if (aggregations) {
    for (var i = 0, len = aggregations.length; i < len; i++) {
      var aggregation = aggregations[i];
      var aggregatedDataObject = aggregation.relatedObject;
      _classPrivateFieldLooseBase(this, _buildTypesNodes3)[_buildTypesNodes3](aggregatedDataObject, rootNode, typeNodes);
    }
  }
}
function _buildAggregationNodes2() {
  var rootDataObjects = this.data.rootObjects;
  for (var id in rootDataObjects) {
    _classPrivateFieldLooseBase(this, _buildAggregationNodes3)[_buildAggregationNodes3](rootDataObjects[id], null);
  }
}
function _buildAggregationNodes4(dataObject, parentNode) {
  if (_classPrivateFieldLooseBase(this, _pruneEmptyNodes)[_pruneEmptyNodes] && !_classPrivateFieldLooseBase(this, _dataObjectSceneObjectCounts)[_dataObjectSceneObjectCounts][dataObject.id]) {
    return;
  }
  var objectId = dataObject.id;
  var type = dataObject.type;
  var name = dataObject.name || type;
  var aggregations = dataObject.related[_classPrivateFieldLooseBase(this, _linkType)[_linkType]];
  var node = {
    nodeId: objectId,
    objectId: objectId,
    title: !parentNode ? _classPrivateFieldLooseBase(this, _rootName)[_rootName] || name : name && name !== "" && name !== "Undefined" && name !== "Default" ? name : type,
    type: type,
    parentNode: parentNode,
    numViewObjects: 0,
    numVisibleViewObjects: 0,
    checked: false,
    xrayed: false,
    childNodes: []
  };
  if (parentNode) {
    parentNode.childNodes.push(node);
  } else {
    _classPrivateFieldLooseBase(this, _rootNodes)[_rootNodes].push(node);
  }
  _classPrivateFieldLooseBase(this, _objectNodes)[_objectNodes][node.objectId] = node;
  if (aggregations) {
    for (var i = 0, len = aggregations.length; i < len; i++) {
      var aggregation = aggregations[i];
      var aggregatedDataObject = aggregation.relatedObject;
      _classPrivateFieldLooseBase(this, _buildAggregationNodes3)[_buildAggregationNodes3](aggregatedDataObject, node);
    }
  }
}
function _doSortNodes2() {
  for (var i = 0, len = _classPrivateFieldLooseBase(this, _rootNodes)[_rootNodes].length; i < len; i++) {
    var rootNode = _classPrivateFieldLooseBase(this, _rootNodes)[_rootNodes][i];
    _classPrivateFieldLooseBase(this, _sortChildNodes)[_sortChildNodes](rootNode);
  }
}
function _sortChildNodes2(node) {
  // const childNodes = node.childNodes;
  // if (!childNodes || childNodes.length === 0) {
  //     return;
  // }
  // if (this.#hierarchy === "storeys" && node.type === "IfcBuilding") {
  //     // Assumes that childNodes of an IfcBuilding will always be IfcBuildingStoreys
  //     childNodes.sort(this.#getSpatialSortFunc());
  // } else {
  //     childNodes.sort(this.#alphaSortFunc);
  // }
  // for (let i = 0, len = childNodes.length; i < len; i++) {
  //     const node = childNodes[i];
  //     this.#sortChildNodes(node);
  // }
}
function _getSpatialSortFunc2() {
  // const viewer = this.#viewer;
  // const scene = viewer.scene;
  // const camera = scene.camera;
  // const metaScene = viewer.metaScene;
  // return this.#spatialSortFunc || (this.#spatialSortFunc = (node1, node2) => {
  //     if (!node1.aabb || !node2.aabb) {
  //         // Sorting on lowest point of the AABB is likely more more robust when objects could overlap storeys
  //         if (!node1.aabb) {
  //             node1.aabb = scene.getAABB(metaScene.getObjectIDsInSubtree(node1.objectId));
  //         }
  //         if (!node2.aabb) {
  //             node2.aabb = scene.getAABB(metaScene.getObjectIDsInSubtree(node2.objectId));
  //         }
  //     }
  //     let idx = 0;
  //     if (camera.xUp) {
  //         idx = 0;
  //     } else if (camera.yUp) {
  //         idx = 1;
  //     } else {
  //         idx = 2;
  //     }
  //     if (node1.aabb[idx] > node2.aabb[idx]) {
  //         return -1;
  //     }
  //     if (node1.aabb[idx] < node2.aabb[idx]) {
  //         return 1;
  //     }
  //     return 0;
  // });
}
function _alphaSortFunc2(node1, node2) {
  var title1 = node1.title.toUpperCase(); // FIXME: Should be case sensitive?
  var title2 = node2.title.toUpperCase();
  if (title1 < title2) {
    return -1;
  }
  if (title1 > title2) {
    return 1;
  }
  return 0;
}
function _synchNodesToEntities2() {
  var objectIds = Object.keys(this.data.objects);
  var dataObjects = this.data.objects;
  var viewObjects = this.view.objects;
  for (var i = 0, len = objectIds.length; i < len; i++) {
    var objectId = objectIds[i];
    var dataObject = dataObjects[objectId];
    if (dataObject) {
      var node = _classPrivateFieldLooseBase(this, _objectNodes)[_objectNodes][objectId];
      if (node) {
        var viewObject = viewObjects[objectId];
        if (viewObject) {
          var visible = viewObject.visible;
          node.numViewObjects = 1;
          node.xrayed = viewObject.xrayed;
          if (visible) {
            node.numVisibleViewObjects = 1;
            node.checked = true;
          } else {
            node.numVisibleViewObjects = 0;
            node.checked = false;
          }
          var parentNode = node.parentNode; // Synch parents
          while (parentNode) {
            parentNode.numViewObjects++;
            if (visible) {
              parentNode.numVisibleViewObjects++;
              parentNode.checked = true;
            }
            parentNode = parentNode.parentNode;
          }
        }
      }
    }
  }
}
function _withNodeTree2(node, callback) {
  callback(node);
  var childNodes = node.childNodes;
  if (!childNodes) {
    return;
  }
  for (var i = 0, len = childNodes.length; i < len; i++) {
    _classPrivateFieldLooseBase(this, _withNodeTree)[_withNodeTree](childNodes[i], callback);
  }
}
function _createNodeElements2() {
  var _this4 = this;
  if (_classPrivateFieldLooseBase(this, _rootNodes)[_rootNodes].length === 0) {
    return;
  }
  var rootNodeElements = _classPrivateFieldLooseBase(this, _rootNodes)[_rootNodes].map(function (rootNode) {
    return _classPrivateFieldLooseBase(_this4, _createNodeElement)[_createNodeElement](rootNode);
  });
  var ul = document.createElement('ul');
  rootNodeElements.forEach(function (nodeElement) {
    ul.appendChild(nodeElement);
  });
  _classPrivateFieldLooseBase(this, _containerElement)[_containerElement].appendChild(ul);
  _classPrivateFieldLooseBase(this, _rootElement)[_rootElement] = ul;
}
function _createNodeElement2(node) {
  var _this5 = this;
  var nodeElement = document.createElement('li');
  //const nodeId = this.#objectToNodeID(node.objectId);
  var nodeId = node.nodeId;
  if (node.xrayed) {
    nodeElement.classList.add('xrayed-node');
  }
  nodeElement.id = 'node-' + nodeId;
  if (node.childNodes.length > 0) {
    var switchElementId = "switch-" + nodeId;
    var switchElement = document.createElement('a');
    switchElement.href = '#';
    switchElement.id = switchElementId;
    switchElement.textContent = '+';
    switchElement.classList.add('plus');
    switchElement.addEventListener('click', _classPrivateFieldLooseBase(this, _switchExpandHandler)[_switchExpandHandler]);
    nodeElement.appendChild(switchElement);
  }
  var checkbox = document.createElement('input');
  checkbox.id = nodeId;
  checkbox.type = "checkbox";
  checkbox.checked = node.checked;
  // @ts-ignore
  checkbox.style["pointer-events"] = "all";
  // @ts-ignore
  checkbox.addEventListener("change", _classPrivateFieldLooseBase(this, _checkboxChangeHandler)[_checkboxChangeHandler]);
  nodeElement.appendChild(checkbox);
  var span = document.createElement('span');
  span.textContent = node.title;
  nodeElement.appendChild(span);
  span.oncontextmenu = function (e) {
    _this5.onContextMenu.dispatch(_this5, {
      event: e,
      treeView: _this5,
      treeViewNode: node
    });
    e.preventDefault();
  };
  span.onclick = function (e) {
    _this5.onNodeTitleClicked.dispatch(_this5, {
      event: e,
      treeView: _this5,
      treeViewNode: node
    });
    e.preventDefault();
  };
  return nodeElement;
}
function _expandSwitchElement2(switchElement) {
  var _this6 = this;
  var parentElement = switchElement.parentElement;
  if (!parentElement) {
    return;
  }
  var expanded = parentElement.getElementsByTagName('li')[0];
  if (expanded) {
    return;
  }
  var nodeId = parentElement.id.replace('node-', '');
  var objectId = nodeId;
  var switchNode = _classPrivateFieldLooseBase(this, _objectNodes)[_objectNodes][objectId];
  var childNodes = switchNode.childNodes;
  var nodeElements = childNodes.map(function (node) {
    return _classPrivateFieldLooseBase(_this6, _createNodeElement)[_createNodeElement](node);
  });
  var ul = document.createElement('ul');
  nodeElements.forEach(function (nodeElement) {
    ul.appendChild(nodeElement);
  });
  parentElement.appendChild(ul);
  switchElement.classList.remove('plus');
  switchElement.classList.add('minus');
  switchElement.textContent = '-';
  switchElement.removeEventListener('click', _classPrivateFieldLooseBase(this, _switchExpandHandler)[_switchExpandHandler]);
  switchElement.addEventListener('click', _classPrivateFieldLooseBase(this, _switchCollapseHandler)[_switchCollapseHandler]);
}
function _collapseNode2(objectId) {
  var nodeId = objectId;
  var switchElementId = "switch-" + nodeId;
  var switchElement = document.getElementById(switchElementId);
  if (!switchElement) {
    return;
  }
  _classPrivateFieldLooseBase(this, _collapseSwitchElement)[_collapseSwitchElement](switchElement);
}
function _collapseSwitchElement2(switchElement) {
  if (!switchElement) {
    return;
  }
  var parent = switchElement.parentElement;
  if (!parent) {
    return;
  }
  var ul = parent.querySelector('ul');
  if (!ul) {
    return;
  }
  parent.removeChild(ul);
  switchElement.classList.remove('minus');
  switchElement.classList.add('plus');
  switchElement.textContent = '+';
  switchElement.removeEventListener('click', _classPrivateFieldLooseBase(this, _switchCollapseHandler)[_switchCollapseHandler]);
  switchElement.addEventListener('click', _classPrivateFieldLooseBase(this, _switchExpandHandler)[_switchExpandHandler]);
}
/**
 * Hierarchy mode that arranges the {@link TreeViewNode | TreeViewNodes} as an aggregation hierarchy.
 *
 * The mode creates a TreeViewNode hierarchy that mirrors that of the
 * {@link @xeokit/data!DataObject | DataObjects} and
 * aggregation {@link @xeokit/data!Relationship | Relationships} in the {@link @xeokit/data!Data | Data}.
 *
 * In this hierarchy, each TreeViewNode corresponds to a DataObject in the Data. The TreeViewNodes are connected
 * into a hierarchy that reflects a depth-first traversal from the root DataObjects that follows each DataObject's
 * outgoing Relationships of the type given in {@link TreeView.linkType | TreeView.linkType}.
 */
TreeView.AggregationHierarchy = void 0;
/**
 * Hierarchy mode that groups the {@link TreeViewNode | TreeViewNodes} by type.
 *
 * This mode creates a two-level hierarchy. At the root level, we get TreeViewNodes that represent each of the
 * distinct types in our {@link @xeokit/data!Data | Data}. Each of those gets one or more child TreeViewNodes
 * that represent {@link @xeokit/data!DataObject | DataObjects} of that type. When those DataObjects have
 * {@link @xeokit/viewer!ViewObject | ViewObjects} of the same ID, then the TreeViewNodes will have checkboxes
 * that we can use to show, hide, and X-ray their ViewObjects.
 */
TreeView.TypesHierarchy = void 0;
/**
 * Hierarchy mode that arranges the {@link TreeViewNode | TreeViewNodes} into an n-level grouped hierarchy.
 *
 * This mode creates a multi-level grouped hierarchy, following the order given
 * in {@link TreeViewParams.groupTypes | TreeViewParams.groupTypes}. The TreeViewNodes at level 0 are all the same
 * type as ````TreeViewParams.groupTypes[0]````, TreeViewNodes at level 1 are all the same type
 * as ````TreeViewParams.groupTypes[2]````, and so on. Once descended beyond the length of ````TreeViewParams.groupTypes````,
 * the TreeViewNodes are just grouped by type.
 */
TreeView.GroupsHierarchy = void 0;

/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2Ftreeview.svg)](https://badge.fury.io/js/%40xeokit%2Ftreeview)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/treeview/badge)](https://www.jsdelivr.com/package/npm/@xeokit/treeview)
 *
 * <img style="padding:0px; padding-top:30px; padding-bottom:30px;" src="media://images/tree_view_icon.png"/>
 *
 * <br>
 *
 * ## xeokit Tree View UI
 *
 * * {@link @xeokit/treeview!TreeView}
 * * Fast HTML tree view to navigate federated models in a {@link @xeokit/viewer!Viewer}
 * * Use with a {@link @xeokit/viewer!View | View} and a semantic {@link @xeokit/data!Data} model
 * * Supports Industry Foundation Classes ([IFC](https://xeokit.github.io/sdk/docs/pages/GLOSSARY.html#ifc))
 * * Supports any schema expressable as ER graph with aggregation relationships
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/treeview
 * ````
 *
 * ## Usage
 *
 * TODO
 *
 * ````javascript
 * import {Viewer} from "@xeokit/viewer";
 * import {WebGLRenderer} from "@xeokit/webglrenderer";
 * import {Data} from "@xeokit/data";
 * import * as ifcTypes from "@xeokit/ifctypes";
 * import {TreeView} from "@xeokit/treeview!TreeView";
 * import {loadXKT} from "@xeokit/xkt";
 * ````
 *
 * Create a {@link @xeokit/viewer!Viewer}, configured with a {@link @xeokit/webglrenderer!WebGLRenderer}:
 *
 * ````javascript
 * const myViewer = new Viewer({
 *     id: "myViewer",
 *     renderer: new WebGLRenderer({ })
 * });
 * ````
 *
 * Create a {@link @xeokit/viewer!View} and position the {@link @xeokit/viewer!Camera}:
 *
 * ````javascript
 * const view1 = myViewer.createView({
 *     id: "myView",
 *     canvasId: "myView1"
 * });
 *
 * view1.camera.eye = [-3.933, 2.855, 27.018];
 * view1.camera.look = [4.400, 3.724, 8.899];
 * view1.camera.up = [-0.018, 0.999, 0.039];
 *
 * const data = new Data();
 * ````
 *
 * Create a {@link @xeokit/treeview!TreeView}, configured to show TODO:
 *
 * ````javascript
 * const treeView = new TreeView({
 *
 *     view: myView,
 *     data: myData,
 *
 *     containerElement: document.getElementById("myTreeViewContainer"),
 *
 *     hierarchy: TreeView.GroupsHierarchy,
 *     linkType: ifcTypes.IfcRelAggregates,
 *     groupTypes: [ifcTypes.IfcBuilding, ifcTypes.IfcBuildingStorey]
 * });
 *
 * const sceneModel = new SceneModel(); // SceneModel implements SceneModel
 *
 * const dataModel = data.createModel({
 *     id: "myModel"
 * });
 *
 * fetch("myModel.xkt").then(response => {
 *
 *     response.arrayBuffer().then(data => {
 *
 *          loadXKT({ data, sceneModel, dataModel });
 *
 *          sceneModel.build();
 *          dataModel.build();
 *
 *          myViewer.scene.addModel({ id: "myModel", sceneModel });
 *     });
 * });
 * ````
 *
 * @module @xeokit/treeview
 */

var index = {
  __proto__: null,
  TreeView: TreeView
};

export { index$a as basictypes, index$1 as bcf, index$g as boundaries, index$2 as cameracontrol, index$7 as cityjson, index$9 as cityjsontypes, index$h as compression, index$l as constants, index$m as core, index$e as curves, index$c as data, index$6 as dotbim, index$8 as ifctypes, index$3 as ktx2, index$d as locale, index$k as math, index$j as matrix, index$4 as mockrenderer, index$f as rtc, index$b as scene, index as treeview, index$i as utils, index$5 as viewer };
//# sourceMappingURL=xeokit-bundle.js.map
